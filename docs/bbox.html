<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>bbox API documentation</title>
<meta name="description" content="Bounding box utility functions ###
Various utility functions to work with bounding boxes and gdal â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>bbox</code></h1>
</header>
<section id="section-intro">
<h3 id="bounding-box-utility-functions">Bounding box utility functions</h3>
<p>Various utility functions to work with bounding boxes and gdal.</p>
<p>There are two different formats for bounding boxes used by GDAL:</br>
WARP: <code>[x_min, y_min, x_max, y_max]</code></br>
OGR:
<code>[x_min, x_max, y_min, y_max]</code></br></p>
<p><em>If nothing else is stated, the OGR format is used.</em></p>
<p>The GDAL geotransform is a list of six parameters:</br>
<code>x_min, pixel_width, row_skew, y_max, column_skew, pixel_height (negative for north-up)</code></p>
<h2 id="todo">Todo</h2>
<ul>
<li>create tests</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
### Bounding box utility functions ###
Various utility functions to work with bounding boxes and gdal.

There are two different formats for bounding boxes used by GDAL:&lt;/br&gt;
WARP: `[x_min, y_min, x_max, y_max]`&lt;/br&gt;
OGR:  `[x_min, x_max, y_min, y_max]`&lt;/br&gt;

_If nothing else is stated, the OGR format is used._

The GDAL geotransform is a list of six parameters:&lt;/br&gt;
`x_min, pixel_width, row_skew, y_max, column_skew, pixel_height (negative for north-up)`

TODO:
    * create tests
&#34;&#34;&#34;

# Standard library
from uuid import uuid4

# External
from osgeo import ogr, osr, gdal

# Internal
from core import is_number, get_unix_seconds_as_str # pylint: disable=import-error



def is_valid_bbox(bbox_ogr):
    &#34;&#34;&#34;
    Checks if a bbox is valid.

    A valid ogr formatted bbox has the form:
    `[x_min, x_max, y_min, y_max]`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    **True** if the bbox is valid, **False** otherwise.
    &#34;&#34;&#34;
    if not isinstance(bbox_ogr, list):
        return False

    if len(bbox_ogr) != 4:
        return False

    for val in bbox_ogr:
        if not is_number(val):
            return False

    x_min, x_max, y_min, y_max = bbox_ogr

    if x_min &gt; x_max or y_min &gt; y_max:
        return False

    return True


def is_valid_geotransform(geotransform):
    &#34;&#34;&#34;
    Checks if a geotransform is valid.
    
    A valid geotransform has the form:
    ```python
    [x_min, pixel_width, row_skew, y_max, column_skew, pixel_height]
    ```

    ## Args:
    `geotransform` (_list_ || _tuple_): A GDAL formatted geotransform.

    ## Returns:
    **True** if the geotransform is valid, **False** otherwise.
    &#34;&#34;&#34;
    if not isinstance(geotransform, (list, tuple)):
        return False

    if len(geotransform) != 6:
        return False

    for val in geotransform:
        if not is_number(val):
            return False

    return True


def ensure_negative(number):
    &#34;&#34;&#34;
    Ensures that a valid is negative. If the number is positive, it is made negative.

    ## Args:
    `number` (_int_ || _float_): A float or int number. &lt;/br&gt;

    ## Returns:
    (_int_ || _float_): The same number made **negative** if necesary.
    &#34;&#34;&#34;
    assert is_number(number), f&#34;number must be a number. Received: {number}&#34;

    if number &lt;= 0:
        return -number

    return number


def get_pixel_offsets(geotransform, bbox_ogr):
    &#34;&#34;&#34;
    Get the pixels offsets for a bbox and a geotransform.

    ## Args:
    `geotransform` (_list_ || _tuple_): A GDAL GeoTransform. &lt;/br&gt;
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): A list of pixel offsets. `[x_start, y_start, x_size, y_size]`
    &#34;&#34;&#34;
    assert is_valid_geotransform(
        geotransform
    ), f&#34;geotransform must be a list of length six. Received: {geotransform}.&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr must be a valid OGR formatted bbox. Received: {bbox_ogr}.&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    origin_x = geotransform[0]
    origin_y = geotransform[3]
    pixel_width = abs(geotransform[1])
    pixel_height = abs(geotransform[5])

    x_1 = int((x_min - origin_x) / pixel_width)
    x_2 = int((x_max - origin_x) / pixel_width) + 1

    y_1 = int((y_max - origin_y) / pixel_height)
    y_2 = int((y_min - origin_y) / pixel_height) + 1

    x_size = x_2 - x_1
    y_size = y_2 - y_1

    x_start = x_1
    y_start = y_1

    return [x_start, y_start, x_size, y_size]


def get_bbox_from_geotransform(geotransform, raster_x_size, raster_y_size):
    &#34;&#34;&#34;
    Get an OGR bounding box from a geotransform and raster sizes.

    ## Args:
    `geotransform` (_list_ || _tuple_): A GDAL GeoTransform. &lt;/br&gt;
    `raster_x_size` (_int_): The number of pixels in the x direction. &lt;/br&gt;
    `raster_y_size` (_int_): The number of pixels in the y direction. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert is_valid_geotransform(
        geotransform
    ), f&#34;geotransform was not a valid geotransform. Received: {geotransform}&#34;

    x_min, pixel_width, _row_skew, y_max, _column_skew, pixel_height = geotransform

    x_max = x_min + (raster_x_size * pixel_width)
    y_min = y_max + (raster_y_size * pixel_height)

    return [x_min, x_max, y_min, y_max]


def get_bbox_from_raster(raster_dataframe):
    &#34;&#34;&#34;
    Gets an OGR bounding box from a GDAL raster dataframe.

    ## Args:
    `raster_dataframe` (_gdal.DataFrame_): A GDAL raster dataframe. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        raster_dataframe, gdal.Dataset
    ), f&#34;raster_dataframe was not a gdal.Datasource. Received: {raster_dataframe}&#34;

    bbox = get_bbox_from_geotransform(
        raster_dataframe.GetGeoTransform(),
        raster_dataframe.RasterXSize,
        raster_dataframe.RasterYSize,
    )

    return bbox


def get_bbox_from_vector(vector_dataframe):
    &#34;&#34;&#34;
    Gets an OGR bounding box from an OGR dataframe.

    ## Args:
    `vector_dataframe` (_ogr.DataSource_): An OGR vector dataframe. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        vector_dataframe, ogr.DataSource
    ), f&#34;vector_dataframe was not a valid ogr.DataSource. Received: {vector_dataframe}&#34;

    layer_count = vector_dataframe.GetLayerCount()

    assert (
        layer_count &gt; 0
    ), f&#34;vector_dataframe did not contain any layers. Received: {vector_dataframe}&#34;

    x_min = None
    x_max = None
    y_min = None
    y_max = None

    for layer_index in range(layer_count):
        layer = vector_dataframe.GetLayerByIndex(layer_index)
        layer_x_min, layer_x_max, layer_y_min, layer_y_max = layer.GetExtent()

        if layer_index == 0:
            x_min = layer_x_min
            x_max = layer_x_max
            y_min = layer_y_min
            y_max = layer_y_max
        else:
            if layer_x_min &lt; x_min:
                x_min = layer_x_min
            if layer_x_max &gt; x_max:
                x_max = layer_x_max
            if layer_y_min &lt; y_min:
                y_min = layer_y_min
            if layer_y_max &gt; y_max:
                y_max = layer_y_max

    return [x_min, x_max, y_min, y_max]


def get_bbox_from_vector_layer(vector_layer):
    &#34;&#34;&#34;
    Gets an OGR bounding box from an OGR dataframe layer.

    ## Args:
    `vector_layer` (_ogr.Layer_): An OGR vector dataframe layer. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        vector_layer, ogr.Layer
    ), f&#34;vector_layer was not a valid ogr.Layer. Received: {vector_layer}&#34;

    x_min, x_max, y_min, y_max = vector_layer.GetExtent()

    return [x_min, x_max, y_min, y_max]


def get_sub_geotransform(geotransform, bbox_ogr):
    &#34;&#34;&#34;
    Create a GeoTransform and the raster sizes for an OGR formatted bbox.

    ## Args:
    `geotransform` (_list_): A GDAL geotransform. &lt;/br&gt;
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_dict_): { &#34;Transform&#34;: _list_, &#34;RasterXSize&#34;: _int_, &#34;RasterYSize&#34;: _int_ }
    &#34;&#34;&#34;
    assert is_valid_geotransform(
        geotransform
    ), f&#34;geotransform must be a valid geotransform. Received: {geotransform}.&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr
    pixel_width = geotransform[1]
    pixel_height = geotransform[5]

    raster_x_size = round((x_max - x_min) / pixel_width)
    raster_y_size = round((y_max - y_min) / pixel_height)

    return {
        &#34;Transform&#34;: [x_min, pixel_width, 0, y_max, 0, ensure_negative(pixel_height)],
        &#34;RasterXSize&#34;: abs(raster_x_size),
        &#34;RasterYSize&#34;: abs(raster_y_size),
    }


def convert_bbox_to_geom(bbox_ogr):
    &#34;&#34;&#34;
    Convert an OGR bounding box to ogr.Geometry.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; ogr.Geometry`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_ogr.Geometry_): An OGR geometry.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    ring = ogr.Geometry(ogr.wkbLinearRing)
    ring.AddPoint(x_min, y_min)
    ring.AddPoint(x_max, y_min)
    ring.AddPoint(x_max, y_max)
    ring.AddPoint(x_min, y_max)
    ring.AddPoint(x_min, y_min)

    geom = ogr.Geometry(ogr.wkbPolygon)
    geom.AddGeometry(ring)

    return geom


def convert_geom_to_bbox(geom):
    &#34;&#34;&#34;
    Convert an ogr.Geometry to an OGR bounding box.&lt;/br&gt;
    `ogr.Geometry -&gt; [x_min, x_max, y_min, y_max]`

    ## Args:
    `geom` (_ogr.Geometry_): An OGR geometry. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        geom, ogr.Geometry
    ), f&#34;geom was not a valid ogr.Geometry. Received: {geom}&#34;

    bbox_ogr = geom.GetEnvelope()

    return bbox_ogr  # [x_min, x_max, y_min, y_max]


def convert_bbox_to_geotransform(bbox_ogr, raster_x_size, raster_y_size):
    &#34;&#34;&#34;
    Convert an OGR formatted bounding box to a GDAL GeoTransform.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; [x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `raster_x_size` (_int_): The number of pixels in the x direction. &lt;/br&gt;
    `raster_y_size` (_int_): The number of pixels in the y direction. &lt;/br&gt;

    ## Returns:
    (_list_): A GDAL GeoTransform. `[x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    origin_x = x_min
    origin_y = y_max
    pixel_width = (x_max - x_min) / raster_x_size
    pixel_height = (y_max - y_min) / raster_y_size

    return [origin_x, pixel_width, 0, origin_y, 0, ensure_negative(pixel_height)]


def convert_ogr_bbox_to_gdal_bbox(bbox_ogr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to a GDAL formatted one.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; [x_min, y_min, x_max, y_max]`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): A GDAL formatted bbox. `[x_min, y_min, x_max, y_max]`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    return [x_min, y_min, x_max, y_max]


def convert_gdal_bbox_to_ogr_bbox(bbox_gdal):
    &#34;&#34;&#34;
    Converts a GDAL formatted bbox to an OGR formatted one.&lt;/br&gt;
    `[x_min, y_min, x_max, y_max] -&gt; [x_min, x_max, y_min, y_max]`

    ## Args:
    `bbox_gdal` (_list_): A GDAL formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert (
        isinstance(bbox_gdal, list) and len(bbox_gdal) == 4
    ), f&#34;bbox_gdal must be a list of length four. Received: {bbox_gdal}.&#34;

    x_min, y_min, x_max, y_max = bbox_gdal

    return [x_min, x_max, y_min, y_max]


def convert_bbox_to_wkt(bbox_ogr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to a WKT string.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; WKT`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_str_): A WKT Polygon string. `POLYGON ((...))`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    wkt = f&#34;POLYGON (({x_min} {y_min}, {x_max} {y_min}, {x_max} {y_max}, {x_min} {y_max}, {x_min} {y_min}))&#34;

    return wkt


def convert_bbox_to_geojson(bbox_ogr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to a GeoJson dictionary.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; GeoJson`

    ## Args:
    `bbox_ogr` (_list_): an OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_dict_): A GeoJson Dictionary. `{ &#34;type&#34;: &#34;Polygon&#34;, &#34;coordinates&#34;: [ ... ] }`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    geojson = {
        &#34;type&#34;: &#34;Polygon&#34;,
        &#34;coordinates&#34;: [
            [
                [x_min, y_min],
                [x_max, y_min],
                [x_max, y_max],
                [x_min, y_max],
                [x_min, y_min],
            ]
        ],
    }

    return geojson


def convert_bbox_to_vector(bbox_ogr, projection_osr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to an in-memory vector.&lt;/br&gt;
    _Vectors are stored in /vsimem/ as .fgb files._&lt;/br&gt;
    **OBS**: Layers should be manually cleared when no longer used.

    ## Args:
    `bbox_ogr` (_list_): an OGR formatted bbox. &lt;/br&gt;
    `projection_osr` (_osr.SpatialReference_): The projection of the vector. &lt;/br&gt;

    ## Returns:
    (_ogr.DataSource_): The bounding box as a vector.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;
    assert isinstance(
        projection_osr, osr.SpatialReference
    ), f&#34;projection_osr not a valid spatial reference. Recieved: {projection_osr}&#34;

    geom = convert_bbox_to_geom(bbox_ogr)

    driver = ogr.GetDriverByName(&#34;FlatGeobuf&#34;)
    extent_name = f&#34;/vsimem/{get_unix_seconds_as_str()}_{uuid4().int}_extent.fgb&#34;
    extent_ds = driver.CreateDataSource(extent_name)

    layer = extent_ds.CreateLayer(&#34;extent_ogr&#34;, projection_osr, ogr.wkbPolygon)

    feature = ogr.Feature(layer.GetLayerDefn())
    feature.SetGeometry(geom)
    layer.CreateFeature(feature)

    feature = None
    layer.SyncToDisk()

    return extent_name


def bboxes_intersect(bbox1_ogr, bbox2_ogr):
    &#34;&#34;&#34;
    Checks if two OGR formatted bboxes intersect.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_bool_): **True** if the bboxes intersect, **False** otherwise.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox1_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox1_ogr}&#34;
    assert is_valid_bbox(
        bbox2_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox2_ogr}&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    if bbox2_x_min &gt; bbox1_x_max:
        return False

    if bbox2_y_min &gt; bbox1_y_max:
        return False

    if bbox2_x_max &gt; bbox1_x_min:
        return False

    if bbox2_y_max &gt; bbox1_y_min:
        return False

    return True


def bboxes_within(bbox1_ogr, bbox2_ogr):
    &#34;&#34;&#34;
    Checks if one OGR formatted bbox is within another.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_bool_): **True** if the bbox is within the other, **False** otherwise.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox1_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox1_ogr}&#34;
    assert is_valid_bbox(
        bbox2_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox2_ogr}&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    return (
        (bbox1_x_min &gt;= bbox2_x_min)
        and (bbox1_x_max &lt;= bbox2_x_max)
        and (bbox1_y_min &gt;= bbox2_y_min)
        and (bbox1_y_max &lt;= bbox2_y_max)
    )


def get_intersection_bboxes(bbox1_ogr, bbox2_ogr):
    &#34;&#34;&#34;
    Get the intersection of two OGR formatted bboxes.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox of the intersection. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert bboxes_intersect(
        bbox1_ogr, bbox2_ogr
    ), &#34;The two bounding boxes do not intersect.&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    return (
        max(bbox1_x_min, bbox2_x_min),
        min(bbox1_x_max, bbox2_x_max),
        max(bbox1_y_min, bbox2_y_min),
        min(bbox1_y_max, bbox2_y_max),
    )


def align_bboxes_to_pixel_size(bbox1_ogr, bbox2_ogr, pixel_width, pixel_height):
    &#34;&#34;&#34;
    Aligns two OGR formatted bboxes to a pixel size.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `pixel_width` (_float_ || _int_): The width of the pixel. &lt;/br&gt;
    `pixel_height` (_float_ || _int_): The height of the pixel. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox of the alignment. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert (
        isinstance(bbox1_ogr, list) and len(bbox1_ogr) == 4
    ), f&#34;bbox1_ogr must be a list of length four. Received: {bbox1_ogr}.&#34;
    assert (
        isinstance(bbox2_ogr, list) and len(bbox2_ogr) == 4
    ), f&#34;bbox2_ogr must be a list of length four. Received: {bbox2_ogr}.&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    x_min = bbox2_x_min - ((bbox2_x_min - bbox1_x_min) % pixel_width)
    x_max = bbox2_x_max + ((bbox1_x_max - bbox2_x_max) % pixel_width)

    y_min = bbox2_y_min - ((bbox2_y_min - bbox1_y_min) % abs(pixel_height))
    y_max = bbox2_y_max + ((bbox1_y_max - bbox2_y_max) % abs(pixel_height))

    return x_min, x_max, y_min, y_max


def reproject_bbox(
    bbox_ogr,
    source_projection_osr,
    target_projection_osr,
):
    &#34;&#34;&#34;
    Reprojects an OGR formatted bbox.

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `source_projection_osr` (_osr.SpatialReference_): The source projection. &lt;/br&gt;
    `target_projection_osr` (_osr.SpatialReference_): The target projection. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted reprojected bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert is_valid_bbox(bbox_ogr), f&#34;Invalid bbox. Received: {bbox_ogr}.&#34;
    assert isinstance(
        source_projection_osr, osr.SpatialReference
    ), f&#34;source_projection not a valid spatial reference. Recieved: {source_projection_osr}&#34;
    assert isinstance(
        target_projection_osr, osr.SpatialReference
    ), f&#34;target_projection not a valid spatial reference. Recieved: {target_projection_osr}&#34;

    if source_projection_osr.IsSame(target_projection_osr):
        return bbox_ogr

    transformer = osr.CoordinateTransformation(
        source_projection_osr, target_projection_osr
    )

    x_min, x_max, y_min, y_max = bbox_ogr

    transformed_x_min, transformed_y_min = transformer.TransformPoint(x_min, y_min)
    transformed_x_max, transformed_y_max = transformer.TransformPoint(x_max, y_max)

    return transformed_x_min, transformed_x_max, transformed_y_min, transformed_y_max


def additional_bboxes(bbox_ogr, projection_osr):
    &#34;&#34;&#34;
    This is an internal utility function for metadata generation. It takes a standard
    OGR bounding box and returns a list of variations of bounding boxes.

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `projection_osr` (_osr.SpatialReference_): The projection. &lt;/br&gt;

    ## Returns:
    (_dict_): A dictionary of the added bboxes. Contains the following keys: &lt;/br&gt;
    `bbox_latlng`: The bbox in latlng coordinates. &lt;/br&gt;
    `bbox_wkt`: The bbox in WKT format. &lt;/br&gt;
    `bbox_wkt_latlng`: The bbox in WKT format in latlng coordinates. &lt;/br&gt;
    `bbox_geom`: The bbox in ogr.Geometry format. &lt;/br&gt;
    `bbox_geom_latlng`: The bbox in ogr.Geometry format in latlng coordinates. &lt;/br&gt;
    `bbox_gdal`: The bbox in GDAL format. &lt;/br&gt;
    `bbox_gdal_latlng`: The bbox in GDAL format in latlng coordinates. &lt;/br&gt;
    `bbox_dict`: The bbox in a dictionary format. { &#34;x_min&#34;: x_min, ... } &lt;/br&gt;
    `bbox_dict_latlng`: The bbox in a dictionary format in latlng coordinates. &lt;/br&gt;
    &#34;&#34;&#34;
    assert is_valid_bbox(bbox_ogr), f&#34;Invalid bbox. Received: {bbox_ogr}.&#34;
    assert isinstance(
        projection_osr, osr.SpatialReference
    ), f&#34;source_projection not a valid spatial reference. Recieved: {projection_osr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    original_projection = osr.SpatialReference()
    original_projection.ImportFromWkt(projection_osr.ExportToWkt())

    latlng_projection = osr.SpatialReference()
    latlng_projection.ImportFromEPSG(4326)

    bbox_ogr_latlng = reproject_bbox(bbox_ogr, original_projection, latlng_projection)
    latlng_x_min, latlng_x_max, latlng_y_min, latlng_y_max = bbox_ogr_latlng

    bbox_geom = convert_bbox_to_geom(bbox_ogr)
    bbox_geom_latlng = convert_bbox_to_geom(bbox_ogr_latlng)

    bbox_wkt = convert_bbox_to_wkt(bbox_ogr)
    bbox_wkt_latlng = convert_bbox_to_wkt(bbox_ogr_latlng)

    return {
        &#34;bbox_latlng&#34;: bbox_ogr_latlng,
        &#34;bbox_wkt&#34;: bbox_wkt,
        &#34;bbox_wkt_latlng&#34;: bbox_wkt_latlng,
        &#34;bbox_geom&#34;: bbox_geom,
        &#34;bbox_geom_latlng&#34;: bbox_geom_latlng,
        &#34;bbox_gdal&#34;: convert_ogr_bbox_to_gdal_bbox(bbox_ogr),
        &#34;bbox_gdal_latlng&#34;: convert_ogr_bbox_to_gdal_bbox(bbox_ogr_latlng),
        &#34;bbox_dict&#34;: {&#34;x_min&#34;: x_min, &#34;x_max&#34;: x_max, &#34;y_min&#34;: y_min, &#34;y_max&#34;: y_max},
        &#34;bbox_dict_latlng&#34;: {
            &#34;x_min&#34;: latlng_x_min,
            &#34;x_max&#34;: latlng_x_max,
            &#34;y_min&#34;: latlng_y_min,
            &#34;y_max&#34;: latlng_y_max,
        },
        &#34;bbox_geojson&#34;: convert_bbox_to_geojson(bbox_ogr_latlng),
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="bbox.additional_bboxes"><code class="name flex">
<span>def <span class="ident">additional_bboxes</span></span>(<span>bbox_ogr, projection_osr)</span>
</code></dt>
<dd>
<div class="desc"><p>This is an internal utility function for metadata generation. It takes a standard
OGR bounding box and returns a list of variations of bounding boxes.</p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>projection_osr</code> (<em>osr.SpatialReference</em>): The projection. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>dict</em>): A dictionary of the added bboxes. Contains the following keys: </br>
<code>bbox_latlng</code>: The bbox in latlng coordinates. </br>
<code>bbox_wkt</code>: The bbox in WKT format. </br>
<code>bbox_wkt_latlng</code>: The bbox in WKT format in latlng coordinates. </br>
<code>bbox_geom</code>: The bbox in ogr.Geometry format. </br>
<code>bbox_geom_latlng</code>: The bbox in ogr.Geometry format in latlng coordinates. </br>
<code>bbox_gdal</code>: The bbox in GDAL format. </br>
<code>bbox_gdal_latlng</code>: The bbox in GDAL format in latlng coordinates. </br>
<code>bbox_dict</code>: The bbox in a dictionary format. { "x_min": x_min, &hellip; } </br>
<code>bbox_dict_latlng</code>: The bbox in a dictionary format in latlng coordinates. </br></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def additional_bboxes(bbox_ogr, projection_osr):
    &#34;&#34;&#34;
    This is an internal utility function for metadata generation. It takes a standard
    OGR bounding box and returns a list of variations of bounding boxes.

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `projection_osr` (_osr.SpatialReference_): The projection. &lt;/br&gt;

    ## Returns:
    (_dict_): A dictionary of the added bboxes. Contains the following keys: &lt;/br&gt;
    `bbox_latlng`: The bbox in latlng coordinates. &lt;/br&gt;
    `bbox_wkt`: The bbox in WKT format. &lt;/br&gt;
    `bbox_wkt_latlng`: The bbox in WKT format in latlng coordinates. &lt;/br&gt;
    `bbox_geom`: The bbox in ogr.Geometry format. &lt;/br&gt;
    `bbox_geom_latlng`: The bbox in ogr.Geometry format in latlng coordinates. &lt;/br&gt;
    `bbox_gdal`: The bbox in GDAL format. &lt;/br&gt;
    `bbox_gdal_latlng`: The bbox in GDAL format in latlng coordinates. &lt;/br&gt;
    `bbox_dict`: The bbox in a dictionary format. { &#34;x_min&#34;: x_min, ... } &lt;/br&gt;
    `bbox_dict_latlng`: The bbox in a dictionary format in latlng coordinates. &lt;/br&gt;
    &#34;&#34;&#34;
    assert is_valid_bbox(bbox_ogr), f&#34;Invalid bbox. Received: {bbox_ogr}.&#34;
    assert isinstance(
        projection_osr, osr.SpatialReference
    ), f&#34;source_projection not a valid spatial reference. Recieved: {projection_osr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    original_projection = osr.SpatialReference()
    original_projection.ImportFromWkt(projection_osr.ExportToWkt())

    latlng_projection = osr.SpatialReference()
    latlng_projection.ImportFromEPSG(4326)

    bbox_ogr_latlng = reproject_bbox(bbox_ogr, original_projection, latlng_projection)
    latlng_x_min, latlng_x_max, latlng_y_min, latlng_y_max = bbox_ogr_latlng

    bbox_geom = convert_bbox_to_geom(bbox_ogr)
    bbox_geom_latlng = convert_bbox_to_geom(bbox_ogr_latlng)

    bbox_wkt = convert_bbox_to_wkt(bbox_ogr)
    bbox_wkt_latlng = convert_bbox_to_wkt(bbox_ogr_latlng)

    return {
        &#34;bbox_latlng&#34;: bbox_ogr_latlng,
        &#34;bbox_wkt&#34;: bbox_wkt,
        &#34;bbox_wkt_latlng&#34;: bbox_wkt_latlng,
        &#34;bbox_geom&#34;: bbox_geom,
        &#34;bbox_geom_latlng&#34;: bbox_geom_latlng,
        &#34;bbox_gdal&#34;: convert_ogr_bbox_to_gdal_bbox(bbox_ogr),
        &#34;bbox_gdal_latlng&#34;: convert_ogr_bbox_to_gdal_bbox(bbox_ogr_latlng),
        &#34;bbox_dict&#34;: {&#34;x_min&#34;: x_min, &#34;x_max&#34;: x_max, &#34;y_min&#34;: y_min, &#34;y_max&#34;: y_max},
        &#34;bbox_dict_latlng&#34;: {
            &#34;x_min&#34;: latlng_x_min,
            &#34;x_max&#34;: latlng_x_max,
            &#34;y_min&#34;: latlng_y_min,
            &#34;y_max&#34;: latlng_y_max,
        },
        &#34;bbox_geojson&#34;: convert_bbox_to_geojson(bbox_ogr_latlng),
    }</code></pre>
</details>
</dd>
<dt id="bbox.align_bboxes_to_pixel_size"><code class="name flex">
<span>def <span class="ident">align_bboxes_to_pixel_size</span></span>(<span>bbox1_ogr, bbox2_ogr, pixel_width, pixel_height)</span>
</code></dt>
<dd>
<div class="desc"><p>Aligns two OGR formatted bboxes to a pixel size.</p>
<h2 id="args">Args:</h2>
<p><code>bbox1_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>bbox2_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>pixel_width</code> (<em>float</em> || <em>int</em>): The width of the pixel. </br>
<code>pixel_height</code> (<em>float</em> || <em>int</em>): The height of the pixel. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox of the alignment. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def align_bboxes_to_pixel_size(bbox1_ogr, bbox2_ogr, pixel_width, pixel_height):
    &#34;&#34;&#34;
    Aligns two OGR formatted bboxes to a pixel size.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `pixel_width` (_float_ || _int_): The width of the pixel. &lt;/br&gt;
    `pixel_height` (_float_ || _int_): The height of the pixel. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox of the alignment. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert (
        isinstance(bbox1_ogr, list) and len(bbox1_ogr) == 4
    ), f&#34;bbox1_ogr must be a list of length four. Received: {bbox1_ogr}.&#34;
    assert (
        isinstance(bbox2_ogr, list) and len(bbox2_ogr) == 4
    ), f&#34;bbox2_ogr must be a list of length four. Received: {bbox2_ogr}.&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    x_min = bbox2_x_min - ((bbox2_x_min - bbox1_x_min) % pixel_width)
    x_max = bbox2_x_max + ((bbox1_x_max - bbox2_x_max) % pixel_width)

    y_min = bbox2_y_min - ((bbox2_y_min - bbox1_y_min) % abs(pixel_height))
    y_max = bbox2_y_max + ((bbox1_y_max - bbox2_y_max) % abs(pixel_height))

    return x_min, x_max, y_min, y_max</code></pre>
</details>
</dd>
<dt id="bbox.bboxes_intersect"><code class="name flex">
<span>def <span class="ident">bboxes_intersect</span></span>(<span>bbox1_ogr, bbox2_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if two OGR formatted bboxes intersect.</p>
<h2 id="args">Args:</h2>
<p><code>bbox1_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>bbox2_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>bool</em>): <strong>True</strong> if the bboxes intersect, <strong>False</strong> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bboxes_intersect(bbox1_ogr, bbox2_ogr):
    &#34;&#34;&#34;
    Checks if two OGR formatted bboxes intersect.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_bool_): **True** if the bboxes intersect, **False** otherwise.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox1_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox1_ogr}&#34;
    assert is_valid_bbox(
        bbox2_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox2_ogr}&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    if bbox2_x_min &gt; bbox1_x_max:
        return False

    if bbox2_y_min &gt; bbox1_y_max:
        return False

    if bbox2_x_max &gt; bbox1_x_min:
        return False

    if bbox2_y_max &gt; bbox1_y_min:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="bbox.bboxes_within"><code class="name flex">
<span>def <span class="ident">bboxes_within</span></span>(<span>bbox1_ogr, bbox2_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if one OGR formatted bbox is within another.</p>
<h2 id="args">Args:</h2>
<p><code>bbox1_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>bbox2_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>bool</em>): <strong>True</strong> if the bbox is within the other, <strong>False</strong> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bboxes_within(bbox1_ogr, bbox2_ogr):
    &#34;&#34;&#34;
    Checks if one OGR formatted bbox is within another.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_bool_): **True** if the bbox is within the other, **False** otherwise.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox1_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox1_ogr}&#34;
    assert is_valid_bbox(
        bbox2_ogr
    ), f&#34;bbox1_ogr was not a valid bbox. Received: {bbox2_ogr}&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    return (
        (bbox1_x_min &gt;= bbox2_x_min)
        and (bbox1_x_max &lt;= bbox2_x_max)
        and (bbox1_y_min &gt;= bbox2_y_min)
        and (bbox1_y_max &lt;= bbox2_y_max)
    )</code></pre>
</details>
</dd>
<dt id="bbox.convert_bbox_to_geojson"><code class="name flex">
<span>def <span class="ident">convert_bbox_to_geojson</span></span>(<span>bbox_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts an OGR formatted bbox to a GeoJson dictionary.</br>
<code>[x_min, x_max, y_min, y_max] -&gt; GeoJson</code></p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): an OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>dict</em>): A GeoJson Dictionary. <code>{ "type": "Polygon", "coordinates": [ ... ] }</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bbox_to_geojson(bbox_ogr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to a GeoJson dictionary.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; GeoJson`

    ## Args:
    `bbox_ogr` (_list_): an OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_dict_): A GeoJson Dictionary. `{ &#34;type&#34;: &#34;Polygon&#34;, &#34;coordinates&#34;: [ ... ] }`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    geojson = {
        &#34;type&#34;: &#34;Polygon&#34;,
        &#34;coordinates&#34;: [
            [
                [x_min, y_min],
                [x_max, y_min],
                [x_max, y_max],
                [x_min, y_max],
                [x_min, y_min],
            ]
        ],
    }

    return geojson</code></pre>
</details>
</dd>
<dt id="bbox.convert_bbox_to_geom"><code class="name flex">
<span>def <span class="ident">convert_bbox_to_geom</span></span>(<span>bbox_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an OGR bounding box to ogr.Geometry.</br>
<code>[x_min, x_max, y_min, y_max] -&gt; ogr.Geometry</code></p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>ogr.Geometry</em>): An OGR geometry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bbox_to_geom(bbox_ogr):
    &#34;&#34;&#34;
    Convert an OGR bounding box to ogr.Geometry.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; ogr.Geometry`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_ogr.Geometry_): An OGR geometry.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    ring = ogr.Geometry(ogr.wkbLinearRing)
    ring.AddPoint(x_min, y_min)
    ring.AddPoint(x_max, y_min)
    ring.AddPoint(x_max, y_max)
    ring.AddPoint(x_min, y_max)
    ring.AddPoint(x_min, y_min)

    geom = ogr.Geometry(ogr.wkbPolygon)
    geom.AddGeometry(ring)

    return geom</code></pre>
</details>
</dd>
<dt id="bbox.convert_bbox_to_geotransform"><code class="name flex">
<span>def <span class="ident">convert_bbox_to_geotransform</span></span>(<span>bbox_ogr, raster_x_size, raster_y_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an OGR formatted bounding box to a GDAL GeoTransform.</br>
<code>[x_min, x_max, y_min, y_max] -&gt; [x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]</code></p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>raster_x_size</code> (<em>int</em>): The number of pixels in the x direction. </br>
<code>raster_y_size</code> (<em>int</em>): The number of pixels in the y direction. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): A GDAL GeoTransform. <code>[x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bbox_to_geotransform(bbox_ogr, raster_x_size, raster_y_size):
    &#34;&#34;&#34;
    Convert an OGR formatted bounding box to a GDAL GeoTransform.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; [x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `raster_x_size` (_int_): The number of pixels in the x direction. &lt;/br&gt;
    `raster_y_size` (_int_): The number of pixels in the y direction. &lt;/br&gt;

    ## Returns:
    (_list_): A GDAL GeoTransform. `[x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    origin_x = x_min
    origin_y = y_max
    pixel_width = (x_max - x_min) / raster_x_size
    pixel_height = (y_max - y_min) / raster_y_size

    return [origin_x, pixel_width, 0, origin_y, 0, ensure_negative(pixel_height)]</code></pre>
</details>
</dd>
<dt id="bbox.convert_bbox_to_vector"><code class="name flex">
<span>def <span class="ident">convert_bbox_to_vector</span></span>(<span>bbox_ogr, projection_osr)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts an OGR formatted bbox to an in-memory vector.</br>
<em>Vectors are stored in /vsimem/ as .fgb files.</em></br>
<strong>OBS</strong>: Layers should be manually cleared when no longer used.</p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): an OGR formatted bbox. </br>
<code>projection_osr</code> (<em>osr.SpatialReference</em>): The projection of the vector. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>ogr.DataSource</em>): The bounding box as a vector.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bbox_to_vector(bbox_ogr, projection_osr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to an in-memory vector.&lt;/br&gt;
    _Vectors are stored in /vsimem/ as .fgb files._&lt;/br&gt;
    **OBS**: Layers should be manually cleared when no longer used.

    ## Args:
    `bbox_ogr` (_list_): an OGR formatted bbox. &lt;/br&gt;
    `projection_osr` (_osr.SpatialReference_): The projection of the vector. &lt;/br&gt;

    ## Returns:
    (_ogr.DataSource_): The bounding box as a vector.
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;
    assert isinstance(
        projection_osr, osr.SpatialReference
    ), f&#34;projection_osr not a valid spatial reference. Recieved: {projection_osr}&#34;

    geom = convert_bbox_to_geom(bbox_ogr)

    driver = ogr.GetDriverByName(&#34;FlatGeobuf&#34;)
    extent_name = f&#34;/vsimem/{get_unix_seconds_as_str()}_{uuid4().int}_extent.fgb&#34;
    extent_ds = driver.CreateDataSource(extent_name)

    layer = extent_ds.CreateLayer(&#34;extent_ogr&#34;, projection_osr, ogr.wkbPolygon)

    feature = ogr.Feature(layer.GetLayerDefn())
    feature.SetGeometry(geom)
    layer.CreateFeature(feature)

    feature = None
    layer.SyncToDisk()

    return extent_name</code></pre>
</details>
</dd>
<dt id="bbox.convert_bbox_to_wkt"><code class="name flex">
<span>def <span class="ident">convert_bbox_to_wkt</span></span>(<span>bbox_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts an OGR formatted bbox to a WKT string.</br>
<code>[x_min, x_max, y_min, y_max] -&gt; WKT</code></p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>str</em>): A WKT Polygon string. <code>POLYGON ((&hellip;))</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_bbox_to_wkt(bbox_ogr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to a WKT string.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; WKT`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_str_): A WKT Polygon string. `POLYGON ((...))`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    wkt = f&#34;POLYGON (({x_min} {y_min}, {x_max} {y_min}, {x_max} {y_max}, {x_min} {y_max}, {x_min} {y_min}))&#34;

    return wkt</code></pre>
</details>
</dd>
<dt id="bbox.convert_gdal_bbox_to_ogr_bbox"><code class="name flex">
<span>def <span class="ident">convert_gdal_bbox_to_ogr_bbox</span></span>(<span>bbox_gdal)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a GDAL formatted bbox to an OGR formatted one.</br>
<code>[x_min, y_min, x_max, y_max] -&gt; [x_min, x_max, y_min, y_max]</code></p>
<h2 id="args">Args:</h2>
<p><code>bbox_gdal</code> (<em>list</em>): A GDAL formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_gdal_bbox_to_ogr_bbox(bbox_gdal):
    &#34;&#34;&#34;
    Converts a GDAL formatted bbox to an OGR formatted one.&lt;/br&gt;
    `[x_min, y_min, x_max, y_max] -&gt; [x_min, x_max, y_min, y_max]`

    ## Args:
    `bbox_gdal` (_list_): A GDAL formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert (
        isinstance(bbox_gdal, list) and len(bbox_gdal) == 4
    ), f&#34;bbox_gdal must be a list of length four. Received: {bbox_gdal}.&#34;

    x_min, y_min, x_max, y_max = bbox_gdal

    return [x_min, x_max, y_min, y_max]</code></pre>
</details>
</dd>
<dt id="bbox.convert_geom_to_bbox"><code class="name flex">
<span>def <span class="ident">convert_geom_to_bbox</span></span>(<span>geom)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an ogr.Geometry to an OGR bounding box.</br>
<code>ogr.Geometry -&gt; [x_min, x_max, y_min, y_max]</code></p>
<h2 id="args">Args:</h2>
<p><code>geom</code> (<em>ogr.Geometry</em>): An OGR geometry. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_geom_to_bbox(geom):
    &#34;&#34;&#34;
    Convert an ogr.Geometry to an OGR bounding box.&lt;/br&gt;
    `ogr.Geometry -&gt; [x_min, x_max, y_min, y_max]`

    ## Args:
    `geom` (_ogr.Geometry_): An OGR geometry. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        geom, ogr.Geometry
    ), f&#34;geom was not a valid ogr.Geometry. Received: {geom}&#34;

    bbox_ogr = geom.GetEnvelope()

    return bbox_ogr  # [x_min, x_max, y_min, y_max]</code></pre>
</details>
</dd>
<dt id="bbox.convert_ogr_bbox_to_gdal_bbox"><code class="name flex">
<span>def <span class="ident">convert_ogr_bbox_to_gdal_bbox</span></span>(<span>bbox_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts an OGR formatted bbox to a GDAL formatted one.</br>
<code>[x_min, x_max, y_min, y_max] -&gt; [x_min, y_min, x_max, y_max]</code></p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): A GDAL formatted bbox. <code>[x_min, y_min, x_max, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_ogr_bbox_to_gdal_bbox(bbox_ogr):
    &#34;&#34;&#34;
    Converts an OGR formatted bbox to a GDAL formatted one.&lt;/br&gt;
    `[x_min, x_max, y_min, y_max] -&gt; [x_min, y_min, x_max, y_max]`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): A GDAL formatted bbox. `[x_min, y_min, x_max, y_max]`
    &#34;&#34;&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    return [x_min, y_min, x_max, y_max]</code></pre>
</details>
</dd>
<dt id="bbox.ensure_negative"><code class="name flex">
<span>def <span class="ident">ensure_negative</span></span>(<span>number)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensures that a valid is negative. If the number is positive, it is made negative.</p>
<h2 id="args">Args:</h2>
<p><code>number</code> (<em>int</em> || <em>float</em>): A float or int number. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>int</em> || <em>float</em>): The same number made <strong>negative</strong> if necesary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ensure_negative(number):
    &#34;&#34;&#34;
    Ensures that a valid is negative. If the number is positive, it is made negative.

    ## Args:
    `number` (_int_ || _float_): A float or int number. &lt;/br&gt;

    ## Returns:
    (_int_ || _float_): The same number made **negative** if necesary.
    &#34;&#34;&#34;
    assert is_number(number), f&#34;number must be a number. Received: {number}&#34;

    if number &lt;= 0:
        return -number

    return number</code></pre>
</details>
</dd>
<dt id="bbox.get_bbox_from_geotransform"><code class="name flex">
<span>def <span class="ident">get_bbox_from_geotransform</span></span>(<span>geotransform, raster_x_size, raster_y_size)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an OGR bounding box from a geotransform and raster sizes.</p>
<h2 id="args">Args:</h2>
<p><code>geotransform</code> (<em>list</em> || <em>tuple</em>): A GDAL GeoTransform. </br>
<code>raster_x_size</code> (<em>int</em>): The number of pixels in the x direction. </br>
<code>raster_y_size</code> (<em>int</em>): The number of pixels in the y direction. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bbox_from_geotransform(geotransform, raster_x_size, raster_y_size):
    &#34;&#34;&#34;
    Get an OGR bounding box from a geotransform and raster sizes.

    ## Args:
    `geotransform` (_list_ || _tuple_): A GDAL GeoTransform. &lt;/br&gt;
    `raster_x_size` (_int_): The number of pixels in the x direction. &lt;/br&gt;
    `raster_y_size` (_int_): The number of pixels in the y direction. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert is_valid_geotransform(
        geotransform
    ), f&#34;geotransform was not a valid geotransform. Received: {geotransform}&#34;

    x_min, pixel_width, _row_skew, y_max, _column_skew, pixel_height = geotransform

    x_max = x_min + (raster_x_size * pixel_width)
    y_min = y_max + (raster_y_size * pixel_height)

    return [x_min, x_max, y_min, y_max]</code></pre>
</details>
</dd>
<dt id="bbox.get_bbox_from_raster"><code class="name flex">
<span>def <span class="ident">get_bbox_from_raster</span></span>(<span>raster_dataframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an OGR bounding box from a GDAL raster dataframe.</p>
<h2 id="args">Args:</h2>
<p><code>raster_dataframe</code> (<em>gdal.DataFrame</em>): A GDAL raster dataframe. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bbox_from_raster(raster_dataframe):
    &#34;&#34;&#34;
    Gets an OGR bounding box from a GDAL raster dataframe.

    ## Args:
    `raster_dataframe` (_gdal.DataFrame_): A GDAL raster dataframe. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        raster_dataframe, gdal.Dataset
    ), f&#34;raster_dataframe was not a gdal.Datasource. Received: {raster_dataframe}&#34;

    bbox = get_bbox_from_geotransform(
        raster_dataframe.GetGeoTransform(),
        raster_dataframe.RasterXSize,
        raster_dataframe.RasterYSize,
    )

    return bbox</code></pre>
</details>
</dd>
<dt id="bbox.get_bbox_from_vector"><code class="name flex">
<span>def <span class="ident">get_bbox_from_vector</span></span>(<span>vector_dataframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an OGR bounding box from an OGR dataframe.</p>
<h2 id="args">Args:</h2>
<p><code>vector_dataframe</code> (<em>ogr.DataSource</em>): An OGR vector dataframe. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bbox_from_vector(vector_dataframe):
    &#34;&#34;&#34;
    Gets an OGR bounding box from an OGR dataframe.

    ## Args:
    `vector_dataframe` (_ogr.DataSource_): An OGR vector dataframe. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        vector_dataframe, ogr.DataSource
    ), f&#34;vector_dataframe was not a valid ogr.DataSource. Received: {vector_dataframe}&#34;

    layer_count = vector_dataframe.GetLayerCount()

    assert (
        layer_count &gt; 0
    ), f&#34;vector_dataframe did not contain any layers. Received: {vector_dataframe}&#34;

    x_min = None
    x_max = None
    y_min = None
    y_max = None

    for layer_index in range(layer_count):
        layer = vector_dataframe.GetLayerByIndex(layer_index)
        layer_x_min, layer_x_max, layer_y_min, layer_y_max = layer.GetExtent()

        if layer_index == 0:
            x_min = layer_x_min
            x_max = layer_x_max
            y_min = layer_y_min
            y_max = layer_y_max
        else:
            if layer_x_min &lt; x_min:
                x_min = layer_x_min
            if layer_x_max &gt; x_max:
                x_max = layer_x_max
            if layer_y_min &lt; y_min:
                y_min = layer_y_min
            if layer_y_max &gt; y_max:
                y_max = layer_y_max

    return [x_min, x_max, y_min, y_max]</code></pre>
</details>
</dd>
<dt id="bbox.get_bbox_from_vector_layer"><code class="name flex">
<span>def <span class="ident">get_bbox_from_vector_layer</span></span>(<span>vector_layer)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets an OGR bounding box from an OGR dataframe layer.</p>
<h2 id="args">Args:</h2>
<p><code>vector_layer</code> (<em>ogr.Layer</em>): An OGR vector dataframe layer. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bbox_from_vector_layer(vector_layer):
    &#34;&#34;&#34;
    Gets an OGR bounding box from an OGR dataframe layer.

    ## Args:
    `vector_layer` (_ogr.Layer_): An OGR vector dataframe layer. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert isinstance(
        vector_layer, ogr.Layer
    ), f&#34;vector_layer was not a valid ogr.Layer. Received: {vector_layer}&#34;

    x_min, x_max, y_min, y_max = vector_layer.GetExtent()

    return [x_min, x_max, y_min, y_max]</code></pre>
</details>
</dd>
<dt id="bbox.get_intersection_bboxes"><code class="name flex">
<span>def <span class="ident">get_intersection_bboxes</span></span>(<span>bbox1_ogr, bbox2_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the intersection of two OGR formatted bboxes.</p>
<h2 id="args">Args:</h2>
<p><code>bbox1_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>bbox2_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted bbox of the intersection. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_intersection_bboxes(bbox1_ogr, bbox2_ogr):
    &#34;&#34;&#34;
    Get the intersection of two OGR formatted bboxes.

    ## Args:
    `bbox1_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `bbox2_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted bbox of the intersection. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert bboxes_intersect(
        bbox1_ogr, bbox2_ogr
    ), &#34;The two bounding boxes do not intersect.&#34;

    bbox1_x_min, bbox1_x_max, bbox1_y_min, bbox1_y_max = bbox1_ogr
    bbox2_x_min, bbox2_x_max, bbox2_y_min, bbox2_y_max = bbox2_ogr

    return (
        max(bbox1_x_min, bbox2_x_min),
        min(bbox1_x_max, bbox2_x_max),
        max(bbox1_y_min, bbox2_y_min),
        min(bbox1_y_max, bbox2_y_max),
    )</code></pre>
</details>
</dd>
<dt id="bbox.get_pixel_offsets"><code class="name flex">
<span>def <span class="ident">get_pixel_offsets</span></span>(<span>geotransform, bbox_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the pixels offsets for a bbox and a geotransform.</p>
<h2 id="args">Args:</h2>
<p><code>geotransform</code> (<em>list</em> || <em>tuple</em>): A GDAL GeoTransform. </br>
<code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): A list of pixel offsets. <code>[x_start, y_start, x_size, y_size]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pixel_offsets(geotransform, bbox_ogr):
    &#34;&#34;&#34;
    Get the pixels offsets for a bbox and a geotransform.

    ## Args:
    `geotransform` (_list_ || _tuple_): A GDAL GeoTransform. &lt;/br&gt;
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_list_): A list of pixel offsets. `[x_start, y_start, x_size, y_size]`
    &#34;&#34;&#34;
    assert is_valid_geotransform(
        geotransform
    ), f&#34;geotransform must be a list of length six. Received: {geotransform}.&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr must be a valid OGR formatted bbox. Received: {bbox_ogr}.&#34;

    x_min, x_max, y_min, y_max = bbox_ogr

    origin_x = geotransform[0]
    origin_y = geotransform[3]
    pixel_width = abs(geotransform[1])
    pixel_height = abs(geotransform[5])

    x_1 = int((x_min - origin_x) / pixel_width)
    x_2 = int((x_max - origin_x) / pixel_width) + 1

    y_1 = int((y_max - origin_y) / pixel_height)
    y_2 = int((y_min - origin_y) / pixel_height) + 1

    x_size = x_2 - x_1
    y_size = y_2 - y_1

    x_start = x_1
    y_start = y_1

    return [x_start, y_start, x_size, y_size]</code></pre>
</details>
</dd>
<dt id="bbox.get_sub_geotransform"><code class="name flex">
<span>def <span class="ident">get_sub_geotransform</span></span>(<span>geotransform, bbox_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a GeoTransform and the raster sizes for an OGR formatted bbox.</p>
<h2 id="args">Args:</h2>
<p><code>geotransform</code> (<em>list</em>): A GDAL geotransform. </br>
<code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>dict</em>): { "Transform": <em>list</em>, "RasterXSize": <em>int</em>, "RasterYSize": <em>int</em> }</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sub_geotransform(geotransform, bbox_ogr):
    &#34;&#34;&#34;
    Create a GeoTransform and the raster sizes for an OGR formatted bbox.

    ## Args:
    `geotransform` (_list_): A GDAL geotransform. &lt;/br&gt;
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    (_dict_): { &#34;Transform&#34;: _list_, &#34;RasterXSize&#34;: _int_, &#34;RasterYSize&#34;: _int_ }
    &#34;&#34;&#34;
    assert is_valid_geotransform(
        geotransform
    ), f&#34;geotransform must be a valid geotransform. Received: {geotransform}.&#34;
    assert is_valid_bbox(
        bbox_ogr
    ), f&#34;bbox_ogr was not a valid bbox. Received: {bbox_ogr}&#34;

    x_min, x_max, y_min, y_max = bbox_ogr
    pixel_width = geotransform[1]
    pixel_height = geotransform[5]

    raster_x_size = round((x_max - x_min) / pixel_width)
    raster_y_size = round((y_max - y_min) / pixel_height)

    return {
        &#34;Transform&#34;: [x_min, pixel_width, 0, y_max, 0, ensure_negative(pixel_height)],
        &#34;RasterXSize&#34;: abs(raster_x_size),
        &#34;RasterYSize&#34;: abs(raster_y_size),
    }</code></pre>
</details>
</dd>
<dt id="bbox.is_valid_bbox"><code class="name flex">
<span>def <span class="ident">is_valid_bbox</span></span>(<span>bbox_ogr)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a bbox is valid.</p>
<p>A valid ogr formatted bbox has the form:
<code>[x_min, x_max, y_min, y_max]</code></p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br></p>
<h2 id="returns">Returns:</h2>
<p><strong>True</strong> if the bbox is valid, <strong>False</strong> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_bbox(bbox_ogr):
    &#34;&#34;&#34;
    Checks if a bbox is valid.

    A valid ogr formatted bbox has the form:
    `[x_min, x_max, y_min, y_max]`

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;

    ## Returns:
    **True** if the bbox is valid, **False** otherwise.
    &#34;&#34;&#34;
    if not isinstance(bbox_ogr, list):
        return False

    if len(bbox_ogr) != 4:
        return False

    for val in bbox_ogr:
        if not is_number(val):
            return False

    x_min, x_max, y_min, y_max = bbox_ogr

    if x_min &gt; x_max or y_min &gt; y_max:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="bbox.is_valid_geotransform"><code class="name flex">
<span>def <span class="ident">is_valid_geotransform</span></span>(<span>geotransform)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a geotransform is valid.</p>
<p>A valid geotransform has the form:</p>
<pre><code class="language-python">[x_min, pixel_width, row_skew, y_max, column_skew, pixel_height]
</code></pre>
<h2 id="args">Args:</h2>
<p><code>geotransform</code> (<em>list</em> || <em>tuple</em>): A GDAL formatted geotransform.</p>
<h2 id="returns">Returns:</h2>
<p><strong>True</strong> if the geotransform is valid, <strong>False</strong> otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_valid_geotransform(geotransform):
    &#34;&#34;&#34;
    Checks if a geotransform is valid.
    
    A valid geotransform has the form:
    ```python
    [x_min, pixel_width, row_skew, y_max, column_skew, pixel_height]
    ```

    ## Args:
    `geotransform` (_list_ || _tuple_): A GDAL formatted geotransform.

    ## Returns:
    **True** if the geotransform is valid, **False** otherwise.
    &#34;&#34;&#34;
    if not isinstance(geotransform, (list, tuple)):
        return False

    if len(geotransform) != 6:
        return False

    for val in geotransform:
        if not is_number(val):
            return False

    return True</code></pre>
</details>
</dd>
<dt id="bbox.reproject_bbox"><code class="name flex">
<span>def <span class="ident">reproject_bbox</span></span>(<span>bbox_ogr, source_projection_osr, target_projection_osr)</span>
</code></dt>
<dd>
<div class="desc"><p>Reprojects an OGR formatted bbox.</p>
<h2 id="args">Args:</h2>
<p><code>bbox_ogr</code> (<em>list</em>): An OGR formatted bbox. </br>
<code>source_projection_osr</code> (<em>osr.SpatialReference</em>): The source projection. </br>
<code>target_projection_osr</code> (<em>osr.SpatialReference</em>): The target projection. </br></p>
<h2 id="returns">Returns:</h2>
<p>(<em>list</em>): An OGR formatted reprojected bbox. <code>[x_min, x_max, y_min, y_max]</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reproject_bbox(
    bbox_ogr,
    source_projection_osr,
    target_projection_osr,
):
    &#34;&#34;&#34;
    Reprojects an OGR formatted bbox.

    ## Args:
    `bbox_ogr` (_list_): An OGR formatted bbox. &lt;/br&gt;
    `source_projection_osr` (_osr.SpatialReference_): The source projection. &lt;/br&gt;
    `target_projection_osr` (_osr.SpatialReference_): The target projection. &lt;/br&gt;

    ## Returns:
    (_list_): An OGR formatted reprojected bbox. `[x_min, x_max, y_min, y_max]`
    &#34;&#34;&#34;
    assert is_valid_bbox(bbox_ogr), f&#34;Invalid bbox. Received: {bbox_ogr}.&#34;
    assert isinstance(
        source_projection_osr, osr.SpatialReference
    ), f&#34;source_projection not a valid spatial reference. Recieved: {source_projection_osr}&#34;
    assert isinstance(
        target_projection_osr, osr.SpatialReference
    ), f&#34;target_projection not a valid spatial reference. Recieved: {target_projection_osr}&#34;

    if source_projection_osr.IsSame(target_projection_osr):
        return bbox_ogr

    transformer = osr.CoordinateTransformation(
        source_projection_osr, target_projection_osr
    )

    x_min, x_max, y_min, y_max = bbox_ogr

    transformed_x_min, transformed_y_min = transformer.TransformPoint(x_min, y_min)
    transformed_x_max, transformed_y_max = transformer.TransformPoint(x_max, y_max)

    return transformed_x_min, transformed_x_max, transformed_y_min, transformed_y_max</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#bounding-box-utility-functions">Bounding box utility functions</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="bbox.additional_bboxes" href="#bbox.additional_bboxes">additional_bboxes</a></code></li>
<li><code><a title="bbox.align_bboxes_to_pixel_size" href="#bbox.align_bboxes_to_pixel_size">align_bboxes_to_pixel_size</a></code></li>
<li><code><a title="bbox.bboxes_intersect" href="#bbox.bboxes_intersect">bboxes_intersect</a></code></li>
<li><code><a title="bbox.bboxes_within" href="#bbox.bboxes_within">bboxes_within</a></code></li>
<li><code><a title="bbox.convert_bbox_to_geojson" href="#bbox.convert_bbox_to_geojson">convert_bbox_to_geojson</a></code></li>
<li><code><a title="bbox.convert_bbox_to_geom" href="#bbox.convert_bbox_to_geom">convert_bbox_to_geom</a></code></li>
<li><code><a title="bbox.convert_bbox_to_geotransform" href="#bbox.convert_bbox_to_geotransform">convert_bbox_to_geotransform</a></code></li>
<li><code><a title="bbox.convert_bbox_to_vector" href="#bbox.convert_bbox_to_vector">convert_bbox_to_vector</a></code></li>
<li><code><a title="bbox.convert_bbox_to_wkt" href="#bbox.convert_bbox_to_wkt">convert_bbox_to_wkt</a></code></li>
<li><code><a title="bbox.convert_gdal_bbox_to_ogr_bbox" href="#bbox.convert_gdal_bbox_to_ogr_bbox">convert_gdal_bbox_to_ogr_bbox</a></code></li>
<li><code><a title="bbox.convert_geom_to_bbox" href="#bbox.convert_geom_to_bbox">convert_geom_to_bbox</a></code></li>
<li><code><a title="bbox.convert_ogr_bbox_to_gdal_bbox" href="#bbox.convert_ogr_bbox_to_gdal_bbox">convert_ogr_bbox_to_gdal_bbox</a></code></li>
<li><code><a title="bbox.ensure_negative" href="#bbox.ensure_negative">ensure_negative</a></code></li>
<li><code><a title="bbox.get_bbox_from_geotransform" href="#bbox.get_bbox_from_geotransform">get_bbox_from_geotransform</a></code></li>
<li><code><a title="bbox.get_bbox_from_raster" href="#bbox.get_bbox_from_raster">get_bbox_from_raster</a></code></li>
<li><code><a title="bbox.get_bbox_from_vector" href="#bbox.get_bbox_from_vector">get_bbox_from_vector</a></code></li>
<li><code><a title="bbox.get_bbox_from_vector_layer" href="#bbox.get_bbox_from_vector_layer">get_bbox_from_vector_layer</a></code></li>
<li><code><a title="bbox.get_intersection_bboxes" href="#bbox.get_intersection_bboxes">get_intersection_bboxes</a></code></li>
<li><code><a title="bbox.get_pixel_offsets" href="#bbox.get_pixel_offsets">get_pixel_offsets</a></code></li>
<li><code><a title="bbox.get_sub_geotransform" href="#bbox.get_sub_geotransform">get_sub_geotransform</a></code></li>
<li><code><a title="bbox.is_valid_bbox" href="#bbox.is_valid_bbox">is_valid_bbox</a></code></li>
<li><code><a title="bbox.is_valid_geotransform" href="#bbox.is_valid_geotransform">is_valid_geotransform</a></code></li>
<li><code><a title="bbox.reproject_bbox" href="#bbox.reproject_bbox">reproject_bbox</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>