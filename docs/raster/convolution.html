<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>buteo.raster.convolution API documentation</title>
<meta name="description" content="Perform convolutions on arrays.
###" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buteo.raster.convolution</code></h1>
</header>
<section id="section-intro">
<h3 id="perform-convolutions-on-arrays">Perform convolutions on arrays.</h3>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
### Perform convolutions on arrays.  ###
&#34;&#34;&#34;

# External
import numpy as np
from numba import jit, prange


def weight_distance(arr, method, decay, sigma, center, spherical, radius):
    &#34;&#34;&#34; Weight the kernel by distance. &#34;&#34;&#34;

    if center == 0.0:
        normed = np.linalg.norm(arr)
    else:
        normed = np.linalg.norm(arr - np.array([0, 0, center]))

    if normed == 0.0:
        weight = 1.0

    if method is None or method == &#34;none&#34; or method == &#34;&#34;:
        weight = 1.0
    elif method == &#34;linear&#34;:
        weight = np.power((1 - decay), normed)
    elif method == &#34;sqrt&#34;:
        weight = np.power(np.sqrt((1 - decay)), normed)
    elif method == &#34;power&#34;:
        weight = np.power(np.power((1 - decay), 2), normed)
    elif method == &#34;log&#34;:
        weight = np.log(normed + 2)
    elif method == &#34;gaussian&#34;:
        weight = np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2)))
    else:
        raise ValueError(&#34;Unable to parse parameters distance_calc.&#34;)

    if spherical:
        sqrt_2 = np.sqrt(2)
        half_sqrt_2 = np.divide(sqrt_2, 2)

        if normed &gt; (radius - half_sqrt_2) and normed &lt; (radius + half_sqrt_2):
            adjustment = sqrt_2 / normed
        elif normed &gt; (radius - half_sqrt_2):
            adjustment = 0.0
        elif normed &lt; (radius + half_sqrt_2):
            adjustment = 1.0
        else:
            adjustment = 1.0

        return weight * adjustment

    return weight


def rotate_kernel(bottom_right):
    &#34;&#34;&#34; Create a whole kernel from a quadrant. &#34;&#34;&#34;

    size = ((bottom_right.shape[0] - 1) * 2) + 1
    depth = bottom_right.shape[2]
    kernel = np.zeros((size, size, depth), dtype=&#34;float32&#34;)

    top_right = np.flipud(bottom_right)
    lower_left = np.fliplr(bottom_right)
    top_left = np.flipud(lower_left)

    kernel[size // 2:, size // 2:, :] = bottom_right
    kernel[:1 + -size // 2, :1 + -size // 2, :] = top_left
    kernel[1 + size // 2:, :size // 2, :] = lower_left[1:, :-1, :]
    kernel[:size // 2, 1 + size // 2:, :] = top_right[:-1, 1:, :]

    return kernel


def get_kernel(
    size,
    depth=1,
    hole=False,
    inverted=False,
    normalise=True,
    multi_dimensional=False,
    multi_dimensional_center=0,
    spherical=False,
    distance_weight=None,
    distance_decay=0.2,
    distance_sigma=1,
):
    &#34;&#34;&#34; Get a square kernel for convolutions.
        returns: kernel, weights, offsets.
    &#34;&#34;&#34;

    assert size &gt;= 3, &#34;Kernel must have atleast size 3.&#34;
    assert size % 2 != 0, &#34;Kernel must be an uneven size.&#34;
    assert isinstance(size, int), &#34;Kernel must be an integer.&#34;
    assert depth &gt;= 1, &#34;Depth must be a positive integer&#34;
    assert isinstance(depth, int), &#34;Depth must be an integer.&#34;

    if distance_weight is False:
        distance_weight = None

    quadrant = np.zeros((1 + size // 2, 1 + size // 2, depth), dtype=&#34;float32&#34;)

    for idx_x in range(0, quadrant.shape[0]):
        for idx_y in range(0, quadrant.shape[1]):
            for idx_z in range(0, quadrant.shape[2]):

                z_value = idx_z if multi_dimensional else 0

                weighted = weight_distance(
                    np.array([idx_x, idx_y, z_value], dtype=&#34;float32&#34;),
                    method=distance_weight,
                    decay=distance_decay,
                    sigma=distance_sigma,
                    center=multi_dimensional_center,
                    spherical=spherical,
                    radius=size // 2,
                )

                quadrant[idx_x, idx_y, idx_z] = weighted
    if hole:
        for idx_z in range(0, quadrant.shape[2]):
            quadrant[0, 0, idx_z] = 0

    kernel = rotate_kernel(quadrant)

    if distance_weight == &#34;log&#34;:
        kernel = kernel.max() - kernel

    if inverted:
        kernel = 1 - kernel

    if normalise:
        if multi_dimensional:
            summed = kernel.sum()
            if summed != 0.0:
                kernel = kernel / summed
        else:
            summed = kernel.sum(axis=(0, 1))

            for dim in range(0, depth):
                kernel[:, :, dim] = kernel[:, :, dim] / summed[dim]

    weights = []
    offsets = []

    for idx_x in range(0, kernel.shape[0]):
        for idx_y in range(0, kernel.shape[1]):
            for idx_z in range(0, kernel.shape[2]):
                current_weight = kernel[idx_x][idx_y][idx_z]

                if current_weight &lt;= 0.0:
                    continue

                offsets.append(
                    [
                        idx_x - (kernel.shape[0] // 2),
                        idx_y - (kernel.shape[1] // 2),
                        idx_z
                    ]
                )

                weights.append(current_weight)

    return kernel, np.array(weights, dtype=&#34;float32&#34;), np.array(offsets, dtype=int)


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_max(values, weights):
    &#34;&#34;&#34; Get the weighted maximum. &#34;&#34;&#34;
    idx = np.argmax(np.multiply(values, weights))
    return values[idx]


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_min(values, weights):
    &#34;&#34;&#34; Get the weighted minimum. &#34;&#34;&#34;
    max_val = values.max()
    adjusted_values = np.where(weights == 0.0, max_val, values)
    idx = np.argmin(np.divide(adjusted_values, weights + 1e-7))
    return values[idx]


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_sum(values, weights):
    &#34;&#34;&#34; Get the weighted sum. &#34;&#34;&#34;
    return np.sum(np.multiply(values, weights))


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_mode(values, weights):
    &#34;&#34;&#34; Get the weighted sum. &#34;&#34;&#34;
    values_ints = np.rint(values)
    unique = np.unique(values_ints)

    most_occured_value = 0
    most_occured_weight = -9999.9

    for unique_value in prange(unique):
        cum_weight = 0
        for idx in range(values.shape[0]):
            if values_ints[idx] == unique_value:
                cum_weight += weights[idx]

        if cum_weight &gt; most_occured_weight:
            most_occured_weight = cum_weight
            most_occured_value = unique_value

    return most_occured_value


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_contrast(values, weights):
    &#34;&#34;&#34; Get the local contrast. &#34;&#34;&#34;
    max_val = values.max()
    adjusted_values = np.where(weights == 0.0, max_val, values)
    local_min = np.min(np.divide(adjusted_values, weights + 1e-7))
    local_max = np.max(np.multiply(values, weights))

    return np.abs(local_max - local_min)

@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_quantile(values, weights, quant):
    &#34;&#34;&#34; Get the weighted median. &#34;&#34;&#34;
    sort_mask = np.argsort(values)
    sorted_data = values[sort_mask]
    sorted_weights = weights[sort_mask]
    cumsum = np.cumsum(sorted_weights)
    intersect = (cumsum - 0.5 * sorted_weights) / cumsum[-1]
    return np.interp(quant, intersect, sorted_data)


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_median_absolute_deviation(values, weights):
    &#34;&#34;&#34; Get the median absolute deviation &#34;&#34;&#34;
    median = hood_quantile(values, weights, 0.5)
    absdeviation = np.abs(np.subtract(values, median))
    return hood_quantile(absdeviation, weights, 0.5)


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_z_score(values, center_value, weights):
    &#34;&#34;&#34; Get the local z score .&#34;&#34;&#34;
    std = hood_standard_deviation(values, weights)
    mean = hood_sum(values, weights)

    return (center_value - mean) / std


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_z_score_mad(values, center_value, weights):
    &#34;&#34;&#34; Get the local z score calculated around the MAD. &#34;&#34;&#34;
    mad_std = hood_median_absolute_deviation(values, weights) * 1.4826
    median = hood_quantile(values, weights, 0.5)

    return (center_value - median) / mad_std


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_standard_deviation(values, weights):
    &#34;Get the weighted standard deviation. &#34;
    summed = hood_sum(values, weights)
    variance = np.sum(np.multiply(np.power(np.subtract(values, summed), 2), weights))
    return np.sqrt(variance)


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def k_to_size(size):
    &#34;&#34;&#34; Preprocess Sigma Lee limits. &#34;&#34;&#34;
    return int(np.rint(-0.0000837834 * size ** 2 + 0.045469 * size + 0.805733))


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_sigma_lee(values, weights):
    &#34;&#34;&#34; Sigma lee SAR filte. &#34;&#34;&#34;
    std = hood_standard_deviation(values, weights)
    selected_values = np.zeros_like(values)
    selected_weights = np.zeros_like(weights)

    sigma_mult = 1
    passed = 0
    attempts = 0
    ks = k_to_size(values.size)

    while passed &lt; ks and attempts &lt; 5:
        for idx, _val in enumerate(values):
            if values[idx] &gt;= std * sigma_mult and values[idx] &lt;= -std * sigma_mult:
                selected_values[idx] = values[idx]
                selected_weights[idx] = weights[idx]
                passed += 1

        sigma_mult += 1
        attempts += 1

    if passed &lt; ks:
        return hood_sum(values, weights)

    sum_of_weights = np.sum(selected_weights)

    if sum_of_weights == 0:
        return 0

    selected_weights = np.divide(selected_weights, sum_of_weights)

    return hood_sum(selected_values, selected_weights)

# @jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
# def hood_match_mean(primary, secondary, center_value, weights):
#     &#34;&#34;&#34; Match the local means of two arrays. &#34;&#34;&#34;
#     if weights.sum() &lt;= 0.0:
#         return 0.0

#     average_primary = np.average(primary, weights=weights)
#     average_secondary = np.average(secondary, weights=weights)

#     if average_secondary == 0.0:
#         return 0.0

#     ratio = average_secondary / average_primary

#     return ratio * center_value


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def pad_array(arr, pad_size=1):
    &#34;&#34;&#34; Pad an array using SAME &#34;&#34;&#34;
    # Core
    arr_padded = np.zeros((arr.shape[0] + int(pad_size * 2), arr.shape[1] + int(pad_size * 2), arr.shape[2]), dtype=arr.dtype)
    arr_padded[pad_size:-pad_size, pad_size:-pad_size, :] = arr

    # Corners
    arr_padded[0:pad_size, 0:pad_size, :] = arr[ 0,  0, :]
    arr_padded[-pad_size:, -pad_size:, :] = arr[-1, -1, :]
    arr_padded[0:pad_size, -pad_size:, :] = arr[ 0, -1, :]
    arr_padded[-pad_size:, 0:pad_size, :] = arr[-1,  0, :]

    # Sides
    for idx in range(0, pad_size):
        arr_padded[idx, pad_size:-pad_size, :] = arr[ 0,  :, :]
        arr_padded[-(idx + 1):, pad_size:-pad_size, :] = arr[-1,  :, :]
        arr_padded[pad_size:-pad_size, -(idx + 1), :] = arr[ :, -1, :]
        arr_padded[pad_size:-pad_size, idx, :] = arr[ :,  0, :]

    return arr_padded


@jit(nopython=True, nogil=True, fastmath=True)
def convolve_array(
    arr,
    offsets,
    weights,
    method=&#34;sum&#34;,
    # additional_array=None,
    nodata=False,
    nodata_value=-9999.9,
    pad=False,
    pad_size=1,
):
    &#34;&#34;&#34; Convolve an image with a function. &#34;&#34;&#34;

    # Edge-padding
    if pad:
        arr = pad_array(arr, pad_size=pad_size)

        # if additional_array is not None:
        #     additional_array = pad_array(additional_array, pad_size=1)

    x_adj = arr.shape[0] - 1
    y_adj = arr.shape[1] - 1
    z_adj = (arr.shape[2] - 1) // 2

    hood_size = len(offsets)

    # two_arrays = True if additional_array is not None else False

    result = np.zeros((arr.shape[0], arr.shape[1], 1), dtype=&#34;float32&#34;)

    for idx_x in prange(arr.shape[0]):
        for idx_y in prange(arr.shape[1]):

            hood_values = np.zeros(hood_size, dtype=&#34;float32&#34;)

            # if two_arrays:
            #     secondary_hood_values = np.zeros(hood_size, dtype=&#34;float32&#34;)

            hood_weights = np.zeros(hood_size, dtype=&#34;float32&#34;)
            weight_sum = np.array([0.0], dtype=&#34;float32&#34;)
            center_value = arr[idx_x, idx_y, 0]
            normalise = False

            for idx_n in range(hood_size):
                offset_x = idx_x + offsets[idx_n][0]
                offset_y = idx_y + offsets[idx_n][1]
                offset_z = offsets[idx_n][2]

                outside = False

                if offset_z &lt; -z_adj:
                    offset_z = -z_adj
                    outside = True
                elif offset_z &gt; z_adj:
                    offset_z = z_adj
                    outside = True

                if offset_x &lt; 0:
                    offset_x = 0
                    outside = True
                elif offset_x &gt; x_adj:
                    offset_x = x_adj
                    outside = True

                if offset_y &lt; 0:
                    offset_y = 0
                    outside = True
                elif offset_y &gt; y_adj:
                    offset_y = y_adj
                    outside = True

                value = arr[offset_x, offset_y, offset_z]

                if outside is True:
                    normalise = True
                    hood_weights[idx_n] = 0
                elif nodata and value == nodata_value:
                    normalise = True
                    hood_weights[idx_n] = 0
                else:
                    hood_values[idx_n] = value

                    # if two_arrays:
                    #     secondary_hood_values[idx_n] = additional_array[offset_x, offset_y, offset_z]

                    weight = weights[idx_n]

                    hood_weights[idx_n] = weight
                    weight_sum[0] += weight

            if normalise and weight_sum[0] &gt; 0.0:
                hood_weights = np.divide(hood_weights, weight_sum[0])

            if method == &#34;sum&#34;:
                result[idx_x, idx_y, 0] = hood_sum(hood_values, hood_weights)
            elif method == &#34;mode&#34;:
                result[idx_x, idx_y, 0] = hood_mode(hood_values, hood_weights)
            elif method == &#34;max&#34;:
                result[idx_x, idx_y, 0] = hood_max(hood_values, hood_weights)
            elif method == &#34;min&#34;:
                result[idx_x, idx_y, 0] = hood_min(hood_values, hood_weights)
            elif method == &#34;contrast&#34;:
                result[idx_x, idx_y, 0] = hood_contrast(hood_values, hood_weights)
            elif method == &#34;median&#34;:
                result[idx_x, idx_y, 0] = hood_quantile(hood_values, hood_weights, 0.5)
            elif method == &#34;std&#34;:
                result[idx_x, idx_y, 0] = hood_standard_deviation(hood_values, hood_weights)
            elif method == &#34;mad&#34;:
                result[idx_x, idx_y, 0] = hood_median_absolute_deviation(hood_values, hood_weights)
            elif method == &#34;z_score&#34;:
                result[idx_x, idx_y, 0] = hood_z_score(hood_values, center_value, hood_weights)
            elif method == &#34;z_score_mad&#34;:
                result[idx_x, idx_y, 0] = hood_z_score_mad(hood_values, center_value, hood_weights)
            elif method == &#34;sigma_lee&#34;:
                result[idx_x, idx_y, 0] = hood_sigma_lee(hood_values, hood_weights)
            # elif method == &#34;match_mean&#34;:
            #     result[idx_x, idx_y, 0] = hood_match_mean(hood_values, secondary_hood_values, center_value, hood_weights)
            else:
                raise ValueError(&#34;Unknown method passed to convolver&#34;)

    if pad:
        return result[
            pad_size:-pad_size,
            pad_size:-pad_size,
            :,
        ]

    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="buteo.raster.convolution.convolve_array"><code class="name flex">
<span>def <span class="ident">convolve_array</span></span>(<span>arr, offsets, weights, method='sum', nodata=False, nodata_value=-9999.9, pad=False, pad_size=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Convolve an image with a function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, nogil=True, fastmath=True)
def convolve_array(
    arr,
    offsets,
    weights,
    method=&#34;sum&#34;,
    # additional_array=None,
    nodata=False,
    nodata_value=-9999.9,
    pad=False,
    pad_size=1,
):
    &#34;&#34;&#34; Convolve an image with a function. &#34;&#34;&#34;

    # Edge-padding
    if pad:
        arr = pad_array(arr, pad_size=pad_size)

        # if additional_array is not None:
        #     additional_array = pad_array(additional_array, pad_size=1)

    x_adj = arr.shape[0] - 1
    y_adj = arr.shape[1] - 1
    z_adj = (arr.shape[2] - 1) // 2

    hood_size = len(offsets)

    # two_arrays = True if additional_array is not None else False

    result = np.zeros((arr.shape[0], arr.shape[1], 1), dtype=&#34;float32&#34;)

    for idx_x in prange(arr.shape[0]):
        for idx_y in prange(arr.shape[1]):

            hood_values = np.zeros(hood_size, dtype=&#34;float32&#34;)

            # if two_arrays:
            #     secondary_hood_values = np.zeros(hood_size, dtype=&#34;float32&#34;)

            hood_weights = np.zeros(hood_size, dtype=&#34;float32&#34;)
            weight_sum = np.array([0.0], dtype=&#34;float32&#34;)
            center_value = arr[idx_x, idx_y, 0]
            normalise = False

            for idx_n in range(hood_size):
                offset_x = idx_x + offsets[idx_n][0]
                offset_y = idx_y + offsets[idx_n][1]
                offset_z = offsets[idx_n][2]

                outside = False

                if offset_z &lt; -z_adj:
                    offset_z = -z_adj
                    outside = True
                elif offset_z &gt; z_adj:
                    offset_z = z_adj
                    outside = True

                if offset_x &lt; 0:
                    offset_x = 0
                    outside = True
                elif offset_x &gt; x_adj:
                    offset_x = x_adj
                    outside = True

                if offset_y &lt; 0:
                    offset_y = 0
                    outside = True
                elif offset_y &gt; y_adj:
                    offset_y = y_adj
                    outside = True

                value = arr[offset_x, offset_y, offset_z]

                if outside is True:
                    normalise = True
                    hood_weights[idx_n] = 0
                elif nodata and value == nodata_value:
                    normalise = True
                    hood_weights[idx_n] = 0
                else:
                    hood_values[idx_n] = value

                    # if two_arrays:
                    #     secondary_hood_values[idx_n] = additional_array[offset_x, offset_y, offset_z]

                    weight = weights[idx_n]

                    hood_weights[idx_n] = weight
                    weight_sum[0] += weight

            if normalise and weight_sum[0] &gt; 0.0:
                hood_weights = np.divide(hood_weights, weight_sum[0])

            if method == &#34;sum&#34;:
                result[idx_x, idx_y, 0] = hood_sum(hood_values, hood_weights)
            elif method == &#34;mode&#34;:
                result[idx_x, idx_y, 0] = hood_mode(hood_values, hood_weights)
            elif method == &#34;max&#34;:
                result[idx_x, idx_y, 0] = hood_max(hood_values, hood_weights)
            elif method == &#34;min&#34;:
                result[idx_x, idx_y, 0] = hood_min(hood_values, hood_weights)
            elif method == &#34;contrast&#34;:
                result[idx_x, idx_y, 0] = hood_contrast(hood_values, hood_weights)
            elif method == &#34;median&#34;:
                result[idx_x, idx_y, 0] = hood_quantile(hood_values, hood_weights, 0.5)
            elif method == &#34;std&#34;:
                result[idx_x, idx_y, 0] = hood_standard_deviation(hood_values, hood_weights)
            elif method == &#34;mad&#34;:
                result[idx_x, idx_y, 0] = hood_median_absolute_deviation(hood_values, hood_weights)
            elif method == &#34;z_score&#34;:
                result[idx_x, idx_y, 0] = hood_z_score(hood_values, center_value, hood_weights)
            elif method == &#34;z_score_mad&#34;:
                result[idx_x, idx_y, 0] = hood_z_score_mad(hood_values, center_value, hood_weights)
            elif method == &#34;sigma_lee&#34;:
                result[idx_x, idx_y, 0] = hood_sigma_lee(hood_values, hood_weights)
            # elif method == &#34;match_mean&#34;:
            #     result[idx_x, idx_y, 0] = hood_match_mean(hood_values, secondary_hood_values, center_value, hood_weights)
            else:
                raise ValueError(&#34;Unknown method passed to convolver&#34;)

    if pad:
        return result[
            pad_size:-pad_size,
            pad_size:-pad_size,
            :,
        ]

    return result</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.get_kernel"><code class="name flex">
<span>def <span class="ident">get_kernel</span></span>(<span>size, depth=1, hole=False, inverted=False, normalise=True, multi_dimensional=False, multi_dimensional_center=0, spherical=False, distance_weight=None, distance_decay=0.2, distance_sigma=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a square kernel for convolutions.
returns: kernel, weights, offsets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_kernel(
    size,
    depth=1,
    hole=False,
    inverted=False,
    normalise=True,
    multi_dimensional=False,
    multi_dimensional_center=0,
    spherical=False,
    distance_weight=None,
    distance_decay=0.2,
    distance_sigma=1,
):
    &#34;&#34;&#34; Get a square kernel for convolutions.
        returns: kernel, weights, offsets.
    &#34;&#34;&#34;

    assert size &gt;= 3, &#34;Kernel must have atleast size 3.&#34;
    assert size % 2 != 0, &#34;Kernel must be an uneven size.&#34;
    assert isinstance(size, int), &#34;Kernel must be an integer.&#34;
    assert depth &gt;= 1, &#34;Depth must be a positive integer&#34;
    assert isinstance(depth, int), &#34;Depth must be an integer.&#34;

    if distance_weight is False:
        distance_weight = None

    quadrant = np.zeros((1 + size // 2, 1 + size // 2, depth), dtype=&#34;float32&#34;)

    for idx_x in range(0, quadrant.shape[0]):
        for idx_y in range(0, quadrant.shape[1]):
            for idx_z in range(0, quadrant.shape[2]):

                z_value = idx_z if multi_dimensional else 0

                weighted = weight_distance(
                    np.array([idx_x, idx_y, z_value], dtype=&#34;float32&#34;),
                    method=distance_weight,
                    decay=distance_decay,
                    sigma=distance_sigma,
                    center=multi_dimensional_center,
                    spherical=spherical,
                    radius=size // 2,
                )

                quadrant[idx_x, idx_y, idx_z] = weighted
    if hole:
        for idx_z in range(0, quadrant.shape[2]):
            quadrant[0, 0, idx_z] = 0

    kernel = rotate_kernel(quadrant)

    if distance_weight == &#34;log&#34;:
        kernel = kernel.max() - kernel

    if inverted:
        kernel = 1 - kernel

    if normalise:
        if multi_dimensional:
            summed = kernel.sum()
            if summed != 0.0:
                kernel = kernel / summed
        else:
            summed = kernel.sum(axis=(0, 1))

            for dim in range(0, depth):
                kernel[:, :, dim] = kernel[:, :, dim] / summed[dim]

    weights = []
    offsets = []

    for idx_x in range(0, kernel.shape[0]):
        for idx_y in range(0, kernel.shape[1]):
            for idx_z in range(0, kernel.shape[2]):
                current_weight = kernel[idx_x][idx_y][idx_z]

                if current_weight &lt;= 0.0:
                    continue

                offsets.append(
                    [
                        idx_x - (kernel.shape[0] // 2),
                        idx_y - (kernel.shape[1] // 2),
                        idx_z
                    ]
                )

                weights.append(current_weight)

    return kernel, np.array(weights, dtype=&#34;float32&#34;), np.array(offsets, dtype=int)</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_contrast"><code class="name flex">
<span>def <span class="ident">hood_contrast</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the local contrast.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_contrast(values, weights):
    &#34;&#34;&#34; Get the local contrast. &#34;&#34;&#34;
    max_val = values.max()
    adjusted_values = np.where(weights == 0.0, max_val, values)
    local_min = np.min(np.divide(adjusted_values, weights + 1e-7))
    local_max = np.max(np.multiply(values, weights))

    return np.abs(local_max - local_min)</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_max"><code class="name flex">
<span>def <span class="ident">hood_max</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the weighted maximum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_max(values, weights):
    &#34;&#34;&#34; Get the weighted maximum. &#34;&#34;&#34;
    idx = np.argmax(np.multiply(values, weights))
    return values[idx]</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_median_absolute_deviation"><code class="name flex">
<span>def <span class="ident">hood_median_absolute_deviation</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the median absolute deviation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_median_absolute_deviation(values, weights):
    &#34;&#34;&#34; Get the median absolute deviation &#34;&#34;&#34;
    median = hood_quantile(values, weights, 0.5)
    absdeviation = np.abs(np.subtract(values, median))
    return hood_quantile(absdeviation, weights, 0.5)</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_min"><code class="name flex">
<span>def <span class="ident">hood_min</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the weighted minimum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_min(values, weights):
    &#34;&#34;&#34; Get the weighted minimum. &#34;&#34;&#34;
    max_val = values.max()
    adjusted_values = np.where(weights == 0.0, max_val, values)
    idx = np.argmin(np.divide(adjusted_values, weights + 1e-7))
    return values[idx]</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_mode"><code class="name flex">
<span>def <span class="ident">hood_mode</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the weighted sum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_mode(values, weights):
    &#34;&#34;&#34; Get the weighted sum. &#34;&#34;&#34;
    values_ints = np.rint(values)
    unique = np.unique(values_ints)

    most_occured_value = 0
    most_occured_weight = -9999.9

    for unique_value in prange(unique):
        cum_weight = 0
        for idx in range(values.shape[0]):
            if values_ints[idx] == unique_value:
                cum_weight += weights[idx]

        if cum_weight &gt; most_occured_weight:
            most_occured_weight = cum_weight
            most_occured_value = unique_value

    return most_occured_value</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_quantile"><code class="name flex">
<span>def <span class="ident">hood_quantile</span></span>(<span>values, weights, quant)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the weighted median.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_quantile(values, weights, quant):
    &#34;&#34;&#34; Get the weighted median. &#34;&#34;&#34;
    sort_mask = np.argsort(values)
    sorted_data = values[sort_mask]
    sorted_weights = weights[sort_mask]
    cumsum = np.cumsum(sorted_weights)
    intersect = (cumsum - 0.5 * sorted_weights) / cumsum[-1]
    return np.interp(quant, intersect, sorted_data)</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_sigma_lee"><code class="name flex">
<span>def <span class="ident">hood_sigma_lee</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Sigma lee SAR filte.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_sigma_lee(values, weights):
    &#34;&#34;&#34; Sigma lee SAR filte. &#34;&#34;&#34;
    std = hood_standard_deviation(values, weights)
    selected_values = np.zeros_like(values)
    selected_weights = np.zeros_like(weights)

    sigma_mult = 1
    passed = 0
    attempts = 0
    ks = k_to_size(values.size)

    while passed &lt; ks and attempts &lt; 5:
        for idx, _val in enumerate(values):
            if values[idx] &gt;= std * sigma_mult and values[idx] &lt;= -std * sigma_mult:
                selected_values[idx] = values[idx]
                selected_weights[idx] = weights[idx]
                passed += 1

        sigma_mult += 1
        attempts += 1

    if passed &lt; ks:
        return hood_sum(values, weights)

    sum_of_weights = np.sum(selected_weights)

    if sum_of_weights == 0:
        return 0

    selected_weights = np.divide(selected_weights, sum_of_weights)

    return hood_sum(selected_values, selected_weights)</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_standard_deviation"><code class="name flex">
<span>def <span class="ident">hood_standard_deviation</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the weighted standard deviation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_standard_deviation(values, weights):
    &#34;Get the weighted standard deviation. &#34;
    summed = hood_sum(values, weights)
    variance = np.sum(np.multiply(np.power(np.subtract(values, summed), 2), weights))
    return np.sqrt(variance)</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_sum"><code class="name flex">
<span>def <span class="ident">hood_sum</span></span>(<span>values, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the weighted sum.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_sum(values, weights):
    &#34;&#34;&#34; Get the weighted sum. &#34;&#34;&#34;
    return np.sum(np.multiply(values, weights))</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_z_score"><code class="name flex">
<span>def <span class="ident">hood_z_score</span></span>(<span>values, center_value, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the local z score .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_z_score(values, center_value, weights):
    &#34;&#34;&#34; Get the local z score .&#34;&#34;&#34;
    std = hood_standard_deviation(values, weights)
    mean = hood_sum(values, weights)

    return (center_value - mean) / std</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.hood_z_score_mad"><code class="name flex">
<span>def <span class="ident">hood_z_score_mad</span></span>(<span>values, center_value, weights)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the local z score calculated around the MAD.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def hood_z_score_mad(values, center_value, weights):
    &#34;&#34;&#34; Get the local z score calculated around the MAD. &#34;&#34;&#34;
    mad_std = hood_median_absolute_deviation(values, weights) * 1.4826
    median = hood_quantile(values, weights, 0.5)

    return (center_value - median) / mad_std</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.k_to_size"><code class="name flex">
<span>def <span class="ident">k_to_size</span></span>(<span>size)</span>
</code></dt>
<dd>
<div class="desc"><p>Preprocess Sigma Lee limits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def k_to_size(size):
    &#34;&#34;&#34; Preprocess Sigma Lee limits. &#34;&#34;&#34;
    return int(np.rint(-0.0000837834 * size ** 2 + 0.045469 * size + 0.805733))</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.pad_array"><code class="name flex">
<span>def <span class="ident">pad_array</span></span>(<span>arr, pad_size=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Pad an array using SAME</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def pad_array(arr, pad_size=1):
    &#34;&#34;&#34; Pad an array using SAME &#34;&#34;&#34;
    # Core
    arr_padded = np.zeros((arr.shape[0] + int(pad_size * 2), arr.shape[1] + int(pad_size * 2), arr.shape[2]), dtype=arr.dtype)
    arr_padded[pad_size:-pad_size, pad_size:-pad_size, :] = arr

    # Corners
    arr_padded[0:pad_size, 0:pad_size, :] = arr[ 0,  0, :]
    arr_padded[-pad_size:, -pad_size:, :] = arr[-1, -1, :]
    arr_padded[0:pad_size, -pad_size:, :] = arr[ 0, -1, :]
    arr_padded[-pad_size:, 0:pad_size, :] = arr[-1,  0, :]

    # Sides
    for idx in range(0, pad_size):
        arr_padded[idx, pad_size:-pad_size, :] = arr[ 0,  :, :]
        arr_padded[-(idx + 1):, pad_size:-pad_size, :] = arr[-1,  :, :]
        arr_padded[pad_size:-pad_size, -(idx + 1), :] = arr[ :, -1, :]
        arr_padded[pad_size:-pad_size, idx, :] = arr[ :,  0, :]

    return arr_padded</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.rotate_kernel"><code class="name flex">
<span>def <span class="ident">rotate_kernel</span></span>(<span>bottom_right)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a whole kernel from a quadrant.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_kernel(bottom_right):
    &#34;&#34;&#34; Create a whole kernel from a quadrant. &#34;&#34;&#34;

    size = ((bottom_right.shape[0] - 1) * 2) + 1
    depth = bottom_right.shape[2]
    kernel = np.zeros((size, size, depth), dtype=&#34;float32&#34;)

    top_right = np.flipud(bottom_right)
    lower_left = np.fliplr(bottom_right)
    top_left = np.flipud(lower_left)

    kernel[size // 2:, size // 2:, :] = bottom_right
    kernel[:1 + -size // 2, :1 + -size // 2, :] = top_left
    kernel[1 + size // 2:, :size // 2, :] = lower_left[1:, :-1, :]
    kernel[:size // 2, 1 + size // 2:, :] = top_right[:-1, 1:, :]

    return kernel</code></pre>
</details>
</dd>
<dt id="buteo.raster.convolution.weight_distance"><code class="name flex">
<span>def <span class="ident">weight_distance</span></span>(<span>arr, method, decay, sigma, center, spherical, radius)</span>
</code></dt>
<dd>
<div class="desc"><p>Weight the kernel by distance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def weight_distance(arr, method, decay, sigma, center, spherical, radius):
    &#34;&#34;&#34; Weight the kernel by distance. &#34;&#34;&#34;

    if center == 0.0:
        normed = np.linalg.norm(arr)
    else:
        normed = np.linalg.norm(arr - np.array([0, 0, center]))

    if normed == 0.0:
        weight = 1.0

    if method is None or method == &#34;none&#34; or method == &#34;&#34;:
        weight = 1.0
    elif method == &#34;linear&#34;:
        weight = np.power((1 - decay), normed)
    elif method == &#34;sqrt&#34;:
        weight = np.power(np.sqrt((1 - decay)), normed)
    elif method == &#34;power&#34;:
        weight = np.power(np.power((1 - decay), 2), normed)
    elif method == &#34;log&#34;:
        weight = np.log(normed + 2)
    elif method == &#34;gaussian&#34;:
        weight = np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2)))
    else:
        raise ValueError(&#34;Unable to parse parameters distance_calc.&#34;)

    if spherical:
        sqrt_2 = np.sqrt(2)
        half_sqrt_2 = np.divide(sqrt_2, 2)

        if normed &gt; (radius - half_sqrt_2) and normed &lt; (radius + half_sqrt_2):
            adjustment = sqrt_2 / normed
        elif normed &gt; (radius - half_sqrt_2):
            adjustment = 0.0
        elif normed &lt; (radius + half_sqrt_2):
            adjustment = 1.0
        else:
            adjustment = 1.0

        return weight * adjustment

    return weight</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#perform-convolutions-on-arrays">Perform convolutions on arrays.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buteo.raster" href="index.html">buteo.raster</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="buteo.raster.convolution.convolve_array" href="#buteo.raster.convolution.convolve_array">convolve_array</a></code></li>
<li><code><a title="buteo.raster.convolution.get_kernel" href="#buteo.raster.convolution.get_kernel">get_kernel</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_contrast" href="#buteo.raster.convolution.hood_contrast">hood_contrast</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_max" href="#buteo.raster.convolution.hood_max">hood_max</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_median_absolute_deviation" href="#buteo.raster.convolution.hood_median_absolute_deviation">hood_median_absolute_deviation</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_min" href="#buteo.raster.convolution.hood_min">hood_min</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_mode" href="#buteo.raster.convolution.hood_mode">hood_mode</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_quantile" href="#buteo.raster.convolution.hood_quantile">hood_quantile</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_sigma_lee" href="#buteo.raster.convolution.hood_sigma_lee">hood_sigma_lee</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_standard_deviation" href="#buteo.raster.convolution.hood_standard_deviation">hood_standard_deviation</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_sum" href="#buteo.raster.convolution.hood_sum">hood_sum</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_z_score" href="#buteo.raster.convolution.hood_z_score">hood_z_score</a></code></li>
<li><code><a title="buteo.raster.convolution.hood_z_score_mad" href="#buteo.raster.convolution.hood_z_score_mad">hood_z_score_mad</a></code></li>
<li><code><a title="buteo.raster.convolution.k_to_size" href="#buteo.raster.convolution.k_to_size">k_to_size</a></code></li>
<li><code><a title="buteo.raster.convolution.pad_array" href="#buteo.raster.convolution.pad_array">pad_array</a></code></li>
<li><code><a title="buteo.raster.convolution.rotate_kernel" href="#buteo.raster.convolution.rotate_kernel">rotate_kernel</a></code></li>
<li><code><a title="buteo.raster.convolution.weight_distance" href="#buteo.raster.convolution.weight_distance">weight_distance</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>