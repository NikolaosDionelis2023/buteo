<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>buteo.raster.patches API documentation</title>
<meta name="description" content="Create patches from rasters, used for machine learnign applications." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buteo.raster.patches</code></h1>
</header>
<section id="section-intro">
<p>Create patches from rasters, used for machine learnign applications.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34; Create patches from rasters, used for machine learnign applications. &#34;&#34;&#34;

from typing import Union, List, Tuple, Optional, Callable
import numpy as np
from numba import prange, jit


def get_kernel_weights(
    tile_size: int = 64,
    edge_distance: int = 5,
    epsilon: float = 1e-7,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Weight a kernel according to how close to an edge a given pixel is.

    Keyword Args:
        tile_size (int=64): The size of the square kernel.
        edge_distance (int=5): The distance from the edge to consider for weighting.
        epsilon (float=1e-7): A small value to prevent division by zero.

    Returns:
        np.ndarray: A 2D NumPy array of shape (tile_size, tile_size) with the kernel weights.
    &#34;&#34;&#34;
    assert tile_size &gt; 0, &#34;Tile size must be greater than zero.&#34;
    assert edge_distance &lt; tile_size // 2, &#34;Edge distance must be less than half the tile size.&#34;
    assert edge_distance &gt;= 0, &#34;Edge distance must be greater than or equal to zero.&#34;

    arr = np.zeros((tile_size, tile_size), dtype=&#34;float32&#34;)
    max_dist = edge_distance * 2

    # Iterate through the kernel array
    for idx_y in range(0, arr.shape[0]):
        for idx_x in range(0, arr.shape[1]):

            # Calculate vertical distance to the closest edge
            val_y_top = max(edge_distance - idx_y, 0.0)
            val_y_bot = max((1 + edge_distance) - (tile_size - idx_y), 0.0)
            val_y = val_y_top + val_y_bot

            # Calculate horizontal distance to the closest edge
            val_x_lef = max(edge_distance - idx_x, 0.0)
            val_x_rig = max((1 + edge_distance) - (tile_size - idx_x), 0.0)
            val_x = val_x_lef + val_x_rig

            # Calculate the weight based on the distance to the closest edge
            val = (max_dist - abs(val_y + val_x)) / max_dist

            # Set a minimum weight to avoid division by zero
            if val &lt;= 0.0:
                val = epsilon

            # Assign the calculated weight to the kernel array
            arr[idx_y, idx_x] = val

    return arr


@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_median(
    arr: np.ndarray,
    arr_weight: np.ndarray,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted median of a multi-dimensional array along the first axis.
    This is the order (number_of_overlaps, tile_size, tile_size, number_of_bands)
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[1], arr.shape[2], arr.shape[3]) with the weighted medians.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Sort the values and weights based on the values
                sort_mask = np.argsort(values)
                sorted_data = values[sort_mask]
                sorted_weights = weights[sort_mask]

                # Calculate the cumulative sum of the sorted weights
                cumsum = np.cumsum(sorted_weights)

                # Normalize the cumulative sum to the range [0, 1]
                intersect = (cumsum - 0.5 * sorted_weights) / cumsum[-1]

                # Interpolate the weighted median and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = np.interp(0.5, intersect, sorted_data)

    return ret_arr


@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_average(
    arr: np.ndarray,
    arr_weight: np.ndarray,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted average of a multi-dimensional array along the last axis.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted averages.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Calculate the weighted sum and total weight
                weighted_sum = np.nansum(values * weights)
                total_weight = np.nansum(weights)

                # Calculate the weighted average and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = weighted_sum / total_weight

    return ret_arr

@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_minmax(
    arr: np.ndarray,
    arr_weight: np.ndarray,
    method=&#34;max&#34;,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted min or max of a multi-dimensional array along the last axis.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted min or max.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    minmax = 0
    if method == &#34;min&#34;:
        minmax = 1

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                weighted = values * weights

                if minmax == 0: # max
                    index = np.nanargmax(weighted)
                else:
                    index = np.nanargmin(weighted)

                value = values[index]

                # Calculate the weighted average and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = value

    return ret_arr


@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_olympic(
    arr: np.ndarray,
    arr_weight: np.ndarray,
    level: int = 1,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the olympic value of a multi-dimensional array along the last axis.
    Using olympic sort, the highest and lowest values are removed from the calculation.
    If level is 1, then the highest and loweest values are removed. If the level is 2,
    then the 2 highest and lowest values are removed, and so on.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the olympic value.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    required = int((level * 2) + 1)

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                if len(values) &lt; required: # Take the average of all
                    value = np.mean(values)
                elif len(values) == required: # Take the middle value
                    value = np.sort(values)[level]
                else:
                    sort_olympic = np.argsort(values)[level:-level]
                    sort_weights = weights[sort_olympic] / np.sum(weights[sort_olympic])
                    sort_values = values[sort_olympic]

                    value = np.sum(sort_values * sort_weights)

                # Calculate the weighted average and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = value

    return ret_arr


@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_mad(
    arr: np.ndarray,
    arr_weight: np.ndarray,
    mad_dist: float = 2.0,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Merge an array of predictions using the MAD-merge methodology.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    Keyword Args:
        mad_dist (float=2.0): The MAD distance.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the MAD-merged values.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Sort the values and weights based on the values
                sort_mask = np.argsort(values)
                sorted_data = values[sort_mask]
                sorted_weights = weights[sort_mask]

                # Calculate the cumulative sum of the sorted weights and normalize to the range [0, 1]
                cumsum = np.cumsum(sorted_weights)
                intersect = (cumsum - 0.5 * sorted_weights) / cumsum[-1]

                # Interpolate the median
                median = np.interp(0.5, intersect, sorted_data)

                # Calculate the median absolute deviation (MAD)
                mad = np.median(np.abs(median - values))

                # If MAD is zero, store the median in the result array and continue
                if mad == 0.0:
                    ret_arr[idx_y, idx_x, 0] = median
                    continue

                # Calculate the new weights based on the MAD
                new_weights = np.zeros_like(sorted_weights)
                for idx_z in range(sorted_data.shape[0]):
                    new_weights[idx_z] = 1.0 - (np.minimum(np.abs(sorted_data[idx_z] - median) / (mad * mad_dist), 1))

                if np.sum(new_weights) == 0.0:
                    ret_arr[idx_y, idx_x, 0] = median
                    continue

                # Calculate the cumulative sum of the new weights and normalize to the range [0, 1]
                cumsum = np.cumsum(new_weights)
                intersect = (cumsum - 0.5 * new_weights) / cumsum[-1]

                # Interpolate the MAD-merged value and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = np.interp(0.5, intersect, sorted_data)

    return ret_arr


@jit(nopython=True, nogil=True)
def unique_values(arr: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Find the unique values in a 1D NumPy array.
    
    Args:
        arr (np.ndarray): The input array.
    
    Returns:
        np.ndarray: A 1D NumPy array with the unique values.
    &#34;&#34;&#34;
    unique = np.empty(arr.size, dtype=arr.dtype)
    unique_count = 0
    for i in range(arr.shape[0]):
        if arr[i] not in unique[:unique_count]:
            unique[unique_count] = arr[i]
            unique_count += 1

    return unique[:unique_count]


@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_mode(
    arr: np.ndarray,
    arr_weight: np.ndarray,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted mode of a multi-dimensional array along the last axis.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted modes.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=arr.dtype)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Get unique values and their weighted counts
                unique_vals = unique_values(values)
                weighted_counts = np.zeros(unique_vals.shape[0])

                # Calculate the weighted sum for each unique value
                for i in range(unique_vals.shape[0]):
                    idxs = np.where(values == unique_vals[i])
                    weighted_counts[i] = np.sum(weights[idxs])

                # Get the index of the maximum weighted sum
                mode_idx = np.argmax(weighted_counts)

                # Store the weighted mode in the result array
                ret_arr[idx_y, idx_x, idx_band] = unique_vals[mode_idx]

    return ret_arr


def calculate_offset_single(
    tile_size: int,
    num_offsets: int,
) -&gt; List[int]:
    &#34;&#34;&#34;
    Calculate a list of offset values for a given tile size and number of offsets.

    Args:
        tile_size (int): The size of each tile.
        num_offsets (int): The desired number of offsets to be calculated.

    Returns:
        List[int]: A list of calculated offset values.
    &#34;&#34;&#34;
    assert num_offsets &gt;= 0, &#34;Number of offsets must be greater than or equal to 0.&#34;
    assert tile_size &gt; 0, &#34;Tile size must be greater than 0.&#34;

    # Initialize the list of offsets with the first value, 0
    offsets = [0]
    previous = None
    for _ in range(num_offsets):

        # Calculate the step size based on previous step
        if previous is None:
            step = tile_size // 2
            previous = step
        else:
            step = previous // 2
            previous = step

        # Break the loop if the step size is 0
        if step == 0:
            break

        # Calculate and add offset values based on the step size
        for j in range(1, num_offsets + 1):
            val = j * step
            if (
                val not in offsets
                and val &lt; tile_size
                and val &gt; 0
                and len(offsets) &lt; num_offsets + 1
            ):
                offsets.append(j * step)

    return offsets

def get_offsets(
    tile_size: int,
    offsets_y: int,
    offsets_x: int,
) -&gt; List[Tuple[int, int]]:
    &#34;&#34;&#34;
    Generate a list of offset pairs for a given tile size and number of offsets in x and y dimensions.

    Args:
        tile_size (int): The size of each tile.
        offsets_y (int): The desired number of offsets to be calculated in the y dimension.
        offsets_x (int): The desired number of offsets to be calculated in the x dimension.

    Returns:
        List[Tuple[int, int]]: A list of tuples containing offset pairs for y and x dimensions.
        order is (y, x)
    &#34;&#34;&#34;
    assert offsets_y &gt;= 0, &#34;Number of offsets in y dimension must be &gt;= 0&#34;
    assert offsets_x &gt;= 0, &#34;Number of offsets in x dimension must be &gt;= 0&#34;
    assert tile_size &gt; 0, &#34;Tile size must be &gt; 0&#34;

    offsets_y = calculate_offset_single(tile_size, offsets_y)
    offsets_x = calculate_offset_single(tile_size, offsets_x)

    offsets = []
    for y in offsets_y:
        for x in offsets_x:
            offsets.append((y, x))

    return offsets


def borders_are_necessary(
    arr: np.ndarray,
    tile_size: int,
    offset: List[int],
) -&gt; Tuple[bool, bool]:
    &#34;&#34;&#34;
    Checks if borders are necessary for the given array.
    Width and height are returned as a tuple.

    Args:
        arr (np.ndarray): The array to be checked.
        tile_size (int): The size of each tile.
        offset (list): The offset to be used.

    Returns:
        tuple: A tuple containing of borders are needed in (height, width) dims.
    &#34;&#34;&#34;
    if arr.ndim == 2:
        height, width = arr.shape
    else:
        height, width, _ = arr.shape

    if (height - offset[0]) % tile_size == 0:
        height_border = False
    else:
        height_border = True

    if (width - offset[1]) % tile_size == 0:
        width_border = False
    else:
        width_border = True

    return height_border, width_border


def borders_are_necessary_list(
    arr: np.ndarray,
    tile_size: int,
    offsets: List[List[int]],
) -&gt; Tuple[bool, bool]:
    &#34;&#34;&#34;
    Checks if borders are necessary for the given array.
    Width and height are returned as a tuple.

    Args:
        arr (np.ndarray): The array to be checked.
        tile_size (int): The size of each tile.
        offsets (list): The offset to be used.

    Returns:
        tuple: A tuple containing of borders are needed in (height, width) dims.
    &#34;&#34;&#34;
    height_border = True
    width_border = True

    for offset in offsets:
        offset_height_border, offset_width_border = borders_are_necessary(
            arr, tile_size, offset
        )
        if not offset_height_border:
            height_border = False

        if not offset_width_border:
            width_border = False

        if not height_border and not width_border:
            break

    return height_border, width_border


def array_to_patches_single(
    arr: np.ndarray,
    tile_size: int,
    offset: Optional[Union[List[int], Tuple[int, int]]] = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate patches from an array.

    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        tile_size (int): The size of each tile/patch, e.g., 64 for 64x64 tiles.
        offset (list/tuple/None=None): The x and y offset values for the input
            array. If not provided, defaults to [0, 0].

    Returns:
        nd.array: A numpy array containing the patches.
    &#34;&#34;&#34;
    assert arr.ndim in [2, 3], &#34;Array must be 2D or 3D&#34;
    assert tile_size &gt; 0, &#34;Tile size must be greater than 0&#34;
    assert offset is None or len(offset) == 2, &#34;Offset must be a list or tuple of length 2&#34;

    # Set default offset to [0, 0] if not provided
    if offset is None:
        offset = [0, 0]

    # Calculate the number of patches in the y and x dimensions
    patches_y = (arr.shape[0] - offset[0]) // tile_size
    patches_x = (arr.shape[1] - offset[1]) // tile_size

    # Calculate cut dimensions for the y and x dimensions
    cut_y = -((arr.shape[0] - offset[0]) % tile_size)
    cut_x = -((arr.shape[1] - offset[1]) % tile_size)

    # Set cut dimensions to None if they are 0
    cut_y = None if cut_y == 0 else cut_y
    cut_x = None if cut_x == 0 else cut_x

    # Reshape the array to separate the patches
    reshaped = arr[offset[0]:cut_y, offset[1]:cut_x].reshape(
        patches_y,
        tile_size,
        patches_x,
        tile_size,
        arr.shape[2],
    )

    # Swap axes to rearrange patches in the correct order
    swaped = reshaped.swapaxes(1, 2)

    # Combine the patches into a single array
    blocks = swaped.reshape(-1, tile_size, tile_size, arr.shape[2])

    return blocks


def patches_to_array_single(
    patches: np.ndarray,
    shape: Union[List, Tuple],
    tile_size: int,
    offset: Optional[Union[List, Tuple]] = None,
    background_value: Optional[Union[int, float]] = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Reconstitute an array from patches.

    Given an array of patches, this function stitches them back together
    to form the original array of the specified shape.

    Args:
        patches (np.ndarray): A numpy array containing the patches to be
            stitched together.
        shape (list/tuple): The desired shape of the output array.
        tile_size (int): The size of each tile/patch Eg. 64 for 64x64 tiles.

    Keyword Args:
        offset (list/tuple/None=None): The x and y offset values for the
            target array. If not provided, defaults to [0, 0].

    Returns:
        np.ndarray: A numpy array with the original shape, formed by stitching
            together the provided patches.
    &#34;&#34;&#34;
    assert len(shape) in [2, 3], &#34;Shape must be a tuple or list of length 2 or 3&#34;
    assert len(patches.shape) == 4, &#34;Patches must be a 4D array&#34;
    assert patches.shape[1] == tile_size, &#34;Patches must be of size tile_size&#34;
    assert patches.shape[2] == tile_size, &#34;Patches must be of size tile_size&#34;
    assert offset is None or len(offset) == 2, &#34;Offset must be a tuple or list of length 2&#34;

    # Set default offset to [0, 0] if not provided
    if offset is None:
        offset = [0, 0]

    # Create an empty target array of the specified shape
    if background_value is None:
        target = np.full(shape, np.nan, dtype=patches.dtype)
    else:
        target = np.full(shape, background_value, dtype=patches.dtype)

    # Calculate target dimensions
    target_y = ((shape[0] - offset[0]) // tile_size) * tile_size
    target_x = ((shape[1] - offset[1]) // tile_size) * tile_size

    # Calculate cut dimensions
    cut_y = -((shape[0] - offset[0]) % tile_size)
    cut_x = -((shape[1] - offset[1]) % tile_size)

    # Set cut dimensions to None if they are 0
    cut_y = None if cut_y == 0 else cut_y
    cut_x = None if cut_x == 0 else cut_x

    # Calculate the number of tiles in the y and x dimensions
    num_tiles_y = target_y // tile_size
    num_tiles_x = target_x // tile_size

    # Reshape the patches for stitching
    reshape = patches.reshape(
        num_tiles_y,
        num_tiles_x,
        tile_size,
        tile_size,
        patches.shape[3],
        1,
    )

    # Swap axes to rearrange patches in the correct order for stitching
    swap = reshape.swapaxes(1, 2)

    # Combine the patches into a single array
    destination = swap.reshape(
        num_tiles_y * tile_size,
        num_tiles_x * tile_size,
        patches.shape[3],
    )

    # Assign the combined patches to the target array
    target[offset[0]:cut_y, offset[1]:cut_x] = destination

    return target


def patches_to_weights(
    patches: np.ndarray,
    edge_distance: int,
) -&gt; np.ndarray:
    &#34;&#34;&#34; Calculate the weights for each patch based on the distance to the edge. &#34;&#34;&#34;
    assert len(patches.shape) == 4, &#34;Patches must be a 4D array&#34;
    assert patches.shape[1] == patches.shape[2], &#34;Patches must be square&#34;

    # Calculate the distance to the edge for each patch
    weights = get_kernel_weights(patches.shape[1], edge_distance)

    # Expand the weights to match the number of patches
    weights = np.repeat(weights[np.newaxis, ...], patches.shape[0], axis=0)[..., np.newaxis]

    return weights

def array_to_patches(
    arr: np.ndarray,
    tile_size: int,
    offsets_y: int = 3,
    offsets_x: int = 3,
    border_check: bool = True,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate patches from an array based on the specified parameters.

    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        tile_size (int): The size of each tile/patch, e.g., 64 for 64x64 tiles.
        offsets_y (int=3): The desired number of offsets to be calculated in the y dimension.
        offsets_x (int=3): The desired number of offsets to be calculated in the x dimension.
        border_check (bool=True): Whether or not to include border patches.

    Returns:
        np.ndarray: The concatenate patches along axis 0. In the order (patches, y, x, channels)
    &#34;&#34;&#34;
    # Get the list of offsets for both x and y dimensions
    offsets = get_offsets(tile_size, offsets_y, offsets_x)

    if border_check:
        borders_y, borders_x = borders_are_necessary_list(arr, tile_size, offsets)

        if borders_y:
            offsets.append([arr.shape[0] - tile_size, 0])
        if borders_x:
            offsets.append([0, arr.shape[1] - tile_size])

    # Initialize an empty list to store the generated patches
    patches = []

    # Iterate through the offsets and generate patches for each offset
    for offset in offsets:
        patches.append(
            array_to_patches_single(arr, tile_size, offset),
        )

    patches = np.concatenate(patches, axis=0)

    return patches


def predict_array(
    arr: np.ndarray,
    callback: Callable[[np.ndarray], np.ndarray],
    tile_size=64,
    offsets_y=1,
    offsets_x=1,
    border_check=True,
    merge_method=&#34;median&#34;,
    edge_weighted=True,
    edge_distance=3,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate patches from an array. Also outputs the offsets and the shapes of the offsets. Only
    suppors the prediction of single values in the rasters/arrays. 
    
    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        callback (function): The callback function to be used for prediction. The callback function
            must take a numpy array as input and return a numpy array as output.
    
    Keyword Args:
        tile_size (int=64): The size of each tile/patch, e.g., 64 for 64x64 tiles.
        offsets_y (int=1): The desired number of offsets to be calculated in the y dimension.
        offsets_x (int=1): The desired number of offsets to be calculated in the x dimension.
        border_check (bool=True): Whether or not to include border patches.
        merge_method (str=&#34;median&#34;): The method to use for merging the patches. Valid methods
        are [&#39;mad&#39;, &#39;median&#39;, &#39;mean&#39;, &#39;mode&#39;, &#34;min&#34;, &#34;max&#34;, &#34;olympic1&#34;, &#34;olympic2&#34;]
        edge_weighted (bool=True): Whether or not to weight the edges patches of patches less
            than the central parts.
        edge_distance (int=3): The distance from the edge to be weighted less. Usually good to
            adjust this to your maximum convolution kernel size.

    Returns:
        np.ndarray: The predicted array.
    &#34;&#34;&#34;
    assert merge_method in [&#34;mad&#34;, &#34;median&#34;, &#34;mean&#34;, &#34;mode&#34;], &#34;Invalid merge method&#34;
    assert len(arr.shape) == 3, &#34;Array must be 3D&#34;
    assert tile_size &lt; arr.shape[0], &#34;Tile size must be smaller than the array size&#34;
    assert tile_size &lt; arr.shape[1], &#34;Tile size must be smaller than the array size&#34;

    # Get the list of offsets for both x and y dimensions
    offsets = get_offsets(tile_size, offsets_y, offsets_x)

    if border_check:
        borders_y, borders_x = borders_are_necessary_list(arr, tile_size, offsets)

        if borders_y:
            offsets.append([arr.shape[0] - tile_size, 0])
        if borders_x:
            offsets.append([0, arr.shape[1] - tile_size])

    # Test output dimensions of prediction
    test_patch = arr[np.newaxis, :tile_size, :tile_size, :]
    test_prediction = callback(test_patch)
    test_shape = test_prediction.shape

    # Initialize an empty list to store the generated patches
    predictions = np.zeros((len(offsets), arr.shape[0], arr.shape[1], test_shape[-1]), dtype=arr.dtype)
    predictions_weights = np.zeros((len(offsets), arr.shape[0], arr.shape[1], 1), dtype=np.float32)

    # Iterate through the offsets and generate patches for each offset
    for idx, offset in enumerate(offsets):
        patches = array_to_patches_single(arr, tile_size, offset)

        prediction = callback(patches)

        if edge_weighted:
            weights = patches_to_weights(patches, edge_distance)
        else:
            weights = np.ones((tile_size, tile_size, 1), dtype=np.float32)
            weights = np.repeat(weights[np.newaxis, ...], patches.shape[0], axis=0)

        predictions[idx, :, :, :] = patches_to_array_single(prediction, (arr.shape[0], arr.shape[1], test_shape[-1]), tile_size, offset)
        predictions_weights[idx, :, :, :] = patches_to_array_single(weights, (arr.shape[0], arr.shape[1], 1), tile_size, offset, 0.0)

    # Merge the predictions
    if merge_method == &#34;mad&#34;:
        predictions = merge_weighted_mad(predictions, predictions_weights)
    elif merge_method == &#34;median&#34;:
        predictions = merge_weighted_median(predictions, predictions_weights)
    elif merge_method in [&#34;mean&#34;, &#34;average&#34;, &#34;avg&#34;]:
        predictions = merge_weighted_average(predictions, predictions_weights)
    elif merge_method == &#34;mode&#34;:
        predictions = merge_weighted_mode(predictions, predictions_weights)
    elif merge_method == &#34;max&#34;:
        predictions = merge_weighted_minmax(predictions, predictions_weights, &#34;max&#34;)
    elif merge_method == &#34;min&#34;:
        predictions = merge_weighted_minmax(predictions, predictions_weights, &#34;min&#34;)
    elif merge_method == &#34;olympic1&#34;:
        predictions = merge_weighted_olympic(predictions, predictions_weights, 1)
    elif merge_method == &#34;olympic2&#34;:
        predictions = merge_weighted_olympic(predictions, predictions_weights, 2)

    return predictions


def predict_array_pixel(
    arr: np.ndarray,
    callback: Callable[[np.ndarray], np.ndarray],
) -&gt; np.ndarray:
    &#34;&#34;&#34; 
    Predicts an array pixel by pixel.

    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        callback (function): The callback function to be used for prediction. The callback function
            must take a numpy array as input and return a numpy array as output.
    &#34;&#34;&#34;
    assert len(arr.shape) == 3, &#34;Array must be 3D&#34;

    reshaped = arr.reshape((arr.shape[0] * arr.shape[1], arr.shape[2]))
    predicted = callback(reshaped)
    predicted = predicted.reshape((arr.shape[0], arr.shape[1], predicted.shape[-1]))

    return predicted</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="buteo.raster.patches.array_to_patches"><code class="name flex">
<span>def <span class="ident">array_to_patches</span></span>(<span>arr: numpy.ndarray, tile_size: int, offsets_y: int = 3, offsets_x: int = 3, border_check: bool = True) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate patches from an array based on the specified parameters.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array to be divided into patches.</dd>
<dt><strong><code>tile_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of each tile/patch, e.g., 64 for 64x64 tiles.</dd>
<dt><strong><code>offsets_y</code></strong> :&ensp;<code>int=3</code></dt>
<dd>The desired number of offsets to be calculated in the y dimension.</dd>
<dt><strong><code>offsets_x</code></strong> :&ensp;<code>int=3</code></dt>
<dd>The desired number of offsets to be calculated in the x dimension.</dd>
<dt><strong><code>border_check</code></strong> :&ensp;<code>bool=True</code></dt>
<dd>Whether or not to include border patches.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The concatenate patches along axis 0. In the order (patches, y, x, channels)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array_to_patches(
    arr: np.ndarray,
    tile_size: int,
    offsets_y: int = 3,
    offsets_x: int = 3,
    border_check: bool = True,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate patches from an array based on the specified parameters.

    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        tile_size (int): The size of each tile/patch, e.g., 64 for 64x64 tiles.
        offsets_y (int=3): The desired number of offsets to be calculated in the y dimension.
        offsets_x (int=3): The desired number of offsets to be calculated in the x dimension.
        border_check (bool=True): Whether or not to include border patches.

    Returns:
        np.ndarray: The concatenate patches along axis 0. In the order (patches, y, x, channels)
    &#34;&#34;&#34;
    # Get the list of offsets for both x and y dimensions
    offsets = get_offsets(tile_size, offsets_y, offsets_x)

    if border_check:
        borders_y, borders_x = borders_are_necessary_list(arr, tile_size, offsets)

        if borders_y:
            offsets.append([arr.shape[0] - tile_size, 0])
        if borders_x:
            offsets.append([0, arr.shape[1] - tile_size])

    # Initialize an empty list to store the generated patches
    patches = []

    # Iterate through the offsets and generate patches for each offset
    for offset in offsets:
        patches.append(
            array_to_patches_single(arr, tile_size, offset),
        )

    patches = np.concatenate(patches, axis=0)

    return patches</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.array_to_patches_single"><code class="name flex">
<span>def <span class="ident">array_to_patches_single</span></span>(<span>arr: numpy.ndarray, tile_size: int, offset: Union[List[int], Tuple[int, int], NoneType] = None) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate patches from an array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array to be divided into patches.</dd>
<dt><strong><code>tile_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of each tile/patch, e.g., 64 for 64x64 tiles.</dd>
</dl>
<p>offset (list/tuple/None=None): The x and y offset values for the input
array. If not provided, defaults to [0, 0].</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>nd.array</code></dt>
<dd>A numpy array containing the patches.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def array_to_patches_single(
    arr: np.ndarray,
    tile_size: int,
    offset: Optional[Union[List[int], Tuple[int, int]]] = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate patches from an array.

    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        tile_size (int): The size of each tile/patch, e.g., 64 for 64x64 tiles.
        offset (list/tuple/None=None): The x and y offset values for the input
            array. If not provided, defaults to [0, 0].

    Returns:
        nd.array: A numpy array containing the patches.
    &#34;&#34;&#34;
    assert arr.ndim in [2, 3], &#34;Array must be 2D or 3D&#34;
    assert tile_size &gt; 0, &#34;Tile size must be greater than 0&#34;
    assert offset is None or len(offset) == 2, &#34;Offset must be a list or tuple of length 2&#34;

    # Set default offset to [0, 0] if not provided
    if offset is None:
        offset = [0, 0]

    # Calculate the number of patches in the y and x dimensions
    patches_y = (arr.shape[0] - offset[0]) // tile_size
    patches_x = (arr.shape[1] - offset[1]) // tile_size

    # Calculate cut dimensions for the y and x dimensions
    cut_y = -((arr.shape[0] - offset[0]) % tile_size)
    cut_x = -((arr.shape[1] - offset[1]) % tile_size)

    # Set cut dimensions to None if they are 0
    cut_y = None if cut_y == 0 else cut_y
    cut_x = None if cut_x == 0 else cut_x

    # Reshape the array to separate the patches
    reshaped = arr[offset[0]:cut_y, offset[1]:cut_x].reshape(
        patches_y,
        tile_size,
        patches_x,
        tile_size,
        arr.shape[2],
    )

    # Swap axes to rearrange patches in the correct order
    swaped = reshaped.swapaxes(1, 2)

    # Combine the patches into a single array
    blocks = swaped.reshape(-1, tile_size, tile_size, arr.shape[2])

    return blocks</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.borders_are_necessary"><code class="name flex">
<span>def <span class="ident">borders_are_necessary</span></span>(<span>arr: numpy.ndarray, tile_size: int, offset: List[int]) -> Tuple[bool, bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if borders are necessary for the given array.
Width and height are returned as a tuple.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The array to be checked.</dd>
<dt><strong><code>tile_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of each tile.</dd>
<dt><strong><code>offset</code></strong> :&ensp;<code>list</code></dt>
<dd>The offset to be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing of borders are needed in (height, width) dims.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def borders_are_necessary(
    arr: np.ndarray,
    tile_size: int,
    offset: List[int],
) -&gt; Tuple[bool, bool]:
    &#34;&#34;&#34;
    Checks if borders are necessary for the given array.
    Width and height are returned as a tuple.

    Args:
        arr (np.ndarray): The array to be checked.
        tile_size (int): The size of each tile.
        offset (list): The offset to be used.

    Returns:
        tuple: A tuple containing of borders are needed in (height, width) dims.
    &#34;&#34;&#34;
    if arr.ndim == 2:
        height, width = arr.shape
    else:
        height, width, _ = arr.shape

    if (height - offset[0]) % tile_size == 0:
        height_border = False
    else:
        height_border = True

    if (width - offset[1]) % tile_size == 0:
        width_border = False
    else:
        width_border = True

    return height_border, width_border</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.borders_are_necessary_list"><code class="name flex">
<span>def <span class="ident">borders_are_necessary_list</span></span>(<span>arr: numpy.ndarray, tile_size: int, offsets: List[List[int]]) -> Tuple[bool, bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if borders are necessary for the given array.
Width and height are returned as a tuple.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The array to be checked.</dd>
<dt><strong><code>tile_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of each tile.</dd>
<dt><strong><code>offsets</code></strong> :&ensp;<code>list</code></dt>
<dd>The offset to be used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing of borders are needed in (height, width) dims.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def borders_are_necessary_list(
    arr: np.ndarray,
    tile_size: int,
    offsets: List[List[int]],
) -&gt; Tuple[bool, bool]:
    &#34;&#34;&#34;
    Checks if borders are necessary for the given array.
    Width and height are returned as a tuple.

    Args:
        arr (np.ndarray): The array to be checked.
        tile_size (int): The size of each tile.
        offsets (list): The offset to be used.

    Returns:
        tuple: A tuple containing of borders are needed in (height, width) dims.
    &#34;&#34;&#34;
    height_border = True
    width_border = True

    for offset in offsets:
        offset_height_border, offset_width_border = borders_are_necessary(
            arr, tile_size, offset
        )
        if not offset_height_border:
            height_border = False

        if not offset_width_border:
            width_border = False

        if not height_border and not width_border:
            break

    return height_border, width_border</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.calculate_offset_single"><code class="name flex">
<span>def <span class="ident">calculate_offset_single</span></span>(<span>tile_size: int, num_offsets: int) -> List[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate a list of offset values for a given tile size and number of offsets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tile_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of each tile.</dd>
<dt><strong><code>num_offsets</code></strong> :&ensp;<code>int</code></dt>
<dd>The desired number of offsets to be calculated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[int]</code></dt>
<dd>A list of calculated offset values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_offset_single(
    tile_size: int,
    num_offsets: int,
) -&gt; List[int]:
    &#34;&#34;&#34;
    Calculate a list of offset values for a given tile size and number of offsets.

    Args:
        tile_size (int): The size of each tile.
        num_offsets (int): The desired number of offsets to be calculated.

    Returns:
        List[int]: A list of calculated offset values.
    &#34;&#34;&#34;
    assert num_offsets &gt;= 0, &#34;Number of offsets must be greater than or equal to 0.&#34;
    assert tile_size &gt; 0, &#34;Tile size must be greater than 0.&#34;

    # Initialize the list of offsets with the first value, 0
    offsets = [0]
    previous = None
    for _ in range(num_offsets):

        # Calculate the step size based on previous step
        if previous is None:
            step = tile_size // 2
            previous = step
        else:
            step = previous // 2
            previous = step

        # Break the loop if the step size is 0
        if step == 0:
            break

        # Calculate and add offset values based on the step size
        for j in range(1, num_offsets + 1):
            val = j * step
            if (
                val not in offsets
                and val &lt; tile_size
                and val &gt; 0
                and len(offsets) &lt; num_offsets + 1
            ):
                offsets.append(j * step)

    return offsets</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.get_kernel_weights"><code class="name flex">
<span>def <span class="ident">get_kernel_weights</span></span>(<span>tile_size: int = 64, edge_distance: int = 5, epsilon: float = 1e-07) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Weight a kernel according to how close to an edge a given pixel is.</p>
<p>Keyword Args:
tile_size (int=64): The size of the square kernel.
edge_distance (int=5): The distance from the edge to consider for weighting.
epsilon (float=1e-7): A small value to prevent division by zero.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 2D NumPy array of shape (tile_size, tile_size) with the kernel weights.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_kernel_weights(
    tile_size: int = 64,
    edge_distance: int = 5,
    epsilon: float = 1e-7,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Weight a kernel according to how close to an edge a given pixel is.

    Keyword Args:
        tile_size (int=64): The size of the square kernel.
        edge_distance (int=5): The distance from the edge to consider for weighting.
        epsilon (float=1e-7): A small value to prevent division by zero.

    Returns:
        np.ndarray: A 2D NumPy array of shape (tile_size, tile_size) with the kernel weights.
    &#34;&#34;&#34;
    assert tile_size &gt; 0, &#34;Tile size must be greater than zero.&#34;
    assert edge_distance &lt; tile_size // 2, &#34;Edge distance must be less than half the tile size.&#34;
    assert edge_distance &gt;= 0, &#34;Edge distance must be greater than or equal to zero.&#34;

    arr = np.zeros((tile_size, tile_size), dtype=&#34;float32&#34;)
    max_dist = edge_distance * 2

    # Iterate through the kernel array
    for idx_y in range(0, arr.shape[0]):
        for idx_x in range(0, arr.shape[1]):

            # Calculate vertical distance to the closest edge
            val_y_top = max(edge_distance - idx_y, 0.0)
            val_y_bot = max((1 + edge_distance) - (tile_size - idx_y), 0.0)
            val_y = val_y_top + val_y_bot

            # Calculate horizontal distance to the closest edge
            val_x_lef = max(edge_distance - idx_x, 0.0)
            val_x_rig = max((1 + edge_distance) - (tile_size - idx_x), 0.0)
            val_x = val_x_lef + val_x_rig

            # Calculate the weight based on the distance to the closest edge
            val = (max_dist - abs(val_y + val_x)) / max_dist

            # Set a minimum weight to avoid division by zero
            if val &lt;= 0.0:
                val = epsilon

            # Assign the calculated weight to the kernel array
            arr[idx_y, idx_x] = val

    return arr</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.get_offsets"><code class="name flex">
<span>def <span class="ident">get_offsets</span></span>(<span>tile_size: int, offsets_y: int, offsets_x: int) -> List[Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a list of offset pairs for a given tile size and number of offsets in x and y dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>tile_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of each tile.</dd>
<dt><strong><code>offsets_y</code></strong> :&ensp;<code>int</code></dt>
<dd>The desired number of offsets to be calculated in the y dimension.</dd>
<dt><strong><code>offsets_x</code></strong> :&ensp;<code>int</code></dt>
<dd>The desired number of offsets to be calculated in the x dimension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Tuple[int, int]]</code></dt>
<dd>A list of tuples containing offset pairs for y and x dimensions.</dd>
<dt><code>order is (y, x)</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_offsets(
    tile_size: int,
    offsets_y: int,
    offsets_x: int,
) -&gt; List[Tuple[int, int]]:
    &#34;&#34;&#34;
    Generate a list of offset pairs for a given tile size and number of offsets in x and y dimensions.

    Args:
        tile_size (int): The size of each tile.
        offsets_y (int): The desired number of offsets to be calculated in the y dimension.
        offsets_x (int): The desired number of offsets to be calculated in the x dimension.

    Returns:
        List[Tuple[int, int]]: A list of tuples containing offset pairs for y and x dimensions.
        order is (y, x)
    &#34;&#34;&#34;
    assert offsets_y &gt;= 0, &#34;Number of offsets in y dimension must be &gt;= 0&#34;
    assert offsets_x &gt;= 0, &#34;Number of offsets in x dimension must be &gt;= 0&#34;
    assert tile_size &gt; 0, &#34;Tile size must be &gt; 0&#34;

    offsets_y = calculate_offset_single(tile_size, offsets_y)
    offsets_x = calculate_offset_single(tile_size, offsets_x)

    offsets = []
    for y in offsets_y:
        for x in offsets_x:
            offsets.append((y, x))

    return offsets</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.merge_weighted_average"><code class="name flex">
<span>def <span class="ident">merge_weighted_average</span></span>(<span>arr: numpy.ndarray, arr_weight: numpy.ndarray) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the weighted average of a multi-dimensional array along the last axis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input array.</dd>
<dt><strong><code>arr_weight</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The weight array with the same shape as the input array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted averages.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_average(
    arr: np.ndarray,
    arr_weight: np.ndarray,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted average of a multi-dimensional array along the last axis.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted averages.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Calculate the weighted sum and total weight
                weighted_sum = np.nansum(values * weights)
                total_weight = np.nansum(weights)

                # Calculate the weighted average and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = weighted_sum / total_weight

    return ret_arr</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.merge_weighted_mad"><code class="name flex">
<span>def <span class="ident">merge_weighted_mad</span></span>(<span>arr: numpy.ndarray, arr_weight: numpy.ndarray, mad_dist: float = 2.0) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Merge an array of predictions using the MAD-merge methodology.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input array.</dd>
<dt><strong><code>arr_weight</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The weight array with the same shape as the input array.</dd>
</dl>
<p>Keyword Args:
mad_dist (float=2.0): The MAD distance.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the MAD-merged values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_mad(
    arr: np.ndarray,
    arr_weight: np.ndarray,
    mad_dist: float = 2.0,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Merge an array of predictions using the MAD-merge methodology.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    Keyword Args:
        mad_dist (float=2.0): The MAD distance.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the MAD-merged values.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Sort the values and weights based on the values
                sort_mask = np.argsort(values)
                sorted_data = values[sort_mask]
                sorted_weights = weights[sort_mask]

                # Calculate the cumulative sum of the sorted weights and normalize to the range [0, 1]
                cumsum = np.cumsum(sorted_weights)
                intersect = (cumsum - 0.5 * sorted_weights) / cumsum[-1]

                # Interpolate the median
                median = np.interp(0.5, intersect, sorted_data)

                # Calculate the median absolute deviation (MAD)
                mad = np.median(np.abs(median - values))

                # If MAD is zero, store the median in the result array and continue
                if mad == 0.0:
                    ret_arr[idx_y, idx_x, 0] = median
                    continue

                # Calculate the new weights based on the MAD
                new_weights = np.zeros_like(sorted_weights)
                for idx_z in range(sorted_data.shape[0]):
                    new_weights[idx_z] = 1.0 - (np.minimum(np.abs(sorted_data[idx_z] - median) / (mad * mad_dist), 1))

                if np.sum(new_weights) == 0.0:
                    ret_arr[idx_y, idx_x, 0] = median
                    continue

                # Calculate the cumulative sum of the new weights and normalize to the range [0, 1]
                cumsum = np.cumsum(new_weights)
                intersect = (cumsum - 0.5 * new_weights) / cumsum[-1]

                # Interpolate the MAD-merged value and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = np.interp(0.5, intersect, sorted_data)

    return ret_arr</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.merge_weighted_median"><code class="name flex">
<span>def <span class="ident">merge_weighted_median</span></span>(<span>arr: numpy.ndarray, arr_weight: numpy.ndarray) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the weighted median of a multi-dimensional array along the first axis.
This is the order (number_of_overlaps, tile_size, tile_size, number_of_bands)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input array.</dd>
<dt><strong><code>arr_weight</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The weight array with the same shape as the input array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 3D NumPy array of shape (arr.shape[1], arr.shape[2], arr.shape[3]) with the weighted medians.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_median(
    arr: np.ndarray,
    arr_weight: np.ndarray,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted median of a multi-dimensional array along the first axis.
    This is the order (number_of_overlaps, tile_size, tile_size, number_of_bands)
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[1], arr.shape[2], arr.shape[3]) with the weighted medians.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Sort the values and weights based on the values
                sort_mask = np.argsort(values)
                sorted_data = values[sort_mask]
                sorted_weights = weights[sort_mask]

                # Calculate the cumulative sum of the sorted weights
                cumsum = np.cumsum(sorted_weights)

                # Normalize the cumulative sum to the range [0, 1]
                intersect = (cumsum - 0.5 * sorted_weights) / cumsum[-1]

                # Interpolate the weighted median and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = np.interp(0.5, intersect, sorted_data)

    return ret_arr</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.merge_weighted_minmax"><code class="name flex">
<span>def <span class="ident">merge_weighted_minmax</span></span>(<span>arr: numpy.ndarray, arr_weight: numpy.ndarray, method='max') -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the weighted min or max of a multi-dimensional array along the last axis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input array.</dd>
<dt><strong><code>arr_weight</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The weight array with the same shape as the input array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted min or max.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_minmax(
    arr: np.ndarray,
    arr_weight: np.ndarray,
    method=&#34;max&#34;,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted min or max of a multi-dimensional array along the last axis.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted min or max.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    minmax = 0
    if method == &#34;min&#34;:
        minmax = 1

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                weighted = values * weights

                if minmax == 0: # max
                    index = np.nanargmax(weighted)
                else:
                    index = np.nanargmin(weighted)

                value = values[index]

                # Calculate the weighted average and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = value

    return ret_arr</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.merge_weighted_mode"><code class="name flex">
<span>def <span class="ident">merge_weighted_mode</span></span>(<span>arr: numpy.ndarray, arr_weight: numpy.ndarray) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the weighted mode of a multi-dimensional array along the last axis.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input array.</dd>
<dt><strong><code>arr_weight</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The weight array with the same shape as the input array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted modes.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_mode(
    arr: np.ndarray,
    arr_weight: np.ndarray,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the weighted mode of a multi-dimensional array along the last axis.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted modes.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=arr.dtype)
    ret_arr[:] = np.nan

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                # Get unique values and their weighted counts
                unique_vals = unique_values(values)
                weighted_counts = np.zeros(unique_vals.shape[0])

                # Calculate the weighted sum for each unique value
                for i in range(unique_vals.shape[0]):
                    idxs = np.where(values == unique_vals[i])
                    weighted_counts[i] = np.sum(weights[idxs])

                # Get the index of the maximum weighted sum
                mode_idx = np.argmax(weighted_counts)

                # Store the weighted mode in the result array
                ret_arr[idx_y, idx_x, idx_band] = unique_vals[mode_idx]

    return ret_arr</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.merge_weighted_olympic"><code class="name flex">
<span>def <span class="ident">merge_weighted_olympic</span></span>(<span>arr: numpy.ndarray, arr_weight: numpy.ndarray, level: int = 1) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the olympic value of a multi-dimensional array along the last axis.
Using olympic sort, the highest and lowest values are removed from the calculation.
If level is 1, then the highest and loweest values are removed. If the level is 2,
then the 2 highest and lowest values are removed, and so on.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input array.</dd>
<dt><strong><code>arr_weight</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The weight array with the same shape as the input array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the olympic value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True)
def merge_weighted_olympic(
    arr: np.ndarray,
    arr_weight: np.ndarray,
    level: int = 1,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Calculate the olympic value of a multi-dimensional array along the last axis.
    Using olympic sort, the highest and lowest values are removed from the calculation.
    If level is 1, then the highest and loweest values are removed. If the level is 2,
    then the 2 highest and lowest values are removed, and so on.
    
    Args:
        arr (np.ndarray): The input array.
        arr_weight (np.ndarray): The weight array with the same shape as the input array.
    
    Returns:
        np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the olympic value.
    &#34;&#34;&#34;
    ret_arr = np.empty((arr.shape[1], arr.shape[2], arr.shape[3]), dtype=&#34;float32&#34;)
    ret_arr[:] = np.nan

    required = int((level * 2) + 1)

    # Iterate through the input array
    for idx_y in prange(arr.shape[1]):
        for idx_x in range(arr.shape[2]):
            for idx_band in range(arr.shape[3]):

                # Flatten the input and weight arrays
                values = arr[:, idx_y, idx_x, idx_band].flatten()
                weights = arr_weight[:, idx_y, idx_x, 0].flatten()

                nan_mask = np.where(~np.isnan(values))[0]

                if len(nan_mask) == 0:
                    continue

                values = values[nan_mask]
                weights = weights[nan_mask]

                if len(values) &lt; required: # Take the average of all
                    value = np.mean(values)
                elif len(values) == required: # Take the middle value
                    value = np.sort(values)[level]
                else:
                    sort_olympic = np.argsort(values)[level:-level]
                    sort_weights = weights[sort_olympic] / np.sum(weights[sort_olympic])
                    sort_values = values[sort_olympic]

                    value = np.sum(sort_values * sort_weights)

                # Calculate the weighted average and store it in the result array
                ret_arr[idx_y, idx_x, idx_band] = value

    return ret_arr</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.patches_to_array_single"><code class="name flex">
<span>def <span class="ident">patches_to_array_single</span></span>(<span>patches: numpy.ndarray, shape: Union[List, Tuple], tile_size: int, offset: Union[List, Tuple, NoneType] = None, background_value: Union[int, float, NoneType] = None) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Reconstitute an array from patches.</p>
<p>Given an array of patches, this function stitches them back together
to form the original array of the specified shape.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>patches</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array containing the patches to be
stitched together.</dd>
<dt>shape (list/tuple): The desired shape of the output array.</dt>
<dt><strong><code>tile_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of each tile/patch Eg. 64 for 64x64 tiles.</dd>
</dl>
<p>Keyword Args:
offset (list/tuple/None=None): The x and y offset values for the
target array. If not provided, defaults to [0, 0].</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A numpy array with the original shape, formed by stitching
together the provided patches.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patches_to_array_single(
    patches: np.ndarray,
    shape: Union[List, Tuple],
    tile_size: int,
    offset: Optional[Union[List, Tuple]] = None,
    background_value: Optional[Union[int, float]] = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Reconstitute an array from patches.

    Given an array of patches, this function stitches them back together
    to form the original array of the specified shape.

    Args:
        patches (np.ndarray): A numpy array containing the patches to be
            stitched together.
        shape (list/tuple): The desired shape of the output array.
        tile_size (int): The size of each tile/patch Eg. 64 for 64x64 tiles.

    Keyword Args:
        offset (list/tuple/None=None): The x and y offset values for the
            target array. If not provided, defaults to [0, 0].

    Returns:
        np.ndarray: A numpy array with the original shape, formed by stitching
            together the provided patches.
    &#34;&#34;&#34;
    assert len(shape) in [2, 3], &#34;Shape must be a tuple or list of length 2 or 3&#34;
    assert len(patches.shape) == 4, &#34;Patches must be a 4D array&#34;
    assert patches.shape[1] == tile_size, &#34;Patches must be of size tile_size&#34;
    assert patches.shape[2] == tile_size, &#34;Patches must be of size tile_size&#34;
    assert offset is None or len(offset) == 2, &#34;Offset must be a tuple or list of length 2&#34;

    # Set default offset to [0, 0] if not provided
    if offset is None:
        offset = [0, 0]

    # Create an empty target array of the specified shape
    if background_value is None:
        target = np.full(shape, np.nan, dtype=patches.dtype)
    else:
        target = np.full(shape, background_value, dtype=patches.dtype)

    # Calculate target dimensions
    target_y = ((shape[0] - offset[0]) // tile_size) * tile_size
    target_x = ((shape[1] - offset[1]) // tile_size) * tile_size

    # Calculate cut dimensions
    cut_y = -((shape[0] - offset[0]) % tile_size)
    cut_x = -((shape[1] - offset[1]) % tile_size)

    # Set cut dimensions to None if they are 0
    cut_y = None if cut_y == 0 else cut_y
    cut_x = None if cut_x == 0 else cut_x

    # Calculate the number of tiles in the y and x dimensions
    num_tiles_y = target_y // tile_size
    num_tiles_x = target_x // tile_size

    # Reshape the patches for stitching
    reshape = patches.reshape(
        num_tiles_y,
        num_tiles_x,
        tile_size,
        tile_size,
        patches.shape[3],
        1,
    )

    # Swap axes to rearrange patches in the correct order for stitching
    swap = reshape.swapaxes(1, 2)

    # Combine the patches into a single array
    destination = swap.reshape(
        num_tiles_y * tile_size,
        num_tiles_x * tile_size,
        patches.shape[3],
    )

    # Assign the combined patches to the target array
    target[offset[0]:cut_y, offset[1]:cut_x] = destination

    return target</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.patches_to_weights"><code class="name flex">
<span>def <span class="ident">patches_to_weights</span></span>(<span>patches: numpy.ndarray, edge_distance: int) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the weights for each patch based on the distance to the edge.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def patches_to_weights(
    patches: np.ndarray,
    edge_distance: int,
) -&gt; np.ndarray:
    &#34;&#34;&#34; Calculate the weights for each patch based on the distance to the edge. &#34;&#34;&#34;
    assert len(patches.shape) == 4, &#34;Patches must be a 4D array&#34;
    assert patches.shape[1] == patches.shape[2], &#34;Patches must be square&#34;

    # Calculate the distance to the edge for each patch
    weights = get_kernel_weights(patches.shape[1], edge_distance)

    # Expand the weights to match the number of patches
    weights = np.repeat(weights[np.newaxis, ...], patches.shape[0], axis=0)[..., np.newaxis]

    return weights</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.predict_array"><code class="name flex">
<span>def <span class="ident">predict_array</span></span>(<span>arr: numpy.ndarray, callback: Callable[[numpy.ndarray], numpy.ndarray], tile_size=64, offsets_y=1, offsets_x=1, border_check=True, merge_method='median', edge_weighted=True, edge_distance=3) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Generate patches from an array. Also outputs the offsets and the shapes of the offsets. Only
suppors the prediction of single values in the rasters/arrays. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array to be divided into patches.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>function</code></dt>
<dd>The callback function to be used for prediction. The callback function
must take a numpy array as input and return a numpy array as output.</dd>
</dl>
<p>Keyword Args:
tile_size (int=64): The size of each tile/patch, e.g., 64 for 64x64 tiles.
offsets_y (int=1): The desired number of offsets to be calculated in the y dimension.
offsets_x (int=1): The desired number of offsets to be calculated in the x dimension.
border_check (bool=True): Whether or not to include border patches.
merge_method (str="median"): The method to use for merging the patches. Valid methods
are ['mad', 'median', 'mean', 'mode', "min", "max", "olympic1", "olympic2"]
edge_weighted (bool=True): Whether or not to weight the edges patches of patches less
than the central parts.
edge_distance (int=3): The distance from the edge to be weighted less. Usually good to
adjust this to your maximum convolution kernel size.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>The predicted array.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_array(
    arr: np.ndarray,
    callback: Callable[[np.ndarray], np.ndarray],
    tile_size=64,
    offsets_y=1,
    offsets_x=1,
    border_check=True,
    merge_method=&#34;median&#34;,
    edge_weighted=True,
    edge_distance=3,
) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Generate patches from an array. Also outputs the offsets and the shapes of the offsets. Only
    suppors the prediction of single values in the rasters/arrays. 
    
    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        callback (function): The callback function to be used for prediction. The callback function
            must take a numpy array as input and return a numpy array as output.
    
    Keyword Args:
        tile_size (int=64): The size of each tile/patch, e.g., 64 for 64x64 tiles.
        offsets_y (int=1): The desired number of offsets to be calculated in the y dimension.
        offsets_x (int=1): The desired number of offsets to be calculated in the x dimension.
        border_check (bool=True): Whether or not to include border patches.
        merge_method (str=&#34;median&#34;): The method to use for merging the patches. Valid methods
        are [&#39;mad&#39;, &#39;median&#39;, &#39;mean&#39;, &#39;mode&#39;, &#34;min&#34;, &#34;max&#34;, &#34;olympic1&#34;, &#34;olympic2&#34;]
        edge_weighted (bool=True): Whether or not to weight the edges patches of patches less
            than the central parts.
        edge_distance (int=3): The distance from the edge to be weighted less. Usually good to
            adjust this to your maximum convolution kernel size.

    Returns:
        np.ndarray: The predicted array.
    &#34;&#34;&#34;
    assert merge_method in [&#34;mad&#34;, &#34;median&#34;, &#34;mean&#34;, &#34;mode&#34;], &#34;Invalid merge method&#34;
    assert len(arr.shape) == 3, &#34;Array must be 3D&#34;
    assert tile_size &lt; arr.shape[0], &#34;Tile size must be smaller than the array size&#34;
    assert tile_size &lt; arr.shape[1], &#34;Tile size must be smaller than the array size&#34;

    # Get the list of offsets for both x and y dimensions
    offsets = get_offsets(tile_size, offsets_y, offsets_x)

    if border_check:
        borders_y, borders_x = borders_are_necessary_list(arr, tile_size, offsets)

        if borders_y:
            offsets.append([arr.shape[0] - tile_size, 0])
        if borders_x:
            offsets.append([0, arr.shape[1] - tile_size])

    # Test output dimensions of prediction
    test_patch = arr[np.newaxis, :tile_size, :tile_size, :]
    test_prediction = callback(test_patch)
    test_shape = test_prediction.shape

    # Initialize an empty list to store the generated patches
    predictions = np.zeros((len(offsets), arr.shape[0], arr.shape[1], test_shape[-1]), dtype=arr.dtype)
    predictions_weights = np.zeros((len(offsets), arr.shape[0], arr.shape[1], 1), dtype=np.float32)

    # Iterate through the offsets and generate patches for each offset
    for idx, offset in enumerate(offsets):
        patches = array_to_patches_single(arr, tile_size, offset)

        prediction = callback(patches)

        if edge_weighted:
            weights = patches_to_weights(patches, edge_distance)
        else:
            weights = np.ones((tile_size, tile_size, 1), dtype=np.float32)
            weights = np.repeat(weights[np.newaxis, ...], patches.shape[0], axis=0)

        predictions[idx, :, :, :] = patches_to_array_single(prediction, (arr.shape[0], arr.shape[1], test_shape[-1]), tile_size, offset)
        predictions_weights[idx, :, :, :] = patches_to_array_single(weights, (arr.shape[0], arr.shape[1], 1), tile_size, offset, 0.0)

    # Merge the predictions
    if merge_method == &#34;mad&#34;:
        predictions = merge_weighted_mad(predictions, predictions_weights)
    elif merge_method == &#34;median&#34;:
        predictions = merge_weighted_median(predictions, predictions_weights)
    elif merge_method in [&#34;mean&#34;, &#34;average&#34;, &#34;avg&#34;]:
        predictions = merge_weighted_average(predictions, predictions_weights)
    elif merge_method == &#34;mode&#34;:
        predictions = merge_weighted_mode(predictions, predictions_weights)
    elif merge_method == &#34;max&#34;:
        predictions = merge_weighted_minmax(predictions, predictions_weights, &#34;max&#34;)
    elif merge_method == &#34;min&#34;:
        predictions = merge_weighted_minmax(predictions, predictions_weights, &#34;min&#34;)
    elif merge_method == &#34;olympic1&#34;:
        predictions = merge_weighted_olympic(predictions, predictions_weights, 1)
    elif merge_method == &#34;olympic2&#34;:
        predictions = merge_weighted_olympic(predictions, predictions_weights, 2)

    return predictions</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.predict_array_pixel"><code class="name flex">
<span>def <span class="ident">predict_array_pixel</span></span>(<span>arr: numpy.ndarray, callback: Callable[[numpy.ndarray], numpy.ndarray]) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Predicts an array pixel by pixel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>A numpy array to be divided into patches.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>function</code></dt>
<dd>The callback function to be used for prediction. The callback function
must take a numpy array as input and return a numpy array as output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_array_pixel(
    arr: np.ndarray,
    callback: Callable[[np.ndarray], np.ndarray],
) -&gt; np.ndarray:
    &#34;&#34;&#34; 
    Predicts an array pixel by pixel.

    Args:
        arr (np.ndarray): A numpy array to be divided into patches.
        callback (function): The callback function to be used for prediction. The callback function
            must take a numpy array as input and return a numpy array as output.
    &#34;&#34;&#34;
    assert len(arr.shape) == 3, &#34;Array must be 3D&#34;

    reshaped = arr.reshape((arr.shape[0] * arr.shape[1], arr.shape[2]))
    predicted = callback(reshaped)
    predicted = predicted.reshape((arr.shape[0], arr.shape[1], predicted.shape[-1]))

    return predicted</code></pre>
</details>
</dd>
<dt id="buteo.raster.patches.unique_values"><code class="name flex">
<span>def <span class="ident">unique_values</span></span>(<span>arr: numpy.ndarray) -> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Find the unique values in a 1D NumPy array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arr</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>The input array.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>A 1D NumPy array with the unique values.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, nogil=True)
def unique_values(arr: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Find the unique values in a 1D NumPy array.
    
    Args:
        arr (np.ndarray): The input array.
    
    Returns:
        np.ndarray: A 1D NumPy array with the unique values.
    &#34;&#34;&#34;
    unique = np.empty(arr.size, dtype=arr.dtype)
    unique_count = 0
    for i in range(arr.shape[0]):
        if arr[i] not in unique[:unique_count]:
            unique[unique_count] = arr[i]
            unique_count += 1

    return unique[:unique_count]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buteo.raster" href="index.html">buteo.raster</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="buteo.raster.patches.array_to_patches" href="#buteo.raster.patches.array_to_patches">array_to_patches</a></code></li>
<li><code><a title="buteo.raster.patches.array_to_patches_single" href="#buteo.raster.patches.array_to_patches_single">array_to_patches_single</a></code></li>
<li><code><a title="buteo.raster.patches.borders_are_necessary" href="#buteo.raster.patches.borders_are_necessary">borders_are_necessary</a></code></li>
<li><code><a title="buteo.raster.patches.borders_are_necessary_list" href="#buteo.raster.patches.borders_are_necessary_list">borders_are_necessary_list</a></code></li>
<li><code><a title="buteo.raster.patches.calculate_offset_single" href="#buteo.raster.patches.calculate_offset_single">calculate_offset_single</a></code></li>
<li><code><a title="buteo.raster.patches.get_kernel_weights" href="#buteo.raster.patches.get_kernel_weights">get_kernel_weights</a></code></li>
<li><code><a title="buteo.raster.patches.get_offsets" href="#buteo.raster.patches.get_offsets">get_offsets</a></code></li>
<li><code><a title="buteo.raster.patches.merge_weighted_average" href="#buteo.raster.patches.merge_weighted_average">merge_weighted_average</a></code></li>
<li><code><a title="buteo.raster.patches.merge_weighted_mad" href="#buteo.raster.patches.merge_weighted_mad">merge_weighted_mad</a></code></li>
<li><code><a title="buteo.raster.patches.merge_weighted_median" href="#buteo.raster.patches.merge_weighted_median">merge_weighted_median</a></code></li>
<li><code><a title="buteo.raster.patches.merge_weighted_minmax" href="#buteo.raster.patches.merge_weighted_minmax">merge_weighted_minmax</a></code></li>
<li><code><a title="buteo.raster.patches.merge_weighted_mode" href="#buteo.raster.patches.merge_weighted_mode">merge_weighted_mode</a></code></li>
<li><code><a title="buteo.raster.patches.merge_weighted_olympic" href="#buteo.raster.patches.merge_weighted_olympic">merge_weighted_olympic</a></code></li>
<li><code><a title="buteo.raster.patches.patches_to_array_single" href="#buteo.raster.patches.patches_to_array_single">patches_to_array_single</a></code></li>
<li><code><a title="buteo.raster.patches.patches_to_weights" href="#buteo.raster.patches.patches_to_weights">patches_to_weights</a></code></li>
<li><code><a title="buteo.raster.patches.predict_array" href="#buteo.raster.patches.predict_array">predict_array</a></code></li>
<li><code><a title="buteo.raster.patches.predict_array_pixel" href="#buteo.raster.patches.predict_array_pixel">predict_array_pixel</a></code></li>
<li><code><a title="buteo.raster.patches.unique_values" href="#buteo.raster.patches.unique_values">unique_values</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>