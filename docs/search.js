window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "buteo", "modulename": "buteo", "kind": "module", "doc": "<h1 id=\"geospatial-analysis-meets-ai\">Geospatial Analysis Meets AI</h1>\n\n<p>Buteo is a toolbox designed to simplify the process of working with geospatial data in machine learning. It includes tools for reading, writing, and processing geospatial data, as well as tools for creating labels from vector data and generating patches from geospatial data. Buteo makes it easy to ingest data, create training data, and perform inference on geospatial data.</p>\n\n<p>Please note that Buteo is under active development, and its API may not be entirely stable.\nWhen using, please pin the version of Buteo you are using to avoid breaking changes.\nFeel free to report any bugs or suggest improvements.</p>\n\n<p><strong>Dependencies</strong> </br>\n<code>numba</code> (<a href=\"https://numba.pydata.org/\">https://numba.pydata.org/</a>) </br>\n<code>gdal</code> (<a href=\"https://gdal.org/\">https://gdal.org/</a>) </br></p>\n\n<p><strong>Installation</strong> </br>\nUsing pip:</p>\n\n<pre><code>pip install gdal\npip install buteo\n</code></pre>\n\n<p>Using conda:</p>\n\n<pre><code>conda install gdal\npip install buteo\n</code></pre>\n\n<p><strong>Quickstart</strong></p>\n\n<h3 id=\"reproject-and-other-functions-to-references-vector-and-raster\">Reproject (and other functions) to references. (Vector and raster)</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n\n<span class=\"n\">OUTDIR</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/output/dir&quot;</span>\n\n<span class=\"n\">vector_file_correct_projection</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/vector/file.gpkg&quot;</span>\n<span class=\"n\">raster_files_wrong_projection</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/raster/files/*.tif:glob&quot;</span>\n\n<span class=\"n\">paths_to_reprojected_rasters</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">reproject_raster</span><span class=\"p\">(</span>\n    <span class=\"n\">raster_files_with_wrong_projection</span><span class=\"p\">,</span>\n    <span class=\"n\">vector_file_with_correct_projection</span><span class=\"p\">,</span>\n    <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"n\">outdir</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">paths_to_reprojected_rasters</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"n\">path</span><span class=\"o\">/</span><span class=\"n\">to</span><span class=\"o\">/</span><span class=\"n\">output</span><span class=\"o\">/</span><span class=\"nb\">dir</span><span class=\"o\">/</span><span class=\"n\">file1</span><span class=\"o\">.</span><span class=\"n\">tif</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"o\">/</span><span class=\"n\">to</span><span class=\"o\">/</span><span class=\"n\">output</span><span class=\"o\">/</span><span class=\"nb\">dir</span><span class=\"o\">/</span><span class=\"n\">file2</span><span class=\"o\">.</span><span class=\"n\">tif</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n\n<h3 id=\"align-stack-and-make-patches-from-rasters\">Align, stack, and make patches from rasters</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n\n<span class=\"n\">SRCDIR</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/src/dir/&quot;</span>\n\n<span class=\"n\">paths_to_aligned_rasters_in_memory</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">align_rasters</span><span class=\"p\">(</span>\n    <span class=\"n\">SRCDIR</span> <span class=\"o\">+</span> <span class=\"s2\">&quot;*.tif:glob&quot;</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">stacked_numpy_arrays</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span>\n    <span class=\"n\">paths_to_aligned_rasters_in_memory</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">patches</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">array_to_patches</span><span class=\"p\">(</span>\n    <span class=\"n\">stacked_numpy_arrays</span><span class=\"p\">,</span>\n    <span class=\"mi\">256</span><span class=\"p\">,</span>\n    <span class=\"n\">n_offsets</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"c1\"># 1 overlap at 1/2 patch size (128)</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># patches_nr, height, width, channels</span>\n<span class=\"n\">patches</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">([</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<h3 id=\"predict-a-raster-using-a-model\">Predict a raster using a model</h3>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n\n<span class=\"n\">RASTER_PATH</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/raster/raster.tif&quot;</span>\n<span class=\"n\">RASTER_OUT_PATH</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/raster/raster_pred.tif&quot;</span>\n\n<span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span><span class=\"n\">RASTER_PATH</span><span class=\"p\">)</span>\n\n<span class=\"n\">callback</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">predict</span> <span class=\"c1\"># from pytorch, keras, etc..</span>\n\n<span class=\"c1\"># Predict the raster using overlaps, and borders.</span>\n<span class=\"c1\"># Merge using different methods. (median, mad, mean, mode, ...)</span>\n<span class=\"n\">predicted</span> <span class=\"o\">=</span> <span class=\"n\">predict_array</span><span class=\"p\">(</span>\n    <span class=\"n\">array</span><span class=\"p\">,</span>\n    <span class=\"n\">callback</span><span class=\"p\">,</span>\n    <span class=\"n\">tile_size</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Write the predicted raster to disk</span>\n<span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">array_to_raster</span><span class=\"p\">(</span>\n    <span class=\"n\">predicted</span><span class=\"p\">,</span>\n    <span class=\"n\">reference</span><span class=\"o\">=</span><span class=\"n\">RASTER_PATH</span><span class=\"p\">,</span>\n    <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"n\">RASTER_OUT_PATH</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n<span class=\"c1\"># Path to the predicted raster</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"s2\">&quot;path/to/raster/raster_pred.tif&quot;</span>\n</code></pre>\n</div>\n\n<p></br></p>\n\n<table>\n<thead>\n<tr>\n  <th>Example Colabs</th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>Create labels from OpenStreetMap data</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/create_labels_from_osm_data.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Scheduled cleaning of geospatial data</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/rocket_example.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Clip and remove noise from rasters</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/clip_and_remove_noise_raster.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Sharpen nightlights data</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/process_nightlights.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Filters and morphological operations</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/filters_and_morphology.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n</tbody>\n</table>\n\n<p></br></p>\n\n<p>The toolbox is being developed by ESA-Philab, NIRAS, and Aalborg University.</p>\n\n<h1 id=\"dependencies\">Dependencies</h1>\n\n<p>gdal\nnumba</p>\n\n<p>optional:\norfeo-toolbox\nesa-snap</p>\n"}, {"fullname": "buteo.ai", "modulename": "buteo.ai", "kind": "module", "doc": "<p>Tools for working with sentinel data</p>\n"}, {"fullname": "buteo.ai.augmentation", "modulename": "buteo.ai.augmentation", "kind": "module", "doc": "<p>This module contains functions for augmenting images that are\nsuited to remote sensing imagery.</p>\n"}, {"fullname": "buteo.ai.augmentation.AugmentationDataset", "modulename": "buteo.ai.augmentation", "qualname": "AugmentationDataset", "kind": "class", "doc": "<p>A dataset that applies augmentations to the data.\nEvery augmentation added needs to be specified as a dictionary\nwith the following keys:\n    - name (str)\n    - chance (float[0,1])</p>\n\n<p>The following augmentations are supported:\n    - rotation\n    - mirror\n    - channel_scale (additive(bool), max_value(float[0,1]))\n    - noise (additive(bool), max_value(float[0,1]))\n    - contrast (max_value(float[0,1]))\n    - drop_pixel (drop_probability(float[0,1]), drop_value(float))\n    - drop_channel (drop_probability(float[0,1]), drop_value(float))\n    - blur\n    - blur_xy\n    - sharpen\n    - sharpen_xy\n    - cutmix (min_size(float[0, 1]), max_size(float[0, 1]))\n    - mixup (min_size(float[0, 1]), max_size(float[0, 1]), label_mix(int))</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe data to augment.</li>\n<li><strong>y</strong> (np.ndarray):\nThe labels for the data.</li>\n<li><strong>augmentations</strong> (list, optional):\nThe augmentations to apply.</li>\n<li><strong>callback</strong> (callable, optional):\nA callback to apply to the data after augmentation.</li>\n<li><strong>input_is_channel_last : bool, default</strong> (True):\nWhether the data is in channel last format.</li>\n<li><strong>output_is_channel_last : bool, default</strong> (False):\nWhether the output should be in channel last format.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>AugmentationDataset</strong>: A dataset yielding batches of augmented data. For Pytorch,\nconvert the batches to tensors before ingestion.</li>\n</ul>\n\n<h6 id=\"example\">Example</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"k\">def</span> <span class=\"nf\">callback</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>\n<span class=\"gp\">... </span>    <span class=\"k\">return</span> <span class=\"p\">(</span>\n<span class=\"gp\">... </span>        <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">from_numpy</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">(),</span>\n<span class=\"gp\">... </span>        <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">from_numpy</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">float</span><span class=\"p\">(),</span>\n<span class=\"gp\">... </span>    <span class=\"p\">)</span>\n<span class=\"gp\">...</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dataset</span> <span class=\"o\">=</span> <span class=\"n\">AugmentationDataset</span><span class=\"p\">(</span>\n<span class=\"gp\">... </span>    <span class=\"n\">x_train</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">y_train</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">callback</span><span class=\"o\">=</span><span class=\"n\">callback</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">input_is_channel_last</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">output_is_channel_last</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">,</span>\n<span class=\"gp\">... </span>    <span class=\"n\">augmentations</span><span class=\"o\">=</span><span class=\"p\">[</span>\n<span class=\"gp\">... </span>        <span class=\"p\">{</span> <span class=\"s2\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;rotation&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;chance&quot;</span><span class=\"p\">:</span> <span class=\"mf\">0.2</span><span class=\"p\">},</span>\n<span class=\"gp\">... </span>        <span class=\"p\">{</span> <span class=\"s2\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;mirror&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;chance&quot;</span><span class=\"p\">:</span> <span class=\"mf\">0.2</span> <span class=\"p\">},</span>\n<span class=\"gp\">... </span>        <span class=\"p\">{</span> <span class=\"s2\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;noise&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;chance&quot;</span><span class=\"p\">:</span> <span class=\"mf\">0.2</span> <span class=\"p\">},</span>\n<span class=\"gp\">... </span>        <span class=\"p\">{</span> <span class=\"s2\">&quot;name&quot;</span><span class=\"p\">:</span> <span class=\"s2\">&quot;cutmix&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;chance&quot;</span><span class=\"p\">:</span> <span class=\"mf\">0.2</span> <span class=\"p\">},</span>\n<span class=\"gp\">... </span>    <span class=\"p\">],</span>\n<span class=\"gp\">... </span><span class=\"p\">)</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">from</span> <span class=\"nn\">torch.utils.data</span> <span class=\"kn\">import</span> <span class=\"n\">DataLoader</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">dataloader</span> <span class=\"o\">=</span> <span class=\"n\">DataLoader</span><span class=\"p\">(</span><span class=\"n\">dataset</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"o\">=</span><span class=\"mi\">32</span><span class=\"p\">,</span> <span class=\"n\">shuffle</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n"}, {"fullname": "buteo.ai.augmentation.AugmentationDataset.__init__", "modulename": "buteo.ai.augmentation", "qualname": "AugmentationDataset.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">augmentations</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">callback</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">input_is_channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">output_is_channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "buteo.ai.augmentation.Dataset", "modulename": "buteo.ai.augmentation", "qualname": "Dataset", "kind": "class", "doc": "<p>A dataset that does not apply any augmentations to the data.\nAllows a callback to be passed and can convert between\nchannel formats.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe data to augment.</li>\n<li><strong>y</strong> (np.ndarray):\nThe labels for the data.</li>\n<li><strong>callback</strong> (callable, optional):\nA callback to apply to the data after augmentation.</li>\n<li><strong>input_is_channel_last : bool, default</strong> (True):\nWhether the data is in channel last format.</li>\n<li><strong>output_is_channel_last : bool, default</strong> (False):\nWhether the output should be in channel last format.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Dataset</strong>: A dataset yielding batches of data. For Pytorch,\nconvert the batches to tensors before ingestion.</li>\n</ul>\n"}, {"fullname": "buteo.ai.augmentation.Dataset.__init__", "modulename": "buteo.ai.augmentation", "qualname": "Dataset.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">callback</span><span class=\"p\">:</span> <span class=\"n\">Callable</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">input_is_channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">output_is_channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "buteo.ai.augmentation_funcs", "modulename": "buteo.ai.augmentation_funcs", "kind": "module", "doc": "<p>This module contains functions for augmenting images that are\nsuited to remote sensing imagery.</p>\n"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_rotation", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_rotation", "kind": "function", "doc": "<p>Randomly rotate the image by 90 degrees intervals. Images\ncan be (channels, height, width) or (height, width, channels).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to rotate.</li>\n<li><strong>k</strong> (int, optional):\nThe number of 90 degree intervals to rotate by, default: None.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The rotated image.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_rotation_xy", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_rotation_xy", "kind": "function", "doc": "<p>Randomly rotate the image and label by 90 degrees intervals. Images\ncan be (channels, height, width) or (height, width, channels).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to rotate.</li>\n<li><strong>y</strong> (np.ndarray):\nThe label to rotate.</li>\n<li><strong>k</strong> (int, optional):\nThe number of 90 degree intervals to rotate by, default: None.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: The rotated image and optionally the label.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_mirror", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_mirror", "kind": "function", "doc": "<p>Randomly mirrors the image.\nImages can be (channels, height, width) or (height, width, channels).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to mirror.</li>\n<li><strong>k</strong> (int, optional):\nIf None, randomly mirrors the image along the horizontal or vertical axis.\n<ol>\n<li>mirrors the image along the horizontal axis.</li>\n<li>mirrors the image along the vertical axis.</li>\n<li>mirrors the image along both the horizontal and vertical axis, default: None.</li>\n</ol></li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The mirrored image.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_mirror_xy", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_mirror_xy", "kind": "function", "doc": "<p>Randomly mirrors the image. Images can be (channels, height, width) or (height, width, channels).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to mirror.</li>\n<li><strong>y</strong> (np.ndarray):\nThe label to mirror.</li>\n<li><strong>k</strong> (int, optional):\nIf None, randomly mirrors the image along the horizontal or vertical axis.\n<ol>\n<li>mirrors the image along the horizontal axis.</li>\n<li>mirrors the image along the vertical axis.</li>\n<li>mirrors the image along both the horizontal and vertical axis, default: None.</li>\n</ol></li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: The mirrored image and optionally the label.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_noise_uniform", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_noise_uniform", "kind": "function", "doc": "<p>Adds random noise seperately to each pixel of the image. The noise works\nfor both channel first and last images. Follows a uniform distribution.\nInput should be (height, width, channels) or (channels, height, width).</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to add noise to.</li>\n<li><strong>max_amount</strong> (float, optional):\nThe maximum amount of noise to add, sampled uniformly, default: 0.1.</li>\n<li><strong>additive</strong> (bool, optional):\nWhether to add or multiply the noise, default: False.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), ignored for this function.\nKept to keep the same function signature as other augmentations, default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The image with uniform noise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">additive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_noise_normal", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_noise_normal", "kind": "function", "doc": "<p>Adds random noise seperately to each pixel of the image. The noise works\nfor both channel first and last images. Follows a normal distribution.\nmax_amount is the standard deviation of the normal distribution.\nInput should be (height, width, channels) or (channels, height, width).</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to add noise to.</li>\n<li><strong>max_amount</strong> (float, optional):\nThe maximum amount of noise to add, sampled uniformly, default: 0.1.</li>\n<li><strong>additive</strong> (bool, optional):\nWhether to add or multiply the noise, default: False.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), ignored for this function.\nKept to keep the same function signature as other augmentations, default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The image with normal noise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">additive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_channel_scale", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_channel_scale", "kind": "function", "doc": "<p>Scales the channels of the image seperately by a fixed amount.\nInput should be (height, width, channels) or (channels, height, width).</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to scale the channels of.</li>\n<li><strong>max_amount</strong> (float, optional):\nThe amount to possible scale the channels by. Sampled uniformly, default: 0.1.</li>\n<li><strong>additive</strong> (bool, optional):\nWhether to add or multiply the scaling, default: False.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The image with scaled channels.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">additive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_contrast", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_contrast", "kind": "function", "doc": "<p>Changes the contrast of an image by a random amount, seperately for each channel.\nInput should be (height, width, channels) or (channels, height, width).</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to change the contrast of.</li>\n<li><strong>max_amount</strong> (float, optional):\nThe max amount to change the contrast by, default: 0.1.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The image with changed contrast.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_drop_pixel", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_drop_pixel", "kind": "function", "doc": "<p>Drops random pixels from an image. Input should be (height, width, channels) or (channels, height, width).\nOnly drops pixels from features, not labels.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to drop a pixel from.</li>\n<li><strong>drop_probability</strong> (float, optional):\nThe probability of dropping a pixel, default: 0.05.</li>\n<li><strong>drop_value</strong> (float, optional):\nThe value to drop the pixel to, default: 0.0.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The image with dropped pixels.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">drop_probability</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">drop_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_drop_channel", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_drop_channel", "kind": "function", "doc": "<p>Drops a random channel from an image. Input should be (height, width, channels) or (channels, height, width).\nA maximum of one channel will be dropped.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to drop a channel from.</li>\n<li><strong>drop_value</strong> (float, optional):\nThe value to drop the channel to, default: 0.0.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The image with dropped channels.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">drop_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_blur", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_blur", "kind": "function", "doc": "<p>Blurs an image at random. Input should be (height, width, channels) or (channels, height, width).</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to blur.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The blurred image.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_blur_xy", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_blur_xy", "kind": "function", "doc": "<p>Blurs an image at random. Input should be (height, width, channels) or (channels, height, width).\nThe label is blurred by the same amount.</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to blur.</li>\n<li><strong>y</strong> (np.ndarray):\nThe label to blur.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: The blurred image and optionally the unmodified label.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_sharpen", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_sharpen", "kind": "function", "doc": "<p>Sharpens an image at random. Input should be (height, width, channels) or (channels, height, width).</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to sharpen.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The sharpened image.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_sharpen_xy", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_sharpen_xy", "kind": "function", "doc": "<p>Sharpens an image at random. Input should be (height, width, channels) or (channels, height, width).\nThe label is sharpened by the same amount.</p>\n\n<p>NOTE: Beware of datatypes. Consider casting to float32 before adding noise.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to sharpen.</li>\n<li><strong>y</strong> (np.ndarray):\nThe label to sharpen. If None, no label is returned</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: The sharpened image and label.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_misalign", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_misalign", "kind": "function", "doc": "<p>Misaligns one channel in the image at random.\ninput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe image to misalign the channels of.</li>\n<li><strong>max_offset</strong> (float, optional):\nThe maximum offset to misalign the channels by. Default: 0.5.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels). Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The misaligned image.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">max_offset</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_cutmix", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_cutmix", "kind": "function", "doc": "<p>Cutmixes two images.\nInput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X_target</strong> (np.ndarray):\nThe image to transfer the cutmix to.</li>\n<li><strong>y_target</strong> (np.ndarray):\nThe label to transfer the cutmix to.</li>\n<li><strong>X_source</strong> (np.ndarray):\nThe image to cutmix from.</li>\n<li><strong>y_source</strong> (np.ndarray):\nThe label to cutmix from.</li>\n<li><strong>min_size</strong> (float, optional):\nThe minimum size of the patch to cutmix. In percentage of the image width, default: 0.333.</li>\n<li><strong>max_size</strong> (float, optional):\nThe maximum size of the patch to cutmix. In percentage of the image width, default: 0.666.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: The cutmixed image and label.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">X_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">min_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.333</span>,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.666</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_mixup", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_mixup", "kind": "function", "doc": "<p>Mixups two images at random. This works by doing a linear intepolation between\ntwo images and then adding a random weight to each image.</p>\n\n<p>Mixup involves taking two images and blending them together by randomly interpolating\ntheir pixel values. More specifically, suppose we have two images x and x' with their\ncorresponding labels y and y'. To generate a new training example, mixup takes a\nweighted sum of x and x', such that the resulting image x^* = \u03bbx + (1-\u03bb)x',\nwhere \u03bb is a randomly chosen interpolation coefficient. The label for the new image\nis also a weighted sum of y and y' based on the same interpolation coefficient.</p>\n\n<p>input should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X_target</strong> (np.ndarray):\nThe image to transfer to.</li>\n<li><strong>y_target</strong> (np.ndarray):\nThe label to transfer to.</li>\n<li><strong>X_source</strong> (np.ndarray):\nThe image to transfer from.</li>\n<li><strong>y_source</strong> (np.ndarray):\nThe label to transfer from.</li>\n<li><strong>min_size</strong> (float, optional):\nThe minimum mixup coefficient, default: 0.333.</li>\n<li><strong>max_size</strong> (float, optional):\nThe maximum mixup coefficient, default: 0.666.</li>\n<li><strong>label_mix</strong> (int, optional):\nIf 0, the labels will be mixed by the weights. If 1, the target label will be used. If 2, \nthe source label will be used. If 3, the max of the labels will be used. If 4, the min \nof the labels will be used. If 5, the max of the image with the highest weight will be used. \nIf 6, the min of the image with the highest weight will be used. If 7, the sum of the labels \nwill be used, default: 0.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the image is (channels, height, width) or (height, width, channels), default: True.</li>\n<li><strong>inplace</strong> (bool, optional):\nWhether to perform the rotation in-place, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: The mixed up image and label.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">X_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">min_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.333</span>,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.666</span>,</span><span class=\"param\">\t<span class=\"n\">label_mix</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils", "modulename": "buteo.ai.augmentation_utils", "kind": "module", "doc": "<p>This module contains utility functions for augmenting images that are\nsuited to remote sensing imagery.</p>\n"}, {"fullname": "buteo.ai.encoding", "modulename": "buteo.ai.encoding", "kind": "module", "doc": "<h3 id=\"encoding-spatial-values\">Encoding spatial values</h3>\n"}, {"fullname": "buteo.ai.encoding.encode_latitude", "modulename": "buteo.ai.encoding", "qualname": "encode_latitude", "kind": "function", "doc": "<p>Encode a latitude value into a two-element numpy array of sine and cosine components.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lat</strong> (float):\nThe latitude value to encode. Must be in the range [-90, 90].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A two-element numpy array containing the sine and cosine components of the encoded latitude.\nThe sine and cosine values are scaled to the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lat</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.encode_longitude", "modulename": "buteo.ai.encoding", "qualname": "encode_longitude", "kind": "function", "doc": "<p>Encode a longitude value into a two-element numpy array of sine and cosine components.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lng</strong> (float):\nThe longitude value to encode. Must be in the range [-180, 180].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A two-element numpy array containing the sine and cosine components of the encoded longitude.\nThe sine and cosine values are scaled to the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lng</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.encode_latlng", "modulename": "buteo.ai.encoding", "qualname": "encode_latlng", "kind": "function", "doc": "<p>Encode a latitude-longitude coordinate into a four-element numpy array of sine and cosine components.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>latlng</strong> (Union[np.ndarray, Tuple[float, float], List[float]]):\nA tuple, list, or numpy array containing the latitude and longitude values to encode.\nThe latitude value must be in the range [-90, 90] and the longitude value must be in the range [-180, 180].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A four-element numpy array containing the sine and cosine components of the encoded latitude and longitude.\nThe sine and cosine values are scaled to the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">latlng</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.encode_latlngs", "modulename": "buteo.ai.encoding", "qualname": "encode_latlngs", "kind": "function", "doc": "<p>Encode multiple latitude-longitude coordinates into a numpy array of sine and cosine components.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>latlngs</strong> (np.ndarray):\nA numpy array containing the latitude-longitude coordinates to encode.\nThe shape of the array should be (n, 2), (m, n, 2), or (p, q, n, 2), where n=2 represents the latitude\nand longitude values. The latitude value must be in the range [-90, 90] and the longitude value must be\nin the range [-180, 180].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array containing the sine and cosine components of the encoded latitude and longitude values.\nThe shape of the returned array will depend on the shape of the input array, with the last dimension\nbeing 4 (two sine and two cosine values).</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the input array has more than 3 dimensions or the shape of the array is not (n, 2), (m, n, 2),\nor (p, q, n, 2).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">latlngs</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.decode_latitude", "modulename": "buteo.ai.encoding", "qualname": "decode_latitude", "kind": "function", "doc": "<p>Decode an encoded sine and cosine value to the original latitude value.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>encoded_sin</strong> (float):\nThe sine component of the encoded latitude value.\nMust be in the range [0, 1].</li>\n<li><strong>encoded_cos</strong> (float):\nThe cosine component of the encoded latitude value.\nMust be in the range [0, 1].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: The original latitude value. The decoded latitude value is in the range [-90, 90].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">encoded_sin</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">encoded_cos</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.decode_longitude", "modulename": "buteo.ai.encoding", "qualname": "decode_longitude", "kind": "function", "doc": "<p>Decode an encoded sine and cosine value to the original longitude value.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>encoded_sin</strong> (float):\nThe sine component of the encoded longitude value.\nMust be in the range [0, 1].</li>\n<li><strong>encoded_cos</strong> (float):\nThe cosine component of the encoded longitude value.\nMust be in the range [0, 1].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: The original longitude value. The decoded longitude value is in the range [-180, 180].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">encoded_sin</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">encoded_cos</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.decode_latlng", "modulename": "buteo.ai.encoding", "qualname": "decode_latlng", "kind": "function", "doc": "<p>Decode an encoded latitude-longitude coordinate to the original latitude-longitude values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>encoded_latlng</strong> (Union[np.ndarray, List[Union[float, int]]]):\nA numpy array or list containing the encoded latitude-longitude coordinate to decode.\nThe shape of the array should be (4,), with the first two values representing the encoded latitude\nand the last two values representing the encoded longitude. The encoded sine and cosine values\nmust be in the range [0, 1].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array containing the original latitude and longitude values. The shape of the returned\narray will be (2,) with the latitude value at index 0 and the longitude value at index 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">encoded_latlng</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.decode_latlngs", "modulename": "buteo.ai.encoding", "qualname": "decode_latlngs", "kind": "function", "doc": "<p>Decode multiple encoded latitude-longitude coordinates to the original latitude-longitude values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>encoded_latlngs</strong> (Union[np.ndarray, List[Union[float, int]]]):\nA numpy array or list containing the encoded latitude-longitude coordinates to decode.\nThe shape of the array should be (n, 4), where n represents the number of encoded coordinates.\nThe first two values of each encoded coordinate represent the encoded latitude and the last two\nvalues represent the encoded longitude. The encoded sine and cosine values must be in the range [0, 1].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array containing the original latitude-longitude values. The shape of the returned\narray will be (n, 2), where n represents the number of encoded coordinates. The latitude value\nwill be at index 0 and the longitude value will be at index 1.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">encoded_latlngs</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.encode_width", "modulename": "buteo.ai.encoding", "qualname": "encode_width", "kind": "function", "doc": "<p>Encode the width of a rectangle to be used as input to the model.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>lng</strong> (float):\nThe longitude value representing the width of the rectangle.\nMust be in the range [-180, 180].</li>\n<li><strong>lng_max</strong> (float):\nThe maximum longitude value. This is typically 360 for the full longitude range.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array containing the encoded width of the rectangle.\nThe encoded width consists of two values: the encoded sine and cosine values.\nBoth values will be in the range [0, 1].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lng</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">lng_max</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.encoding.encode_arr_position", "modulename": "buteo.ai.encoding", "qualname": "encode_arr_position", "kind": "function", "doc": "<p>Fast encoding of a 2D numpy array of coordinates where the width is cyclical.\nVery useful for global maps.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nA 2D numpy array of coordinates to be encoded. The first dimension represents the columns\nand the second dimension represents the rows. The shape of the array should be (m, n), where\nm represents the number of columns and n represents the number of rows.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array containing the encoded coordinates. The shape of the returned array will be (m, n, 3),\nwhere m represents the number of columns, n represents the number of rows, and 3 represents the\nnumber of encoded values for each coordinate. The first two values of each encoded coordinate\nrepresent the encoded width, while the last value represents the encoded column.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers", "modulename": "buteo.ai.scalers", "kind": "module", "doc": "<p>This module provides a set of functions to normalise data for machine learning.</p>\n"}, {"fullname": "buteo.ai.scalers.scaler_minmax", "modulename": "buteo.ai.scalers", "qualname": "scaler_minmax", "kind": "function", "doc": "<p>Normalize an input numpy array using the min-max scaling method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nThe input numpy array to be normalized.</li>\n<li><strong>stat_dict : Optional[Dict[str, float]], default</strong> (None):\nA dictionary containing the minimum and maximum values of the input array.\nIf not provided, the function will compute the minimum and maximum values from the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, Dict[str, float]]</strong>: A tuple containing the normalized numpy array (with dtype float32) and a dictionary containing the minimum\nand maximum values used for scaling. The minimum and maximum values are stored in the dictionary using the\nkeys \"min\" and \"max\", respectively.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If the input array is not a numpy array, or if the stat_dict is not a dictionary or None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">stat_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_standardise", "modulename": "buteo.ai.scalers", "qualname": "scaler_standardise", "kind": "function", "doc": "<p>Standardize an an input numpy array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nThe input numpy array to be normalized.</li>\n<li><strong>stat_dict : Optional[Dict[str, float]], default</strong> (None):\nA dictionary containing the mean and standard deviation values of the input array.\nIf not provided, the function will compute the mean and standard deviation from the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, Dict[str, float]]</strong>: A tuple containing the normalized numpy array (with dtype float32) and a dictionary containing the mean\nand standard deviation values used for scaling. The mean and standard deviation values are stored in the\ndictionary using the keys \"mean\" and \"std\", respectively.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If the input array is not a numpy array, or if the stat_dict is not a dictionary or None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">stat_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_standardise_mad", "modulename": "buteo.ai.scalers", "qualname": "scaler_standardise_mad", "kind": "function", "doc": "<p>Normalize an input numpy array using the median absolute deviation (MAD) scaling method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nThe input numpy array to be normalized.</li>\n<li><strong>stat_dict : Optional[Dict[str, float]], default</strong> (None):\nA dictionary containing the median, absolute deviation and median absolute deviation of the input array.\nIf not provided, the function will compute these statistics from the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, Dict[str, float]]</strong>: A tuple containing the normalized numpy array (with dtype float32) and a dictionary containing the median,\nabsolute deviation, and median absolute deviation used for scaling. These statistics are stored in the\ndictionary using the keys \"median\", \"absdev\", and \"madstd\", respectively.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If the input array is not a numpy array, or if the stat_dict is not a dictionary or None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">stat_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_iqr", "modulename": "buteo.ai.scalers", "qualname": "scaler_iqr", "kind": "function", "doc": "<p>Normalize an input numpy array using the interquartile range (IQR) method.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nThe input numpy array to be normalized.</li>\n<li><strong>q1 : float, default</strong> (0.25):\nThe lower quartile to use in the IQR calculation.</li>\n<li><strong>q3 : float, default</strong> (0.75):\nThe upper quartile to use in the IQR calculation.</li>\n<li><strong>stat_dict : Optional[Dict[str, float]], default</strong> (None):\nA dictionary containing the lower, median, and upper quartiles of the input array.\nIf not provided, the function will compute the quartiles from the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, Dict[str, float]]</strong>: A tuple containing the normalized numpy array (with dtype float32) and a dictionary containing the lower,\nmedian, and upper quartiles used for scaling. The quartile values are stored in the dictionary using the keys\n\"q1\", \"median\", and \"q3\", respectively.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If the input array is not a numpy array, q1 is not between 0.0 and 0.5, q3 is not between 0.5 and 1.0, or if\nq1 is greater than or equal to q3, or if stat_dict is not a dictionary or None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">q1</span><span class=\"o\">=</span><span class=\"mf\">0.25</span>,</span><span class=\"param\">\t<span class=\"n\">q3</span><span class=\"o\">=</span><span class=\"mf\">0.75</span>,</span><span class=\"param\">\t<span class=\"n\">stat_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_to_range", "modulename": "buteo.ai.scalers", "qualname": "scaler_to_range", "kind": "function", "doc": "<p>Normalizes an input numpy array to a given range.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nThe input numpy array to be normalized.</li>\n<li><strong>min_val</strong> (Union[float, int], optional):\nThe minimum value to scale the array to, default: 0.0.</li>\n<li><strong>max_val</strong> (Union[float, int], optional):\nThe maximum value to scale the array to, default: 1.0.</li>\n<li><strong>stat_dict</strong> (Optional[Dict[str, float]], optional):\nA dictionary containing the minimum and maximum values of the input array.\nIf not provided, the function will compute the minimum and maximum values from the input array.\ndefault: None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.array, Dict[str, float]]</strong>: A tuple containing the normalized numpy array (with dtype float32) and a dictionary containing the minimum\nand maximum values used for scaling. The minimum and maximum values are stored in the dictionary using the\nkeys \"min\" and \"max\", respectively.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If the input array is not a numpy array or if the stat_dict is not a dictionary or None.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This function uses the formula (arr - arr_min) / (arr_max - arr_min) to normalize the input array to a range\nof [min_val, max_val]. The minimum and maximum values of the input array can be passed through stat_dict,\notherwise, they will be computed from the array.</p>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">scaler_to_range</span><span class=\"p\">(</span><span class=\"n\">arr</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"mf\">2.</span><span class=\"p\">,</span> <span class=\"mf\">4.</span><span class=\"p\">,</span> <span class=\"mf\">6.</span><span class=\"p\">,</span> <span class=\"mf\">10.</span><span class=\"p\">],</span> <span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"n\">float32</span><span class=\"p\">),</span> <span class=\"p\">{</span><span class=\"s1\">&#39;min&#39;</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s1\">&#39;max&#39;</span><span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">})</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">min_val</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_val</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">stat_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_truncate", "modulename": "buteo.ai.scalers", "qualname": "scaler_truncate", "kind": "function", "doc": "<p>Truncate an input numpy array within the given range, and then normalise it to the target range.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nThe input numpy array to be truncated and normalized.</li>\n<li><strong>trunc_min</strong> (float/int, optional):\nThe minimum value to truncate to. If not provided, truncation will not be applied to the lower end.</li>\n<li><strong>trunc_max</strong> (float/int, optional):\nThe maximum value to truncate to. If not provided, truncation will not be applied to the upper end.</li>\n<li><strong>target_min</strong> (float/int, optional):\nThe minimum value of the target range to normalize to. Default: 0.0.</li>\n<li><strong>target_max</strong> (float/int, optional):\nThe maximum value of the target range to normalize to. Default: 1.0.</li>\n<li><strong>stat_dict</strong> (Dict[str, float], optional):\nA dictionary containing the minimum and maximum values of the input array. If not provided, the function\nwill compute the minimum and maximum values from the truncated array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.array, Dict[str, float]]</strong>: A tuple containing the normalized numpy array (with dtype float32) and a dictionary containing the minimum\nand maximum values used for scaling. The minimum and maximum values are stored in the dictionary using the\nkeys \"arr_min\" and \"arr_max\", respectively.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If the input array is not a numpy array, or if the trunc_min is not less than trunc_max, or if the\ntarget_min is not less than target_max, or if the stat_dict is not a dictionary or None.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">trunc_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">trunc_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">target_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">stat_dict</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.selection", "modulename": "buteo.ai.selection", "kind": "module", "doc": "<p>This module contains function to select features from a dataset for machine learning.</p>\n"}, {"fullname": "buteo.ai.selection.split_train_val", "modulename": "buteo.ai.selection", "qualname": "split_train_val", "kind": "function", "doc": "<p>Split a dataset into training and validation sets using random shuffling.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe input data.</li>\n<li><strong>y</strong> (np.ndarray):\nThe target data.</li>\n<li><strong>val_size</strong> (float, optional):\nThe size of the validation set as a fraction of the total dataset. Default: 0.2.</li>\n<li><strong>random_state</strong> (Union[float, int], optional):\nThe random seed to use for the split. Default is None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]</strong>: A tuple containing the training and validation sets for input data and target data,\nrespectively, in the following order: x_train, x_val, y_train, y_val.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If X and y are not numpy arrays, X and y do not have the same number of rows, or\nval_size is not between 0 and 1.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The function always shuffles the data before splitting.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">val_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.selection.split_train_val_test", "modulename": "buteo.ai.selection", "qualname": "split_train_val_test", "kind": "function", "doc": "<p>Split a dataset into training, validation, and test sets using a specified random seed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe input data to be split.</li>\n<li><strong>y</strong> (np.ndarray):\nThe target data to be split.</li>\n<li><strong>val_size</strong> (float, optional):\nThe proportion of the data to use for validation, default: 0.1.</li>\n<li><strong>test_size</strong> (float, optional):\nThe proportion of the data to use for testing, default: 0.2.</li>\n<li><strong>random_state</strong> (float or int, optional):\nSeed for the random number generator used for shuffling, default: None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray, np.ndarray]</strong>: A tuple containing the following arrays:\n<ul>\n<li>x_train: training input data</li>\n<li>x_val: validation input data</li>\n<li>x_test: testing input data</li>\n<li>y_train: training target data</li>\n<li>y_val: validation target data</li>\n<li>y_test: testing target data</li>\n</ul></li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>AssertionError</strong>: If X and y are not numpy arrays with the same shape[0], or if val_size or test_size are not between 0 and 1.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>The function always shuffles the data before splitting.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">val_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">test_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.selection.stratified_sampling", "modulename": "buteo.ai.selection", "qualname": "stratified_sampling", "kind": "function", "doc": "<p>Stratified sampling of a dataset.</p>\n\n<p>This function can be used for both regression and classification problems.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>X</strong> (np.ndarray):\nThe input data.</li>\n<li><strong>y</strong> (np.ndarray):\nThe target data.</li>\n<li><strong>regression</strong> (bool, optional):\nWhether the dataset is for regression or classification.\nDefault: False.</li>\n<li><strong>samples_per_class</strong> (int, optional):\nThe number of samples to take per class.\nIf None, takes the same number of samples per class as the smallest class.\nDefault: None.</li>\n<li><strong>Returns:</strong></li>\n<li><strong>--------</strong></li>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: (X_stratified, y_stratified) : The stratified input and target data.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">regression</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">samples_per_class</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array", "modulename": "buteo.array", "kind": "module", "doc": "<p>Functions for transforming rasters represented as arrays.</p>\n"}, {"fullname": "buteo.array.color", "modulename": "buteo.array.color", "kind": "module", "doc": "<h3 id=\"generic-utility-functions\">Generic utility functions</h3>\n\n<p>Functions that make interacting with the toolbox easier.</p>\n"}, {"fullname": "buteo.array.color.hsl_to_rgb", "modulename": "buteo.array.color", "qualname": "hsl_to_rgb", "kind": "function", "doc": "<p>Convert an HSL array to an RGB array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>hsl_array</strong> (np.ndarray):\nInput HSL array with shape (height, width, 3).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Output RGB array with shape (height, width, 3).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hsl_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.color.rgb_to_hsl", "modulename": "buteo.array.color", "qualname": "rgb_to_hsl", "kind": "function", "doc": "<p>Convert an RGB array to an HSL array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rgb_array</strong> (np.ndarray):\nInput RGB array with shape (height, width, 3).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: Output HSL array with shape (height, width, 3).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rgb_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution", "modulename": "buteo.array.convolution", "kind": "module", "doc": "<h3 id=\"perform-convolutions-on-arrays\">Perform convolutions on arrays.</h3>\n"}, {"fullname": "buteo.array.convolution.pad_array", "modulename": "buteo.array.convolution", "qualname": "pad_array", "kind": "function", "doc": "<p>Create a padded view of an array using SAME padding.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (numpy.ndarray):\nThe input array to be padded.</li>\n<li><strong>pad_size</strong> (int, optional):\nThe number of padding elements to add to each side of the array.\nDefault: 1.</li>\n<li><strong>method</strong> (str, optional):\nThe padding method to use. Default: \"same\". Other options are\n\"edge\" and \"constant\".</li>\n<li><strong>constant_value</strong> (int, optional):\nThe constant value to use when padding with \"constant\". Default: 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>numpy.ndarray</strong>: A padded view of the input array.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This function creates a padded view of an array using SAME padding, which\nadds padding elements to each side of the array so that the output shape\nis the same as the input shape. The amount of padding is determined by the\n<code>pad_size</code> parameter. The padding method can be one of three options: \"same\"\n(the default), \"edge\", or \"constant\". If \"constant\" padding is used, the\n<code>constant_value</code> parameter specifies the value to use.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">pad_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;same&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">constant_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution.convolve_array_channels", "modulename": "buteo.array.convolution", "qualname": "convolve_array_channels", "kind": "function", "doc": "<p>Convolves a 3D array along its channels.\nUseful for 'collapsing' a 3D array into a 2D array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nA 3D array.</li>\n<li><p><strong>method</strong> (int, optional):\nThe method to use for convolving the array.</p>\n\n<p>The following methods are valid:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>    1. sum\n<ol start=\"2\">\n<li>mode</li>\n<li>max/dilate</li>\n<li>min/erode</li>\n<li>contrast</li>\n<li>median</li>\n<li>std</li>\n<li>mad</li>\n<li>z_score</li>\n<li>z_score_mad</li>\n<li>sigma_lee</li>\n<li>quantile</li>\n<li>occurrances</li>\n<li>feather</li>\n<li>roughness</li>\n<li>roughness_tri</li>\n<li>roughness_tpi\n</code></pre>\n</div></li>\n\n<p></ol>\nDefault: 1.</p></li>\n<li><strong>nodata</strong> (bool, optional):\nWhether to use nodata values in the convolution. Default: False.</li>\n<li><strong>nodata_value</strong> (float, optional):\nThe nodata value to use in the convolution. Default: -9999.9.</li>\n<li><strong>func_value</strong> (int or float, optional):\nThe value to use in the convolution. Default: 0.5.</li>\n<li><strong>channel_last</strong> (bool, optional):\nWhether the channels are the last axis in the array. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The convolved array.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mf\">9999.9</span>,</span><span class=\"param\">\t<span class=\"n\">func_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution.convolve_array", "modulename": "buteo.array.convolution", "qualname": "convolve_array", "kind": "function", "doc": "<p>Convolve an array using a set of offsets and weights.\nArray can be 2D or 3D.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (numpy.ndarray):\nThe input array to be convolved.</li>\n<li><strong>offsets</strong> (list of tuples):\nThe list of pixel offsets to use in the convolution. Each tuple should be in the\nformat (row_offset, col_offset, depth_offset), where row_offset and col_offset\nare the row and column offsets from the center pixel, and depth_offset is the\ndepth offset if the input array has more than two dimensions.</li>\n<li><strong>weights</strong> (list of floats):\nThe list of weights to use in the convolution. The length of the weights list should\nbe the same as the length of the offsets list.</li>\n<li><p><strong>method</strong> (int, optional):\nThe convolution method to use. Default: 1.\nThe following methods are valid:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code>    1. sum\n<ol start=\"2\">\n<li>mode</li>\n<li>max/dilate</li>\n<li>min/erode</li>\n<li>contrast</li>\n<li>median</li>\n<li>std</li>\n<li>mad</li>\n<li>z_score</li>\n<li>z_score_mad</li>\n<li>sigma_lee</li>\n<li>quantile</li>\n<li>occurrances</li>\n<li>feather</li>\n<li>roughness</li>\n<li>roughness_tri</li>\n<li>roughness_tpi\n</code></pre>\n</div></li>\n\n<p></ol></p></li>\n<li><p><strong>nodata</strong> (bool, optional):\nIf True, treat the nodata value as a valid value. Default: False.</p></li>\n<li><strong>nodata_value</strong> (float, optional):\nThe nodata value to use when computing the result. Default: -9999.9.</li>\n<li><strong>func_value</strong> (int or float, optional):\nThe value to use for pixels where the kernel extends outside the input array.\nIf None, use the edge value. Default: 0.5.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>numpy.ndarray</strong>: The convolved array.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This function convolves an array using a set of offsets and weights. The function supports\ndifferent convolution methods, including nearest, linear, and cubic. The function can also\nhandle nodata values and cases where the kernel extends outside the input array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mf\">9999.9</span>,</span><span class=\"param\">\t<span class=\"n\">func_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution_funcs", "modulename": "buteo.array.convolution_funcs", "kind": "module", "doc": "<h3 id=\"perform-convolutions-on-arrays-funcs\">Perform convolutions on arrays. (Funcs)</h3>\n"}, {"fullname": "buteo.array.convolution_kernels", "modulename": "buteo.array.convolution_kernels", "kind": "module", "doc": "<h3 id=\"perform-convolutions-on-arrays\">Perform convolutions on arrays.</h3>\n"}, {"fullname": "buteo.array.convolution_kernels.get_kernel", "modulename": "buteo.array.convolution_kernels", "qualname": "get_kernel", "kind": "function", "doc": "<p>Creates a 2D kernel for convolution.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>radius</strong> (float):\nRadius of the kernel.</li>\n<li><strong>circular</strong> (bool):\nWhether to use a circular kernel.</li>\n<li><strong>distance_weighted</strong> (bool):\nWhether to use a distance weighted kernel.</li>\n<li><strong>normalised</strong> (bool):\nWhether to normalise the kernel.</li>\n<li><strong>hole</strong> (bool):\nWhether to create a hole in the center of the kernel.</li>\n<li><strong>method</strong> (int):\nMethod to use for weighting.\n<ol start=\"0\">\n<li>linear</li>\n<li>sqrt</li>\n<li>power</li>\n<li>gaussian</li>\n<li>constant</li>\n</ol></li>\n<li><strong>decay</strong> (float):\nDecay rate for distance weighted kernels. Only used if <code>distance_weighted</code> is True.</li>\n<li><strong>sigma</strong> (float):\nSigma for gaussian distance weighted kernels. Only used if <code>distance_weighted</code> is True and <code>method</code> is 3.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>kernel</strong> (np.ndarray):\nThe kernel.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">circular</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weighted</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">normalised</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">hole</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution_kernels.get_kernel_shift", "modulename": "buteo.array.convolution_kernels", "qualname": "get_kernel_shift", "kind": "function", "doc": "<p>Create a 2D shift kernel.</p>\n\n<p>This function returns a kernel that can be used to shift a raster by a fractional\nnumber of pixels in the x and y directions. The kernel can also be used to simulate\nchannel misalignment in image augmentation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>x_offset</strong> (float):\nThe horizontal (x) offset to apply.</li>\n<li><strong>y_offset</strong> (float):\nThe vertical (y) offset to apply.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: A tuple of two numpy arrays. The first array contains the (x, y) offsets\nof the kernel values. The second array contains the corresponding weights\nof each kernel value.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x_offset</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y_offset</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution_kernels.get_kernel_unsharp", "modulename": "buteo.array.convolution_kernels", "qualname": "get_kernel_unsharp", "kind": "function", "doc": "<p>Create a 2D unsharp kernel.</p>\n\n<p>This function returns a kernel that can be used to apply an unsharp mask to an image.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>radius</strong> (float, optional):\nThe radius of the kernel. Default: 1.0.</li>\n<li><strong>intensity</strong> (float, optional):\nThe intensity of the unsharp mask. Default: 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: The kernel.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">intensity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution_kernels.get_kernel_sobel", "modulename": "buteo.array.convolution_kernels", "qualname": "get_kernel_sobel", "kind": "function", "doc": "<p>Creates a 2D Sobel style kernel consisting of a horizontal and vertical component.\nThis function returns a kernel that can be used to apply a Sobel filter to an image.</p>\n\n<p>The kernels for radis=2, scale=2 are:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">gx</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">[</span> <span class=\"mf\">0.56</span>  <span class=\"mf\">0.85</span>  <span class=\"mf\">0.</span>   <span class=\"o\">-</span><span class=\"mf\">0.85</span> <span class=\"o\">-</span><span class=\"mf\">0.56</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span> <span class=\"mf\">0.85</span>  <span class=\"mf\">1.5</span>   <span class=\"mf\">0.</span>   <span class=\"o\">-</span><span class=\"mf\">1.5</span>  <span class=\"o\">-</span><span class=\"mf\">0.85</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span> <span class=\"mf\">1.</span>    <span class=\"mf\">2.</span>    <span class=\"mf\">0.</span>   <span class=\"o\">-</span><span class=\"mf\">2.</span>   <span class=\"o\">-</span><span class=\"mf\">1.</span>  <span class=\"p\">],</span>\n    <span class=\"p\">[</span> <span class=\"mf\">0.85</span>  <span class=\"mf\">1.5</span>   <span class=\"mf\">0.</span>   <span class=\"o\">-</span><span class=\"mf\">1.5</span>  <span class=\"o\">-</span><span class=\"mf\">0.85</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span> <span class=\"mf\">0.56</span>  <span class=\"mf\">0.85</span>  <span class=\"mf\">0.</span>   <span class=\"o\">-</span><span class=\"mf\">0.85</span> <span class=\"o\">-</span><span class=\"mf\">0.56</span><span class=\"p\">],</span>\n<span class=\"p\">]</span>\n\n<span class=\"n\">gy</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n    <span class=\"p\">[</span> <span class=\"mf\">0.56</span>  <span class=\"mf\">0.85</span>  <span class=\"mf\">1.</span>    <span class=\"mf\">0.85</span>  <span class=\"mf\">0.56</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span> <span class=\"mf\">0.85</span>  <span class=\"mf\">1.5</span>   <span class=\"mf\">2.</span>    <span class=\"mf\">1.5</span>   <span class=\"mf\">0.85</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span> <span class=\"mf\">0.</span>    <span class=\"mf\">0.</span>    <span class=\"mf\">0.</span>    <span class=\"mf\">0.</span>    <span class=\"mf\">0.</span>  <span class=\"p\">],</span>\n    <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">0.85</span> <span class=\"o\">-</span><span class=\"mf\">1.5</span>  <span class=\"o\">-</span><span class=\"mf\">2.</span>   <span class=\"o\">-</span><span class=\"mf\">1.5</span>  <span class=\"o\">-</span><span class=\"mf\">0.85</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">0.56</span> <span class=\"o\">-</span><span class=\"mf\">0.85</span> <span class=\"o\">-</span><span class=\"mf\">1.</span>   <span class=\"o\">-</span><span class=\"mf\">0.85</span> <span class=\"o\">-</span><span class=\"mf\">0.56</span><span class=\"p\">],</span>\n<span class=\"p\">]</span>\n</code></pre>\n</div>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>radius</strong> (float, optional):\nThe radius of the kernel. Default: 1.0.</li>\n<li><strong>scale</strong> (float, optional):\nThe scale of the kernel. Default: 2.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray]</strong>: The kernels</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">radius</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.convolution_kernels.get_offsets_and_weights", "modulename": "buteo.array.convolution_kernels", "qualname": "get_offsets_and_weights", "kind": "function", "doc": "<p>Generates a list of offsets, weights, and the center pixel index for a given kernel.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kernel</strong> (np.ndarray):\nThe kernel to generate offsets and weights for.</li>\n<li><strong>remove_zero_weights</strong> (bool, optional):\nWhether to remove offsets and weights with zero weights. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Tuple[np.ndarray, np.ndarray, int]</strong>: The offsets, weights and the center pixel index.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kernel</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">remove_zero_weights</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.edge_detection", "modulename": "buteo.array.edge_detection", "kind": "module", "doc": "<h3 id=\"perform-morphological-operations-on-arrays-and-rasters\">Perform morphological operations on arrays and rasters.</h3>\n"}, {"fullname": "buteo.array.edge_detection.edge_detection", "modulename": "buteo.array.edge_detection", "qualname": "edge_detection", "kind": "function", "doc": "<p>Perform an detection method.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">method</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">merge_results</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">gradient_output</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.9</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.morphology", "modulename": "buteo.array.morphology", "kind": "module", "doc": "<h3 id=\"perform-morphological-operations-on-arrays-and-rasters\">Perform morphological operations on arrays and rasters.</h3>\n"}, {"fullname": "buteo.array.morphology.morph_erode", "modulename": "buteo.array.morphology", "qualname": "morph_erode", "kind": "function", "doc": "<p>Erode an array by taking the local minimum.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.morphology.morph_dilate", "modulename": "buteo.array.morphology", "qualname": "morph_dilate", "kind": "function", "doc": "<p>Dilate an array by taking the local maximum.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.morphology.morph_open", "modulename": "buteo.array.morphology", "qualname": "morph_open", "kind": "function", "doc": "<p>Perform the open mortholigical operation on an array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.morphology.morph_close", "modulename": "buteo.array.morphology", "qualname": "morph_close", "kind": "function", "doc": "<p>Perform the close morphological operation on an array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.morphology.morph_tophat", "modulename": "buteo.array.morphology", "qualname": "morph_tophat", "kind": "function", "doc": "<p>Perform the top_hat morphological operation on the array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.morphology.morph_bothat", "modulename": "buteo.array.morphology", "qualname": "morph_bothat", "kind": "function", "doc": "<p>Perform the bottom_hat morphological operation on the array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.morphology.morph_difference", "modulename": "buteo.array.morphology", "qualname": "morph_difference", "kind": "function", "doc": "<p>Perform the difference morphological operation on the array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.patches", "modulename": "buteo.array.patches", "kind": "module", "doc": "<p>Create patches from rasters, used for machine learnign applications.</p>\n"}, {"fullname": "buteo.array.patches.array_to_patches", "modulename": "buteo.array.patches", "qualname": "array_to_patches", "kind": "function", "doc": "<p>Generate patches from an array based on the specified parameters.</p>\n\n<p>NOTE: The produced patches are in channel_last format\nUse buteo.aux_utils.channel_last_to_first and channel_first_to_last to convert if needed.</p>\n\n<p>Args:\n    arr (np.ndarray): A numpy array to be divided into patches.\n    tile_size (int): The size of each tile/patch, e.g., 64 for 64x64 tiles.\n    n_offsets (int=0): The desired number of offsets to be calculated.\n    border_check (bool=True): Whether or not to include border patches.</p>\n\n<p>Returns:\n    np.ndarray: The concatenate patches along axis 0. In the order (patches, y, x, channels)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">n_offsets</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">border_check</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.patches.predict_array", "modulename": "buteo.array.patches", "qualname": "predict_array", "kind": "function", "doc": "<p>Generate patches from an array. Also outputs the offsets and the shapes of the offsets. Only\nsuppors the prediction of single values in the rasters/arrays. </p>\n\n<p>NOTE: The produced patches passed to the callback are in channel_last format.</p>\n\n<p>Args:\n    arr (np.ndarray): A numpy array to be divided into patches.\n    callback (function): The callback function to be used for prediction. The callback function\n        must take a numpy array as input and return a numpy array as output.</p>\n\n<p>Keyword Args:\n    tile_size (int=64): The size of each tile/patch, e.g., 64 for 64x64 tiles.\n    n_offsets (int=1): The desired number of offsets to be calculated.\n    border_check (bool=True): Whether or not to include border patches.\n    merge_method (str=\"median\"): The method to use for merging the patches. Valid methods\n    are ['mad', 'median', 'mean', 'mode', \"min\", \"max\", \"olympic1\", \"olympic2\"]\n    edge_weighted (bool=True): Whether or not to weight the edges patches of patches less\n        than the central parts.\n    edge_distance (int=3): The distance from the edge to be weighted less. Usually good to\n        adjust this to your maximum convolution kernel size.</p>\n\n<p>Returns:\n    np.ndarray: The predicted array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">callback</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">64</span>,</span><span class=\"param\">\t<span class=\"n\">n_offsets</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">border_check</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">merge_method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;median&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">edge_weighted</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">edge_distance</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.patches.predict_array_pixel", "modulename": "buteo.array.patches", "qualname": "predict_array_pixel", "kind": "function", "doc": "<p>Predicts an array pixel by pixel.</p>\n\n<p>Args:\n    arr (np.ndarray): A numpy array to be divided into patches.\n    callback (function): The callback function to be used for prediction. The callback function\n        must take a numpy array as input and return a numpy array as output.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">callback</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.textures", "modulename": "buteo.array.textures", "kind": "module", "doc": "<h3 id=\"perform-morphological-operations-on-arrays-and-rasters\">Perform morphological operations on arrays and rasters.</h3>\n"}, {"fullname": "buteo.array.textures.texture_local_variance", "modulename": "buteo.array.textures", "qualname": "texture_local_variance", "kind": "function", "doc": "<p>Create a variance texture layer.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.textures.texture_local_median", "modulename": "buteo.array.textures", "qualname": "texture_local_median", "kind": "function", "doc": "<p>Create a median filtered array.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.textures.texture_local_blur", "modulename": "buteo.array.textures", "qualname": "texture_local_blur", "kind": "function", "doc": "<p>Apply a blurring filter. Default is a square linear distance weighted blur.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.textures.texture_local_mode", "modulename": "buteo.array.textures", "qualname": "texture_local_mode", "kind": "function", "doc": "<p>Apply a mode filter. Default is a circular filter with no distance decay.</p>\n\n<p>Args:\n    arr (np.ndarray): The array on which to calculate the filter.</p>\n\n<p>Keyword Args:\n    filter_size (int=5): The size of the kernel to use. filter_size x filter_size.\n    spherical (bool=True): If True, the filter applied will be weighted by a circle.\n    nodata (bool=False): Does the array contain nodata and should the values be left?\n    nodata_value (float=9999.0): If nodata is True, what value is nodata.\n    distance_weight (str='none'): How should the distance from the center be treated:\n        * \"none\": no distance weighing will be done.\n        * \"linear\": np.power((1 - decay), normed).\n        * \"sqrt\": np.power(np.sqrt((1 - decay)), normed).\n        * \"power\": np.power(np.power((1 - decay), 2), normed).\n        * \"log\": np.log(normed + 2).\n        * \"gaussian\": np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n    distance_decay (float=0.2): Rate of distance decay.\n    distance_sigma (float=1.0): The sigma to use for gaussian decay.</p>\n\n<p>Returns:\n    np.ndarray: The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;none&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.array.textures.texture_hole_dif", "modulename": "buteo.array.textures", "qualname": "texture_hole_dif", "kind": "function", "doc": "<p>Create a 'hole' filter, representing the difference between a pixel and its surrounding neighbourhood.</p>\n\n<p>Args:\n    arr (np.ndarray): The array on which to calculate the filter.</p>\n\n<p>Keyword Args:\n    filter_size (int=5): The size of the kernel to use. filter_size x filter_size.\n    spherical (bool=False): If True, the filter applied will be weighted by a circle.\n    nodata (bool=False): Does the array contain nodata and should the values be left?\n    nodata_value (float=9999.0): If nodata is True, what value is nodata.\n    distance_weight (str='linear'): How should the distance from the center be treated:\n        * \"none\": no distance weighing will be done.\n        * \"linear\": np.power((1 - decay), normed).\n        * \"sqrt\": np.power(np.sqrt((1 - decay)), normed).\n        * \"power\": np.power(np.power((1 - decay), 2), normed).\n        * \"log\": np.log(normed + 2).\n        * \"gaussian\": np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n    distance_decay (float=0.2): Rate of distance decay.\n    distance_sigma (float=1.0): The sigma to use for gaussian decay.</p>\n\n<p>Returns:\n    np.ndarray: The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo", "modulename": "buteo.eo", "kind": "module", "doc": "<p>Tools for working with sentinel data</p>\n"}, {"fullname": "buteo.eo.s1_preprocess", "modulename": "buteo.eo.s1_preprocess", "kind": "module", "doc": "<p>This module preprocesses Sentinel-1 data. Using SNAP GPT.</p>\n\n<p>TODO:\n    - Enable support for processing only VV or VH.\n    - Improve documentation</p>\n"}, {"fullname": "buteo.eo.s1_preprocess.s1_backscatter", "modulename": "buteo.eo.s1_preprocess", "qualname": "s1_backscatter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">zip_file</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span>,</span><span class=\"param\">\t<span class=\"n\">tmp_folder</span>,</span><span class=\"param\">\t<span class=\"n\">extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">epsg</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_nodata</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">speckle_filter</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">decibel</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">clean_tmp</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">gpt_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;~/snap/bin/gpt&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_utils", "modulename": "buteo.eo.s1_utils", "kind": "module", "doc": "<p>This module provides functions to ease the preprocessing of Sentinel 1 data\nand finding the GPT tools.</p>\n\n<p>TODO:\n    - Improve documentation</p>\n"}, {"fullname": "buteo.eo.s1_utils.s1_kml_to_bbox", "modulename": "buteo.eo.s1_utils", "qualname": "s1_kml_to_bbox", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_to_kml</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_utils.s1_get_metadata", "modulename": "buteo.eo.s1_utils", "qualname": "s1_get_metadata", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image_paths</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices", "modulename": "buteo.eo.s2_indices", "kind": "module", "doc": "<p>This module provides varoius indices for Sentinel 2 imagery.</p>\n\n<p>TODO:\n    Convert to numpy functions.\n    Handle resampling</p>\n"}, {"fullname": "buteo.eo.s2_indices.s2_index_chlre", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_chlre", "kind": "function", "doc": "<p>Red Edge Chlorophyll Index\nCalc: B05 / B08</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_rendvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_rendvi", "kind": "function", "doc": "<p>Red Edge NDVI\nCalc: (B08 - B06) / (B08 + B06)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_06</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_s2_rep", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_s2_rep", "kind": "function", "doc": "<p>Sentinel 2 Red Edge Position\nCalc: 705 + 35 * ((((B07 + B04) / 2) - B05) / (B06 - B05))</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_07</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_06</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ireci", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ireci", "kind": "function", "doc": "<p>Red Edge Chlorophyll Index\nCalc: (B07 - B04) * B06 / B05</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_07</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_06</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_mcari", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_mcari", "kind": "function", "doc": "<p>Modified Chlorophyll Absorption in Reflectance Index\nCalc: (B05 - B04) - 0.2 * (B05 - B03) * (B05 / B04)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_arvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_arvi", "kind": "function", "doc": "<p>Atmospherically Resistant Vegetation Index\nCalc: (B08 - b) / (B08 + b), b = 2 * B04 - B02</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_02</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_savi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_savi", "kind": "function", "doc": "<p>Soil Adjusted Vegetation Index\nCalc: ((B08 - B04) / ((B08 + B04) + 0.428)) * 1.856</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_msavi2", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_msavi2", "kind": "function", "doc": "<p>Modified Soil Adjusted Vegetation Index v2\nCalc: (2 * B08 + 1 - sqrt((2 * B08 + 1) ** 2) - 8 * (B08 - B04)) / 2</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_gndvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_gndvi", "kind": "function", "doc": "<p>Green Normalized Difference Vegetation Index\nCalc: (B08 - B03) / (B08 + B03)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndvi", "kind": "function", "doc": "<p>Normalized Difference Vegetation Index\nCalc: (B08 - B04) / (B08 + B04)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_moist", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_moist", "kind": "function", "doc": "<p>Soil Moisture Index\nCalc: (B8A - B11) / (B8A + B11)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_8A</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndwi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndwi", "kind": "function", "doc": "<p>Normalized Difference Water Index\nCalc: (B08 - B11) / (B08 + B11)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndwi_v2", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndwi_v2", "kind": "function", "doc": "<p>Normalized Difference Water Index v2\nCalc: (B03 - B08) / (B03 + B08)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_nbr", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_nbr", "kind": "function", "doc": "<p>Normalized Burn Ratio\nCalc: (B08 - B12) / (B08 + B12)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_12</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_nvei", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_nvei", "kind": "function", "doc": "<p>Non-elimination vegetation index\nCalc: (B02 - B04) / (B08 + B04)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_02</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_nbai", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_nbai", "kind": "function", "doc": "<p>Built-up area index\nCalc: (B12 - d) / (B12 + d), d = B08 / B02</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_02</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_12</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_brba", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_brba", "kind": "function", "doc": "<p>Band ratio for built-up areas\nCalc: (B03 / B08)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndbi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndbi", "kind": "function", "doc": "<p>Normalised difference built-up index\nCalc: (B11 - B08) / (B11 + B08)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_blfei", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_blfei", "kind": "function", "doc": "<p>Built-up features extraction\nCalc: (bix - B11) / (bix + B11), bix = (B03 + B04 + B12) / 3</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_12</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ibi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ibi", "kind": "function", "doc": "<p>Built-up features extraction\nCalc: (ndbi - ((savi + ndwi2) / 2)) / (ndbi + ((savi + ndwi2) / 2))\n    savi = ((B08 - B04) / ((B08 + B04) + 0.428)) * 1.856\n    ndwi2 = (B03 - B08) / (B03 + B08)\n    ndbi = (B11 - B08) / (B11 + B08</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_utils", "modulename": "buteo.eo.s2_utils", "kind": "module", "doc": "<p>This module contains utility functions to work with sentinel 2 data.</p>\n"}, {"fullname": "buteo.eo.s2_utils.s2_l2a_get_bands", "modulename": "buteo.eo.s2_utils", "qualname": "s2_l2a_get_bands", "kind": "function", "doc": "<p>Get the bands from a sentinel 2 L2A product.</p>\n\n<p>Args:\n    zip_or_safe_folder (str): Path to the zip file or SAFE folder.</p>\n\n<p>Key Args:\n    zipfile (bool=True): If True, the zip file is used. If False, the SAFE folder is used.</p>\n\n<p>Returns:\n    dict: Dictionary with the bands.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zip_or_safe_folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">zipfile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_utils.s2_l2a_get_metadata", "modulename": "buteo.eo.s2_utils", "qualname": "s2_l2a_get_metadata", "kind": "function", "doc": "<p>Get metadata from the SAFE folder or the zip file.</p>\n\n<p>Args:\n    zip_or_safe_folder (str): Path to the zip file or the SAFE folder.</p>\n\n<p>Keyword Args:\n    zipfile (bool): If True, the zip file is used. If False, the SAFE folder is used.</p>\n\n<p>Returns:\n    dict: Dictionary with the metadata.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zip_or_safe_folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">zipfile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster", "modulename": "buteo.raster", "kind": "module", "doc": "<p>Make simple work of raster analysis!</p>\n"}, {"fullname": "buteo.raster.align", "modulename": "buteo.raster.align", "kind": "module", "doc": "<h3 id=\"align-rasters\">Align rasters</h3>\n\n<p>Functions to align a series of rasters to a master or a reference.</p>\n"}, {"fullname": "buteo.raster.align.align_rasters_to_reference", "modulename": "buteo.raster.align", "qualname": "align_rasters_to_reference", "kind": "function", "doc": "<p>Aligns a series of rasters to a reference.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (list of str):\nA list of rasters to align.</li>\n<li><strong>reference</strong> (str or gdal.Dataset):\nPath to the reference raster or vector.</li>\n<li><strong>out_path</strong> (str or list of str, optional):\nPaths to the output. If not provided, the output will be in-memory rasters.</li>\n<li><strong>resample_alg</strong> (str, optional):\nResampling algorithm to use. Default: \"nearest\".</li>\n<li><strong>target_nodata</strong> (int or float, optional):\nNodata value to use for the output rasters.</li>\n<li><strong>overwrite</strong> (bool, optional):\nOverwrite existing files. Default: True.</li>\n<li><strong>creation_options</strong> (list, optional):\nList of creation options.</li>\n<li><strong>prefix</strong> (str, optional):\nPrefix to add to the output file name. Default: \"\".</li>\n<li><strong>suffix</strong> (str, optional):\nSuffix to add to the output file name. Default: \"\".</li>\n<li><strong>ram</strong> (str or int, optional):\nAmount of RAM to use in MB. If \"auto\", the amount of RAM will be determined automatically.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[str]</strong>: A list of paths to the aligned rasters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">target_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">ram</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.align.find_best_reference", "modulename": "buteo.raster.align", "qualname": "find_best_reference", "kind": "function", "doc": "<p>Find the best reference raster for aligning a list of rasters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]]):\nList of rasters to align.</li>\n<li><strong>method</strong> (str):\nBounding box method to use for finding the best reference.\nOptions include: \"reference\", \"intersection\", and \"union\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Path to the best reference raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.align.align_rasters", "modulename": "buteo.raster.align", "qualname": "align_rasters", "kind": "function", "doc": "<p>Aligns rasters either to a reference raster or to each other using one of three methods:\nreference, intersection, or union.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]]):\nThe rasters to align.</li>\n<li><strong>out_path</strong> (List[str] or str, optional):\nThe output path(s), default: None</li>\n<li><strong>reference</strong> (Str or gdal.Dataset, optional):\nThe reference raster to align to, default: None</li>\n<li><strong>method</strong> (str, optional):\nThe method to use, default: \"reference\" [reference, intersection, union]</li>\n<li><strong>resample_alg</strong> (str, optional):\nThe resampling algorithm to use, default: \"nearest\"</li>\n<li><strong>overwrite</strong> (bool, optional):\nWhether to overwrite existing files, default: True</li>\n<li><strong>creation_options</strong> (Optional[List[str]], optional):\nThe creation options to use, default: None</li>\n<li><strong>prefix</strong> (str, optional):\nThe prefix to add to the output file name, default: \"\"</li>\n<li><strong>suffix</strong> (str, optional):\nThe suffix to add to the output file name, default: \"\"</li>\n<li><strong>ram</strong> (Union[str, int], optional):\nAmount of RAM to use in MB. If \"auto\", the amount of RAM will be determined automatically.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[str]</strong>: The aligned rasters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;reference&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">target_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">ram</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.borders", "modulename": "buteo.raster.borders", "kind": "module", "doc": "<h3 id=\"handle-and-create-borders-on-rasters\">Handle and create borders on rasters.</h3>\n\n<p>Functions to add or remove borders from rasters.\nUseful for warped satellite images and for proximity searching.</p>\n"}, {"fullname": "buteo.raster.borders.add_border_to_raster", "modulename": "buteo.raster.borders", "qualname": "add_border_to_raster", "kind": "function", "doc": "<p>Add a border to a raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset]):\nThe input raster.</li>\n<li><strong>out_path</strong> (Optional[str], optional):\nThe output path. If None, the output will be a memory raster.\nDefault: None</li>\n<li><strong>border_size</strong> (int, optional):\nThe size of the border. Default: 100</li>\n<li><strong>border_size_unit</strong> (str, optional):\nThe unit of the border size. Default: 'px'</li>\n<li><strong>border_value</strong> (int, optional):\nThe value of the border. Default: 0</li>\n<li><strong>allow_lists</strong> (bool, optional):\nIf True, lists of rasters will be allowed. Default: True</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf True, the output raster will be overwritten. Default: True</li>\n<li><strong>creation_options</strong> (Optional[List[str]], optional):\nCreation options for the output raster. Default is None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[str, gdal.Dataset]</strong>: The output raster with added borders.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">border_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">border_size_unit</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;px&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">border_value</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.clip", "modulename": "buteo.raster.clip", "kind": "module", "doc": "<h3 id=\"clip-rasters\">Clip rasters</h3>\n\n<p>Clips a raster using a vector geometry or the extents of a raster.</p>\n"}, {"fullname": "buteo.raster.clip.clip_raster", "modulename": "buteo.raster.clip", "qualname": "clip_raster", "kind": "function", "doc": "<p>Clips a raster(s) using a vector geometry or the extents of a raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (str or gdal.Dataset or list of str/gdal.Dataset):\nThe raster(s) to clip.</li>\n<li><strong>clip_geom</strong> (str or ogr.DataSource or gdal.Dataset):\nThe geometry to use to clip the raster.</li>\n<li><strong>out_path</strong> (str or list or None, optional):\nThe path(s) to save the clipped raster to. If None, a memory raster is created. Default: None.</li>\n<li><strong>resample_alg</strong> (str, optional):\nThe resampling algorithm to use. Options include: nearest, bilinear, cubic, cubicspline, lanczos, \naverage, mode, max, min, median, q1, q3, sum, rms. Default: \"nearest\".</li>\n<li><strong>crop_to_geom</strong> (bool, optional):\nIf True, the output raster will be cropped to the extent of the clip geometry. Default: True.</li>\n<li><strong>adjust_bbox</strong> (bool, optional):\nIf True, the output raster will have its bbox adjusted to match the clip geometry. Default: False.</li>\n<li><strong>all_touch</strong> (bool, optional):\nIf true, all pixels touching the clipping geometry will be included. Default: False.</li>\n<li><strong>to_extent</strong> (bool, optional):\nIf True, the output raster will be cropped to the extent of the clip geometry. Default: False.</li>\n<li><strong>prefix</strong> (str, optional):\nThe prefix to use for the output raster. Default: \"\".</li>\n<li><strong>suffix</strong> (str, optional):\nThe suffix to use for the output raster. Default: \"\".</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf True, the output raster will be overwritten if it already exists. Default: True.</li>\n<li><strong>creation_options</strong> (list or None, optional):\nA list of creation options to pass to gdal. Default: None.</li>\n<li><strong>dst_nodata</strong> (int or float or None, optional):\nThe nodata value to use for the output raster. Default: \"infer\".</li>\n<li><strong>src_nodata</strong> (int or float or None, optional):\nThe nodata value to use for the input raster. Default: \"infer\".</li>\n<li><strong>layer_to_clip</strong> (int or str, optional):\nThe layer ID or name in the vector to use for clipping. Default: 0.</li>\n<li><strong>verbose</strong> (int, optional):\nThe verbosity level. Default: 0.</li>\n<li><strong>add_uuid</strong> (bool, optional):\nIf True, a UUID will be added to the output raster. Default: False.</li>\n<li><strong>ram</strong> (str or float or int, optional):\nThe amount of RAM to use for the operation. Default: \"auto\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str or list</strong>: A string or list of strings representing the path(s) to the clipped raster(s).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">crop_to_geom</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">adjust_bbox</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">all_touch</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">to_extent</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">src_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">layer_to_clip</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ram</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster", "modulename": "buteo.raster.core_raster", "kind": "module", "doc": "<h3 id=\"basic-io-functions-for-working-with-rasters\">Basic IO functions for working with Rasters</h3>\n\n<p>This module does standard raster operations related to read, write, and metadata.</p>\n"}, {"fullname": "buteo.raster.core_raster.open_raster", "modulename": "buteo.raster.core_raster", "qualname": "open_raster", "kind": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]]):\nA path to a raster or a GDAL dataframe.</li>\n<li><strong>writeable</strong> (bool, optional):\nIf True, the raster is opened in write mode. Default: True.</li>\n<li><strong>allow_lists</strong> (bool, optional):\nIf True, the input can be a list of rasters. Otherwise,\nonly a single raster is allowed. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[gdal.Dataset, List[gdal.Dataset]]</strong>: A gdal.Dataset or a list of gdal.Datasets.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">writeable</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.get_projection", "modulename": "buteo.raster.core_raster", "qualname": "get_projection", "kind": "function", "doc": "<p>Get the projection from a dataset, either as WKT or osr.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (str or gdal.Dataset):\nA path to a raster or a gdal.Dataset.</li>\n<li><strong>wkt</strong> (bool, optional):\nIf True, returns the projection as WKT. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: The projection of the input raster in the specified format.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">wkt</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_to_metadata", "modulename": "buteo.raster.core_raster", "qualname": "raster_to_metadata", "kind": "function", "doc": "<p>Reads metadata from a raster dataset or a list of raster datasets, and returns a dictionary or a list of dictionaries\ncontaining metadata information for each raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (str or gdal.Dataset or list):\nA path to a raster or a gdal.Dataset, or a list of paths to rasters.</li>\n<li><strong>allow_lists</strong> (bool, optional):\nIf True, allows the input to be a list of rasters. Otherwise, only a single raster is allowed. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dict or list of dict</strong>: A dictionary or a list of dictionaries containing metadata information for each raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_are_aligned", "modulename": "buteo.raster.core_raster", "qualname": "rasters_are_aligned", "kind": "function", "doc": "<p>Verifies whether a list of rasters are aligned.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (list):\nA list of rasters, either in gdal.Dataset or a string referring to the dataset.</li>\n<li><strong>same_extent</strong> (bool, optional):\nIf True, all the rasters should have the same extent. Default: True.</li>\n<li><strong>same_dtype</strong> (bool, optional):\nIf True, all the rasters should have the same data type. Default: False.</li>\n<li><strong>same_nodata</strong> (bool, optional):\nIf True, all the rasters should have the same nodata value. Default: False.</li>\n<li><strong>threshold</strong> (float, optional):\nThe threshold for the difference between the rasters. Default: 0.001.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if rasters are aligned and optional parameters are True, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">same_extent</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">same_dtype</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">same_nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_has_nodata", "modulename": "buteo.raster.core_raster", "qualname": "raster_has_nodata", "kind": "function", "doc": "<p>Verifies whether a raster has any nodata values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (str or gdal.Dataset):\nA raster, either in gdal.Dataset or a string referring to the dataset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if raster has nodata values, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_have_nodata", "modulename": "buteo.raster.core_raster", "qualname": "rasters_have_nodata", "kind": "function", "doc": "<p>Verifies whether a list of rasters have any nodata values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (list):\nA list of rasters, either in gdal.Dataset or a string referring to the dataset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if all rasters have nodata values, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_have_same_nodata", "modulename": "buteo.raster.core_raster", "qualname": "rasters_have_same_nodata", "kind": "function", "doc": "<p>Verifies whether a list of rasters have the same nodata values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (list):\nA list of rasters, either in gdal.Dataset or a string referring to the dataset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if all rasters have the same nodata value, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.get_first_nodata_value", "modulename": "buteo.raster.core_raster", "qualname": "get_first_nodata_value", "kind": "function", "doc": "<p>Gets the first nodata value from a raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (str or gdal.Dataset):\nThe raster to get the nodata value from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float or None</strong>: The nodata value if found, or None if not found.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.count_bands_in_rasters", "modulename": "buteo.raster.core_raster", "qualname": "count_bands_in_rasters", "kind": "function", "doc": "<p>Counts the number of bands in a list of rasters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (list):\nA list of rasters, either in gdal.Dataset or a string referring to the dataset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>int</strong>: The number of bands in the rasters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_to_array", "modulename": "buteo.raster.core_raster", "qualname": "raster_to_array", "kind": "function", "doc": "<p>Converts a raster or a list of rasters into a NumPy array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (gdal.Dataset or str or list):\nRaster(s) to convert.</li>\n<li><strong>bands</strong> (list or str or int, optional):\nBands from the raster to convert to a numpy array. Can be \"all\", an int,\nor a list of integers, or a single integer. Please note that bands are 1-indexed.\nDefault: \"all\".</li>\n<li><strong>masked</strong> (bool or str, optional):\nIf the array contains nodata values, determines whether the resulting\narray should be a masked numpy array or a regular numpy array. If \"auto\",\nthe array will be masked only if the raster has nodata values. Default: \"auto\".</li>\n<li><strong>filled</strong> (bool, optional):\nIf the array contains nodata values, determines whether the resulting\narray should be a filled numpy array or a masked array. Default: False.</li>\n<li><strong>fill_value</strong> (int or float, optional):\nValue to fill the array with if filled is True. If None, the nodata value\nof the raster is used. Default: None.</li>\n<li><strong>bbox</strong> (list, optional):\nA list of <code>[xmin, xmax, ymin, ymax]</code> to use as the extent of the raster.\nUses coordinates and the OGR format. Default: None.</li>\n<li><strong>pixel_offsets</strong> (list or tuple, optional):\nA list of <code>[x_offset, y_offset, x_size, y_size]</code> to use as the extent of the\nraster. Uses pixel offsets and the OGR format. Default: None.</li>\n<li><strong>cast</strong> (str or dtype, optional):\nA type to cast the array to. If None, the array is not cast. It is only cast\nif the array is not already the dtype. Default: None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A numpy array in the 3D channel-last format.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the raster is not a valid raster.</li>\n<li><strong>ValueError</strong>: If the bands are not valid.</li>\n<li><strong>ValueError</strong>: If the masked parameter is not valid.</li>\n<li><strong>ValueError</strong>: If both bbox and pixel_offsets are provided.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<p><code>Example 1: Convert a raster to a numpy array.</code></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">raster</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;/path/to/raster/raster.tif&quot;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Convert a raster to a numpy array</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span><span class=\"n\">raster</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">dtype</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"p\">(</span><span class=\"s1\">&#39;uint8&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p><code>Example 2: Convert a raster to a numpy array with a specific band.</code></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">raster</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;/path/to/raster/raster.tif&quot;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Convert a raster to a numpy array</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span><span class=\"n\">raster</span><span class=\"p\">,</span> <span class=\"n\">bands</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">dtype</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"p\">(</span><span class=\"s1\">&#39;uint8&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p><code>Example 3: Convert a list of rasters to a numpy array with a specific</code></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># band and a specific type and filled.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">from</span> <span class=\"nn\">glob</span> <span class=\"kn\">import</span> <span class=\"n\">glob</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">FOLDER</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;/path/to/folder&quot;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">rasters</span> <span class=\"o\">=</span> <span class=\"n\">glob</span><span class=\"p\">(</span><span class=\"n\">FOLDER</span> <span class=\"o\">+</span> <span class=\"s2\">&quot;/*.tif&quot;</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">rasters</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"mi\">10</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Convert rasters to a numpy array</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>     <span class=\"n\">rasters</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>     <span class=\"n\">bands</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">],</span>\n<span class=\"o\">...</span>     <span class=\"n\">cast</span><span class=\"o\">=</span><span class=\"s2\">&quot;float32&quot;</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>     <span class=\"n\">filled</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>     <span class=\"n\">fill_value</span><span class=\"o\">=</span><span class=\"mf\">0.0</span><span class=\"p\">,</span>\n<span class=\"o\">...</span> <span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># This raises an error if the 10 rasters are not aligned.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"n\">dtype</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">),</span> <span class=\"n\">dtype</span><span class=\"p\">(</span><span class=\"s1\">&#39;float32&#39;</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;all&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">masked</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filled</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">fill_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bbox</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_offsets</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cast</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_to_array_chunks", "modulename": "buteo.raster.core_raster", "qualname": "raster_to_array_chunks", "kind": "class", "doc": "<p>A class for reading raster data in chunks. The array will be split into x and y\namount of chunks in the x and y directions. The output will be the read array\nand the offsets of the chunk in the raster. The offset can be used to reconstitute\nthe array into the original raster or a new raster representing the chunk,\nusing the <code>array_to_raster()</code> function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[gdal.Dataset, str, List[Union[str, gdal.Dataset]]]):\nThe raster to read.</li>\n<li><strong>chunks</strong> (int):\nThe number of chunks to read. The area is chunked in way that ensures\nthat the chunks are as square as possible. Default: 1.</li>\n<li><strong>overlap</strong> (int, optional):\nThe number of pixels to overlap. Default: 0.</li>\n<li><strong>overlap_y</strong> (int, optional):\nThe number of pixels to overlap in the y direction. Default: 0.</li>\n<li><strong>bands</strong> (list or str or int, optional):\nThe bands to read. Can be \"all\", an int, or a list of integers, or a single\ninteger. Please note that bands are 1-indexed. Default: \"all\".</li>\n<li><strong>masked</strong> (bool or str, optional):\nWhether to return a masked array. Default: \"auto\".</li>\n<li><strong>filled</strong> (bool, optional):\nWhether to fill masked values. Default: False.</li>\n<li><strong>fill_value</strong> (int or float, optional):\nThe value to fill masked values with. Default: None.</li>\n<li><strong>cast</strong> (type or str, optional):\nThe data type to cast the output to. Default: None.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>generator</strong>: A generator that yields the raster data in chunks and the offsets of the chunk\nin the raster in a tuple.</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Read a raster into array via chunks.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">raster</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;/path/to/raster/raster.tif&quot;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">shape</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_metadata</span><span class=\"p\">(</span><span class=\"n\">raster</span><span class=\"p\">)[</span><span class=\"s2\">&quot;shape&quot;</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">shape</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">chunk</span><span class=\"p\">,</span> <span class=\"n\">offsets</span> <span class=\"ow\">in</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array_chunks</span><span class=\"p\">(</span><span class=\"n\">raster</span><span class=\"p\">,</span> <span class=\"n\">chunks</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">):</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">chunk</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">,</span> <span class=\"n\">offsets</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span>     <span class=\"p\">(</span><span class=\"mi\">25</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">),</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n"}, {"fullname": "buteo.raster.core_raster.raster_to_array_chunks.__init__", "modulename": "buteo.raster.core_raster", "qualname": "raster_to_array_chunks.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">chunks</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overlap</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;all&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">masked</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filled</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">fill_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">cast</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"}, {"fullname": "buteo.raster.core_raster.array_to_raster", "modulename": "buteo.raster.core_raster", "qualname": "array_to_raster", "kind": "function", "doc": "<p>Turns a NumPy array into a GDAL dataset or exported as a raster using a reference raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>array</strong> (np.ndarray):\nThe numpy array to convert.</li>\n<li><strong>reference</strong> (str or gdal.Dataset):\nThe reference raster to use for the output.</li>\n<li><strong>out_path</strong> (path, optional):\nThe destination to save to. Default: None.</li>\n<li><strong>set_nodata</strong> (bool or float or int, optional):\nCan be set to:\n    - \"arr\": The nodata value will be the same as the NumPy array.\n    - \"ref\": The nodata value will be the same as the reference raster.\n    - value: The nodata value will be the value provided. Default: \"arr\".</li>\n<li><strong>allow_mismatches</strong> (bool, optional):\nIf True, the array can have a different shape than the reference raster.\nDefault: False.</li>\n<li><strong>pixel_offsets</strong> (list or tuple, optional):\nIf provided, the array will be written to the reference raster at the\nspecified pixel offsets. The list should be in the format [x_offset, y_offset, x_size, y_size].\nDefault: None.</li>\n<li><strong>bbox</strong> (list, optional):\nIf provided, the array will be written to the reference raster at the specified\nbounding box. The list should be in the format [min_x, min_y, max_x, max_y]. Default: None.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf the file exists, should it be overwritten? Default: True.</li>\n<li><strong>creation_options</strong> (list, optional):\nList of GDAL creation options. Default: [\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\",\n\"BIGTIFF=YES\", \"COMPRESS=LZW\"].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: The filepath to the newly created raster(s).</li>\n</ul>\n\n<h6 id=\"examples\">Examples</h6>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"c1\"># Create a raster from a numpy array.</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">raster</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;/path/to/raster/raster.tif&quot;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span><span class=\"n\">raster</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">array</span> <span class=\"o\">**</span> <span class=\"mi\">2</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">out_path</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">array_to_raster</span><span class=\"p\">(</span>\n<span class=\"o\">...</span>     <span class=\"n\">array</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>     <span class=\"n\">reference</span><span class=\"o\">=</span><span class=\"n\">raster</span><span class=\"p\">,</span>\n<span class=\"o\">...</span>     <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"s2\">&quot;/path/to/new/new_raster.tif&quot;</span>\n<span class=\"o\">...</span> <span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> \n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">out_path</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"s2\">&quot;/path/to/new/new_raster.tif&quot;</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">set_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;arr&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">allow_mismatches</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_offsets</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bbox</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_set_datatype", "modulename": "buteo.raster.core_raster", "qualname": "raster_set_datatype", "kind": "function", "doc": "<p>Converts the datatype of a raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (str or gdal.Dataset or list):\nThe input raster(s) for which the datatype will be changed.</li>\n<li><strong>dtype</strong> (str):\nThe target datatype for the output raster(s).</li>\n<li><strong>out_path</strong> (path or list, optional):\nThe output location for the processed raster(s). Default: None.</li>\n<li><strong>overwrite</strong> (bool, optional):\nDetermines whether to overwrite existing files with the same name. Default: True.</li>\n<li><strong>allow_lists</strong> (bool, optional):\nAllows processing multiple rasters as a list. If set to False, only single rasters are accepted.\nDefault: True.</li>\n<li><strong>creation_options</strong> (list, optional):\nA list of GDAL creation options for the output raster(s). Default is\n[\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\", \"BIGTIFF=YES\", \"COMPRESS=LZW\"].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str or list</strong>: The filepath(s) of the newly created raster(s) with the specified datatype.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.stack_rasters", "modulename": "buteo.raster.core_raster", "qualname": "stack_rasters", "kind": "function", "doc": "<p>Stacks a list of aligned rasters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (list):\nList of rasters to stack.</li>\n<li><strong>out_path</strong> (str or None, optional):\nThe destination to save the output raster. Default: None.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf the file exists, should it be overwritten? Default: True.</li>\n<li><strong>dtype</strong> (str, optional):\nThe data type of the output raster. Default: None.</li>\n<li><strong>creation_options</strong> (list, optional):\nA list of GDAL creation options for the output raster. Default is\n[\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\", \"BIGTIFF=YES\", \"COMPRESS=LZW\"].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str or list</strong>: The filepath(s) to the newly created raster(s).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.stack_rasters_vrt", "modulename": "buteo.raster.core_raster", "qualname": "stack_rasters_vrt", "kind": "function", "doc": "<p>Stacks a list of rasters into a virtual raster (.vrt).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (list):\nList of rasters to stack.</li>\n<li><strong>out_path</strong> (str):\nThe destination to save the output raster.</li>\n<li><strong>separate</strong> (bool, optional):\nIf the raster bands should be separated. Default: True.</li>\n<li><strong>resample_alg</strong> (str, optional):\nThe resampling algorithm to use. Default: 'nearest'.</li>\n<li><strong>nodata_src</strong> (float, optional):\nThe NoData value to use for the source rasters. Default: None.</li>\n<li><strong>nodata_VRT</strong> (float, optional):\nThe NoData value to use for the VRT raster. Default: None.</li>\n<li><strong>nodata_hide</strong> (bool, optional):\nIf the NoData value should be hidden. Default: None.</li>\n<li><strong>options</strong> (list, optional):\nList of VRT options for GDAL. Default: None.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf the file exists, should it be overwritten? Default: True.</li>\n<li><strong>reference</strong> (str, optional):\nThe reference raster to use. Default: None.</li>\n<li><strong>creation_options</strong> (list, optional):\nA list of GDAL creation options for the output raster. Default is\n[\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\", \"BIGTIFF=YES\", \"COMPRESS=LZW\"].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: The filepath to the newly created VRT raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">separate</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_src</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_VRT</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_hide</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_intersect", "modulename": "buteo.raster.core_raster", "qualname": "rasters_intersect", "kind": "function", "doc": "<p>Checks if two rasters intersect using their latlong boundaries.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster1</strong> (str or gdal.Dataset):\nThe first raster.</li>\n<li><strong>raster2</strong> (str or gdal.Dataset):\nThe second raster.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if the rasters intersect, False otherwise.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">raster2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_intersection", "modulename": "buteo.raster.core_raster", "qualname": "rasters_intersection", "kind": "function", "doc": "<p>Gets the latlng intersection of two rasters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster1</strong> (str or gdal.Dataset):\nThe first raster.</li>\n<li><strong>raster2</strong> (str or gdal.Dataset):\nThe second raster.</li>\n<li><strong>return_as_vector</strong> (bool, optional):\nIf True, the intersection will be returned as a vector. Default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>tuple or ogr.Geometry</strong>: If return_as_vector is False, returns a tuple <code>(xmin, ymin, xmax, ymax)</code> representing\nthe intersection of the two rasters. If return_as_vector is True, returns an ogr.Geometry\nobject representing the intersection.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">raster2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">return_as_vector</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.get_overlap_fraction", "modulename": "buteo.raster.core_raster", "qualname": "get_overlap_fraction", "kind": "function", "doc": "<p>Get the fraction of the overlap between two rasters.\n(e.g. 0.9 for mostly overlapping rasters)</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster1</strong> (str or gdal.Dataset):\nThe first raster (master).</li>\n<li><strong>raster2</strong> (str or gdal.Dataset):\nThe second raster.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: A value between 0.0 and 1.0 representing the degree of overlap between the two rasters.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">raster2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.create_empty_raster", "modulename": "buteo.raster.core_raster", "qualname": "create_empty_raster", "kind": "function", "doc": "<p>Create an empty raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>out_path</strong> (str, optional):\nThe output path. If None, a temporary file will be created.</li>\n<li><strong>width</strong> (int, optional):\nThe width of the raster in pixels. Default: 100.</li>\n<li><strong>height</strong> (int, optional):\nThe height of the raster in pixels. Default: 100.</li>\n<li><strong>pixel_size</strong> (int or float or list or tuple, optional):\nThe pixel size in units of the projection. Default: 10.0.</li>\n<li><strong>bands</strong> (int, optional):\nThe number of bands in the raster. Default: 1.</li>\n<li><strong>dtype</strong> (str, optional):\nThe data type of the raster. Default: \"uint8\".</li>\n<li><strong>x_min</strong> (int or float, optional):\nThe x coordinate of the top left corner of the raster. Default: 0.0.</li>\n<li><strong>y_max</strong> (int or float, optional):\nThe y coordinate of the top left corner of the raster. Default: 0.0.</li>\n<li><strong>nodata_value</strong> (int or float or None, optional):\nThe nodata value of the raster. Default: None.</li>\n<li><strong>projection</strong> (int or str or gdal.Dataset or ogr.DataSource or osr.SpatialReference, optional):\nThe projection of the raster. Default: \"EPSG:3857\".</li>\n<li><strong>creation_options</strong> (list or None, optional):\nA list of creation options. Default: None.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf True, overwrite the output file if it exists. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: The path to the output raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;uint8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">x_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">y_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">osr</span><span class=\"o\">.</span><span class=\"n\">SpatialReference</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;EPSG:3857&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.create_raster_from_array", "modulename": "buteo.raster.core_raster", "qualname": "create_raster_from_array", "kind": "function", "doc": "<p>Create a raster from a numpy array.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>arr</strong> (np.ndarray):\nThe array to convert to a raster.</li>\n<li><strong>out_path</strong> (str, optional):\nThe output path. If None, a temporary file will be created.</li>\n<li><strong>pixel_size</strong> (int or float or list or tuple, optional):\nThe pixel size of the output raster. Default: 10.0.</li>\n<li><strong>x_min</strong> (int or float, optional):\nThe x coordinate of the top left corner of the output raster. Default: 0.0.</li>\n<li><strong>y_max</strong> (int or float, optional):\nThe y coordinate of the top left corner of the output raster. Default: 0.0.</li>\n<li><strong>projection</strong> (int or str or gdal.Dataset or ogr.DataSource or osr.SpatialReference, optional):\nThe projection of the output raster. Default: \"EPSG:3857\".</li>\n<li><strong>creation_options</strong> (list or None, optional):\nThe creation options for the output raster. Default: None.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf True, the output raster will be overwritten if it already exists. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: The path to the output raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>,</span><span class=\"param\">\t<span class=\"n\">x_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">y_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">osr</span><span class=\"o\">.</span><span class=\"n\">SpatialReference</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;EPSG:3857&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.create_grid_with_coordinates", "modulename": "buteo.raster.core_raster", "qualname": "create_grid_with_coordinates", "kind": "function", "doc": "<p>Create a grid of coordinates from a raster. Format is (x, y, xy).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (str or gdal.Dataset):\nThe raster to create the grid from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>np.ndarray</strong>: A NumPy array of shape (x, y, xy-coordinates).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.mosaic_rasters", "modulename": "buteo.raster.core_raster", "qualname": "mosaic_rasters", "kind": "function", "doc": "<p>NOT YET IMPLEMENTED: Mosaic a list of rasters into a single raster.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster_paths</strong> (str or list):\nThe list of rasters to mosaic.</li>\n<li><strong>out_path</strong> (str, optional):\nThe output path. If None, a temporary file will be created.</li>\n<li><strong>creation_options</strong> (list or None, optional):\nThe creation options for the output raster.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf True, the output raster will be overwritten if it already exists. Default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster_paths</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.split_shape_into_offsets", "modulename": "buteo.raster.core_raster", "qualname": "split_shape_into_offsets", "kind": "function", "doc": "<p>Split a shape into offsets. Usually used for splitting an image into offsets to reduce RAM needed.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>shape</strong> (tuple or list):\nThe shape to split into offsets. (height, width, ...)</li>\n<li><strong>offsets_x</strong> (int, optional):\nThe number of offsets to split the shape into in the x-direction. Default: 2.</li>\n<li><strong>offsets_y</strong> (int, optional):\nThe number of offsets to split the shape into in the y-direction. Default: 2.</li>\n<li><strong>overlap_x</strong> (int, optional):\nThe number of pixels to overlap in the x-direction. Default: 0.</li>\n<li><strong>overlap_y</strong> (int, optional):\nThe number of pixels to overlap in the y-direction. Default: 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>list</strong>: The offsets. <code>[x_offset, y_offset, x_size, y_size]</code></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>,</span><span class=\"param\">\t<span class=\"n\">overlap_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">overlap_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.get_chunk_offsets", "modulename": "buteo.raster.core_raster", "qualname": "get_chunk_offsets", "kind": "function", "doc": "<p>Calculate chunk offsets for dividing an image into a specified number of chunks with minimal circumference.</p>\n\n<p>The function finds the optimal configuration of chunks to minimize the circumference and ensure the whole image\nis captured.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>image_shape</strong> (Tuple[int, int]):\nA tuple containing the height and width of the image. (Height, Width)</li>\n<li><strong>num_chunks</strong> (int):\nThe number of chunks to divide the image into.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[Tuple[int, int, int, int]]</strong>: A list of tuples, each containing the chunk offsets and dimensions in the format: <code>(x_start, y_start, x_pixels, y_pixels)</code>.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the number of chunks is too high for the given image size.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">image_shape</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">num_chunks</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">overlap</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.dem", "modulename": "buteo.raster.dem", "kind": "module", "doc": "<p>Slope, aspect, hillshade, and other DEM functions.</p>\n"}, {"fullname": "buteo.raster.dem.raster_dem_to_slope", "modulename": "buteo.raster.dem", "qualname": "raster_dem_to_slope", "kind": "function", "doc": "<p>Slope in percent.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_raster</strong> (str or gdal.Dataset):\nPath to input raster or gdal.Dataset.</li>\n<li><strong>output_raster</strong> (str):\nPath to output raster.</li>\n<li><strong>slope_format</strong> (str, optional):\n\"percent\" or \"degree\", by default \"percent\".</li>\n<li><strong>z_factor</strong> (float, optional):\nZ factor for slope calculation, by default 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Path to output raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">output_raster</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">slope_format</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;percent&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">z_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.dem.raster_dem_to_aspect", "modulename": "buteo.raster.dem", "qualname": "raster_dem_to_aspect", "kind": "function", "doc": "<p>Aspect in degrees.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_raster</strong> (str or gdal.Dataset):\nPath to input raster or gdal.Dataset.</li>\n<li><strong>output_raster</strong> (str):\nPath to output raster.</li>\n<li><strong>zero_for_flat</strong> (bool, optional):\nIf True, set aspect to 0 for flat areas, by default False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Path to output raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">output_raster</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">zero_for_flat</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.dem.raster_dem_to_hillshade", "modulename": "buteo.raster.dem", "qualname": "raster_dem_to_hillshade", "kind": "function", "doc": "<p>Hillshade in degrees.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_raster</strong> (str or gdal.Dataset):\nPath to input raster or gdal.Dataset.</li>\n<li><strong>output_raster</strong> (str):\nPath to output raster.</li>\n<li><strong>z_factor</strong> (float, optional):\nZ factor for hillshade calculation, by default 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Path to output raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">output_raster</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">z_factor</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.dem.raster_dem_to_orientation", "modulename": "buteo.raster.dem", "qualname": "raster_dem_to_orientation", "kind": "function", "doc": "<p>Normalised orientation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_raster</strong> (str or gdal.Dataset):\nPath to input raster or gdal.Dataset.</li>\n<li><strong>output_raster</strong> (str):\nPath to output raster.</li>\n<li><strong>include_height</strong> (bool, optional):\nIf True, include height in orientation calculation, by default False.</li>\n<li><strong>height_normalisation</strong> (bool, optional):\nIf True, normalise height to 0-1, by default False.</li>\n<li><strong>height_normalisation_value</strong> (float, optional):\nValue to normalise height to, by default 1.0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Path to output raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">output_raster</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">include_height</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">height_normalisation</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">height_normalisation_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">8849.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.grid", "modulename": "buteo.raster.grid", "kind": "module", "doc": "<h3 id=\"create-grids-from-rasters\">Create grids from rasters.</h3>\n\n<p>Cut rasters to grids. Use vectors or rasters as grids.</p>\n"}, {"fullname": "buteo.raster.grid.raster_to_grid", "modulename": "buteo.raster.grid", "qualname": "raster_to_grid", "kind": "function", "doc": "<p>Clips a raster to a grid. Generates .vrt.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset]):\nThe input raster.</li>\n<li><strong>grid</strong> (Union[str, ogr.DataSource]):\nThe grid to use.</li>\n<li><strong>out_dir</strong> (str):\nThe output directory.</li>\n<li><strong>use_field</strong> (bool, optional):\nA field to use to name the grid cells, default: None.</li>\n<li><strong>generate_vrt</strong> (bool, optional):\nIf True, the output raster will be a .vrt, default: True.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf True, the output raster will be overwritten, default: True.</li>\n<li><strong>process_layer</strong> (int, optional):\nThe layer from the grid to process, default: 0.</li>\n<li><strong>creation_options</strong> (Optional[List[str]], optional):\nCreation options for the output raster, default: None.</li>\n<li><strong>verbose</strong> (int, optional):\nThe verbosity level, default: 0.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: The filepath for the newly created raster.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_dir</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">use_field</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">generate_vrt</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata", "modulename": "buteo.raster.nodata", "kind": "module", "doc": "<h3 id=\"handle-nodata-values-in-rasters\">Handle nodata values in rasters.</h3>\n\n<p>A module to handle the various aspects of NODATA in raster files.</p>\n"}, {"fullname": "buteo.raster.nodata.raster_has_nodata_value", "modulename": "buteo.raster.nodata", "qualname": "raster_has_nodata_value", "kind": "function", "doc": "<p>Check if a raster or a list of rasters contain nodata values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset, List]):\nThe raster to check for nodata values.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>bool</strong>: True if the raster or list of rasters contain nodata values.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_get_nodata_value", "modulename": "buteo.raster.nodata", "qualname": "raster_get_nodata_value", "kind": "function", "doc": "<p>Get the nodata value of a raster or a list of rasters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset, List]):\nThe raster(s) to get nodata values from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[float, int, List]</strong>: The nodata value(s) of the raster(s).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_set_nodata", "modulename": "buteo.raster.nodata", "qualname": "raster_set_nodata", "kind": "function", "doc": "<p>Sets all the nodata for raster(s) to a value.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset, List]):\nThe raster(s) to set nodata values for.</li>\n<li><strong>dst_nodata</strong> (Union[float, int, str, None]):\nThe target nodata value. If 'infer' the nodata value is set based on the input datatype. \nA list of nodata values can be based matching the amount of input rasters. If multiple \nnodata values should be set, use <code>raster_mask_values</code>.</li>\n<li><strong>out_path</strong> (str, optional):\nThe destination of the changed rasters, default: None</li>\n<li><strong>overwrite</strong> (bool, optional):\nShould the rasters be overwritten if they already exist? default: True</li>\n<li><strong>in_place</strong> (bool, optional):\nShould the rasters be changed in_place or copied?, default: False</li>\n<li><strong>prefix</strong> (str, optional):\nPrefix to add to the output, default: \"\"</li>\n<li><strong>suffix</strong> (str, optional):\nSuffix to add to the output, default: \"_nodata_set\"</li>\n<li><strong>creation_options</strong> (List, optional):\nCreation options for the output rasters, default: None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[str, List]</strong>: Returns the rasters with nodata set.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;_nodata_set&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_remove_nodata", "modulename": "buteo.raster.nodata", "qualname": "raster_remove_nodata", "kind": "function", "doc": "<p>Removes all the nodata from a raster or a list of rasters.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset, List]):\nThe raster(s) to remove nodata values for.</li>\n<li><strong>out_path</strong> (str, optional):\nThe destination of the changed rasters.</li>\n<li><strong>overwrite</strong> (bool, optional):\nShould the rasters be overwritten if they already exist? default: True</li>\n<li><strong>in_place</strong> (bool, optional):\nShould the rasters be changed in_place or copied? default: False</li>\n<li><strong>prefix</strong> (str, optional):\nPrefix to add to the output. default: \"\"</li>\n<li><strong>suffix</strong> (str, optional):\nSuffix to add to the output. default: \"_nodata_removed\"</li>\n<li><strong>creation_options</strong> (list, optional):\nCreation options for the output rasters. default: None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[str, List]</strong>: The rasters with nodata removed.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;_nodata_removed&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_mask_values", "modulename": "buteo.raster.nodata", "qualname": "raster_mask_values", "kind": "function", "doc": "<p>Mask a raster with a list of values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset, List]):\nThe raster(s) to mask.</li>\n<li><strong>values_to_mask</strong> (List):\nThe values to mask.</li>\n<li><strong>include_original_nodata</strong> (bool, optional):\nShould the nodata_value of the input raster be added to the list of masked values?, default: True</li>\n<li><strong>dst_nodata</strong> (Union[float, int, str, List], optional):\nThe nodata value to use for the output raster. If 'infer', the nodata_value from the input raster is used., default: 'infer'</li>\n<li><strong>out_path</strong> (str, optional):\nThe destination of the changed rasters. If out_paths are specified, in_place is automatically set to False.\nThe path can be a folder., default: None</li>\n<li><strong>in_place</strong> (bool, optional):\nShould the rasters be changed in_place or copied?, default: False</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf the output path exists already, should it be overwritten?, default: True</li>\n<li><strong>prefix</strong> (str, optional):\nPrefix to add to the output., default: \"\"</li>\n<li><strong>suffix</strong> (str, optional):\nSuffix to add to the output., default: \"\"</li>\n<li><strong>add_uuid</strong> (bool, optional):\nShould a uuid be added to the output path?, default: False</li>\n<li><strong>creation_options</strong> (List, optional):\nThe GDAL creation options to be passed., default: None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[str, List]</strong>: Returns the rasters with nodata masked.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">values_to_mask</span><span class=\"p\">:</span> <span class=\"n\">List</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">include_original_nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.proximity", "modulename": "buteo.raster.proximity", "kind": "module", "doc": "<h3 id=\"calculate-distances-on-a-raster\">Calculate distances on a raster.</h3>\n\n<p>Module to calculate the distance from a pixel value to other pixels.</p>\n"}, {"fullname": "buteo.raster.proximity.calc_proximity", "modulename": "buteo.raster.proximity", "qualname": "calc_proximity", "kind": "function", "doc": "<p>Calculate the proximity of input_raster to values.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>input_rasters</strong> (List):\nA list of rasters to use as input.</li>\n<li><strong>target_value</strong> (Union[int, float], optional):\nThe value to use as target, default: 1.</li>\n<li><strong>unit</strong> (str, optional):\nThe unit to use for the distance, GEO or PIXEL, default: \"GEO\".</li>\n<li><strong>out_path</strong> (Union[str, None, List], optional):\nThe output path, default: None.</li>\n<li><strong>max_dist</strong> (Union[int, float], optional):\nThe maximum distance to use, default: 1000.</li>\n<li><strong>add_border</strong> (bool, optional):\nIf True, a border will be added to the raster, default: False.</li>\n<li><strong>border_value</strong> (Union[int, float], optional):\nThe value to use for the border, default: 0.</li>\n<li><strong>weighted</strong> (bool, optional):\nIf True, the distance will be divided by the max distance, default: False.</li>\n<li><strong>invert</strong> (bool, optional):\nIf True, the target will be inversed, default: False.</li>\n<li><strong>return_array</strong> (bool, optional):\nIf True, a NumPy array will be returned instead of a raster, default: False.</li>\n<li><strong>prefix</strong> (str, optional):\nPrefix to add to the output, default: \"\".</li>\n<li><strong>suffix</strong> (str, optional):\nSuffix to add to the output, default: \"_proximity\".</li>\n<li><strong>add_uuid</strong> (bool, optional):\nShould a uuid be added to the output path?, default: False.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf the output path exists already, should it be overwritten?, default: True.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[str, np.ndarray]</strong>: A path to a raster with the calculated proximity, or a numpy array with the data.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_rasters</span><span class=\"p\">:</span> <span class=\"n\">List</span>,</span><span class=\"param\">\t<span class=\"n\">target_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">unit</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;GEO&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_dist</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span>,</span><span class=\"param\">\t<span class=\"n\">add_border</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">border_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">weighted</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">return_array</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;_proximity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.reproject", "modulename": "buteo.raster.reproject", "kind": "module", "doc": "<h3 id=\"reproject-rasters\">Reproject rasters.</h3>\n\n<p>Module to reproject rasters to a target coordinate reference system.\nCan uses references from vector or other raster datasets.</p>\n"}, {"fullname": "buteo.raster.reproject.reproject_raster", "modulename": "buteo.raster.reproject", "qualname": "reproject_raster", "kind": "function", "doc": "<p>Reproject raster(s) to a target coordinate reference system.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raster</strong> (Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]]):\nThe raster(s) to reproject.</li>\n<li><strong>projection</strong> (Union[int, str, gdal.Dataset, ogr.DataSource, osr.SpatialReference]):\nThe projection to reproject the raster to. The input can be a WKT proj,\nEPSG proj, Proj, osr proj, or read from a vector or raster datasource\neither from path or in-memory.</li>\n<li><strong>out_path</strong> (Optional[Union[str, List[str]]], optional):\nThe output path, default: None. If not provided, the output path is inferred\nfrom the input.</li>\n<li><strong>resample_alg</strong> (str, optional):\nThe resampling algorithm, default: \"nearest\".</li>\n<li><strong>copy_if_same</strong> (bool, optional):\nIf the input and output projections are the same, copy the input raster to the\noutput path, default: True.</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf the output path already exists, overwrite it, default: True.</li>\n<li><strong>creation_options</strong> (Optional[List[str]], optional):\nA list of creation options for the output raster, default: None.</li>\n<li><strong>dst_nodata</strong> (Union[str, int, float], optional):\nThe nodata value for the output raster, default: \"infer\".</li>\n<li><strong>dtype</strong> (Optional[str], optional):\nThe data type for the output raster, default: None.</li>\n<li><strong>prefix</strong> (str, optional):\nThe prefix to add to the output path, default: \"\".</li>\n<li><strong>suffix</strong> (str, optional):\nThe suffix to add to the output path, default: \"\".</li>\n<li><strong>add_uuid</strong> (bool, optional):\nIf True, add a UUID to the output path, default: False.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Union[str, List[str]]</strong>: The output path(s).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">osr</span><span class=\"o\">.</span><span class=\"n\">SpatialReference</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">copy_if_same</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.reproject.match_raster_projections", "modulename": "buteo.raster.reproject", "qualname": "match_raster_projections", "kind": "function", "doc": "<p>Match a raster or list of rasters to a master layer. The master can be\neither an OGR layer or a GDAL layer.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>rasters</strong> (Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]]):\nA list of rasters to match.</li>\n<li><strong>reference</strong> (Union[str, gdal.Dataset, ogr.DataSource]):\nPath to the reference raster or vector.</li>\n<li><strong>out_path</strong> (Optional[Union[str, List[str]]], optional):\nPaths to the output. If not provided, the output will be in-memory rasters., default: None</li>\n<li><strong>overwrite</strong> (bool, optional):\nIf True, existing rasters will be overwritten., default: True</li>\n<li><strong>dst_nodata</strong> (Union[str, int, float], optional):\nValue to use for no-data pixels. If not provided, the value will be transfered from the original., default: \"infer\"</li>\n<li><strong>copy_if_already_correct</strong> (bool, optional):\nIf True, the raster will be copied if it is already in the correct projection., default: True</li>\n<li><strong>creation_options</strong> (Optional[List[str]], optional):\nList of creation options to pass to the output raster., default: None</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>List[str]</strong>: A list of reprojected input rasters with the correct projection.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">copy_if_already_correct</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.resample", "modulename": "buteo.raster.resample", "kind": "module", "doc": "<h3 id=\"resample-rasters\">Resample rasters.</h3>\n\n<p>Module to resample rasters to a target resolution.\nCan uses references from vector or other raster datasets.</p>\n"}, {"fullname": "buteo.raster.resample.resample_raster", "modulename": "buteo.raster.resample", "qualname": "resample_raster", "kind": "function", "doc": "<p>Resampled raster(s) given a target size.\nBeware, if your input is in latitude and longitude, you'll need to specify the target_size in degrees as well.</p>\n\n<p>Args:\n    raster (str/list/gdal.Dataset): The input raster(s) to resample.\n    target_size (str/int/ogr.DataSource/gdal.Dataset): The desired resolution for the resampled raster(s),\n        in the same unit as the raster projection. For better resampling results, reproject to a projected\n        coordinate system first. If a raster is provided as the target_size, the function will read the pixel\n        size from that raster.</p>\n\n<p>Keyword Args:\n    target_in_pixels (bool=False): If True, interprets target_size as the number of pixels.\n    out_path (str/None=None): The output path for the resampled raster(s). If not provided, the output\n        path is inferred from the input raster(s).\n    resample_alg (str=\"nearest\"): The resampling algorithm to use.\n    copy_if_same (bool=True): If input and output projections are the same, copies the input raster\n        to the output path.\n    overwrite (bool=True): If the output path already exists, overwrites it.\n    creation_options (list/None=None): A list of creation options for the output raster(s).\n    dst_nodata (str/int/float=\"infer\"): The nodata value for the output raster(s).\n    prefix (str=\"\"): The prefix to add to the output path.\n    suffix (str=\"_reprojected\"): The suffix to add to the output path.\n    add_uuid (bool=False): If True, adds a UUID to the output path.</p>\n\n<p>Returns:\n    str/list: The output path(s) of the resampled raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">target_size</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">target_in_pixels</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.resample.resample_array", "modulename": "buteo.raster.resample", "qualname": "resample_array", "kind": "function", "doc": "<p>Resample a numpy array using the GDAL algorithms.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">target_shape_pixels</span>, </span><span class=\"param\"><span class=\"n\">resample_alg</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.shift", "modulename": "buteo.raster.shift", "kind": "module", "doc": "<h3 id=\"shift-rasters\">Shift rasters.</h3>\n\n<p>Module to shift the location of rasters in geographic coordinates.</p>\n"}, {"fullname": "buteo.raster.shift.shift_raster", "modulename": "buteo.raster.shift", "qualname": "shift_raster", "kind": "function", "doc": "<p>Shifts a raster in a given direction. (The frame is shifted)</p>\n\n<p>Args:\n    raster (Union[str, List, gdal.Dataset]): The raster(s) to be shifted.\n    shift_list (List[Union[int, float]]): The shift in x and y direction.</p>\n\n<p>Keyword Args:\n    out_path (Optional[str]='None'): The path to the output raster. If None, the raster is\n        created in memory.\n    overwrite (bool=True): If True, the output raster will be overwritten if it already exists.\n    prefix (str=''): The prefix to be added to the output raster name.\n    suffix (str=''): The suffix to be added to the output raster name.\n    add_uuid (bool=False): If True, a unique identifier will be added to the output raster name.\n    creation_options (Optional[List[str]]='None'): The creation options to be used when creating the output.</p>\n\n<p>Returns:\n    Union[str, List[str], gdal.Dataset]: The path(s) to the shifted raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">shift_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.shift.shift_raster_pixel", "modulename": "buteo.raster.shift", "qualname": "shift_raster_pixel", "kind": "function", "doc": "<p>Shifts a raster in a given direction. (The pixels are shifted, not the frame)</p>\n\n<p>Args:\n    raster (Union[str, gdal.Dataset]): The raster to be shifted.\n    shift_list (List[Union[int, float]]): The shift in x and y direction.</p>\n\n<p>Keyword Args:\n    nodata_value (Union[int, float]=-9999.9): The nodata value to use when shifting pixels.\n    out_path (Optional[str]='None'): The path to the output raster. If None, the raster is\n        created in memory.</p>\n\n<p>Returns:\n    str: The path to the shifted raster.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">shift_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mf\">9999.9</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.timeseries", "modulename": "buteo.raster.timeseries", "kind": "module", "doc": "<p>Time series analysis functions.</p>\n"}, {"fullname": "buteo.raster.timeseries.least_squares_slope", "modulename": "buteo.raster.timeseries", "qualname": "least_squares_slope", "kind": "function", "doc": "<p>Compute the least squares slope for a set of data points along the last channel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.timeseries.robust_least_squares_slope", "modulename": "buteo.raster.timeseries", "qualname": "robust_least_squares_slope", "kind": "function", "doc": "<p>Compute the robust least squares slope for a set of data points along the last channel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">std_threshold</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">splits</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">report_progress</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.vectorize", "modulename": "buteo.raster.vectorize", "kind": "module", "doc": "<h3 id=\"vectorize-rasters\">Vectorize rasters.</h3>\n\n<p>Module to turn rasters into vector representations.</p>\n"}, {"fullname": "buteo.raster.vectorize.vectorize_raster", "modulename": "buteo.raster.vectorize", "qualname": "vectorize_raster", "kind": "function", "doc": "<p>Vectorizes a raster by turning it into polygons per unique value. Works\nbest on integer rasters.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_list_/_gdal.Dataset_): The raster(s) to vectorize.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The path(s) to save the vectorized raster(s) to. (Default: <strong>None</strong>) </br>\n<code>band</code> (_int_): The band to vectorize. (Default: <strong>1</strong>) </br>\n<code>prefix</code> (_str_): The prefix to be added to the output raster name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix to be added to the output raster name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): If True, a unique identifier will be added to the output raster name. (Default: <strong>False</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the vectorized raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">band</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.warp", "modulename": "buteo.raster.warp", "kind": "module", "doc": "<h3 id=\"gdal-warp-functions\">GDAL Warp functions</h3>\n\n<p>Module to wrap the functionality of GDAL's gdalwarp.</p>\n"}, {"fullname": "buteo.raster.warp.warp_raster", "modulename": "buteo.raster.warp", "qualname": "warp_raster", "kind": "function", "doc": "<p>Warps a raster into a target raster. </br></p>\n\n<p>Please be aware that all_touch does not work if target_size is set.\nIf all_touch is required while resampling. Do it in two steps:\nresample -> warp or resample -> clip.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_list_/_gdal.Dataset_): The raster(s) to warp.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The path to the output raster(s). If not set, a memory raster is created. (Default: <strong>None</strong>) </br>\n<code>projection</code> (_str_/_osr.SpatialReference_/_gdal.Dataset_/_ogr.DataSource_): The projection of the output raster. If not set, the projection of the input raster is used. (Default: <strong>None</strong>) </br>\n<code>clip_geom</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The geometry to clip the raster to. (Default: <strong>None</strong>) </br>\n<code>target_size</code> (_tuple_/_None_): The target size of the output raster. If not set, the size of the input raster is used. (Default: <strong>None</strong>) </br>\n<code>target_in_pixels</code> (_bool_): If True, the target size is in pixels. If False, the target size is in map units. (Default: <strong>False</strong>) </br>\n<code>resample_alg</code> (_str_): The resampling algorithm. (Default: <strong>nearest</strong>) </br>\n<code>crop_to_geom</code> (_bool_): If True, the output raster is cropped to the extent of the clip geometry. (Default: <strong>True</strong>) </br>\n<code>all_touch</code> (_bool_): If True, all pixels touching the clipping geometry is included. (Default: <strong>False</strong>) </br>\n<code>adjust_bbox</code> (_bool_): If True, the bounding box of the output raster is adjusted to align with the clipping geometry. (Default: <strong>False</strong>) </br>\n<code>src_nodata</code> (_str_/_int_/_float_/_None_): The nodata value of the input raster. If not set, the nodata value of the input raster is used. (Default: <strong>infer</strong>) </br>\n<code>dst_nodata</code> (_str_/_int_/_float_/_None_): The nodata value of the output raster. If not set, the nodata value of the input raster is used. (Default: <strong>infer</strong>) </br>\n<code>layer_to_clip</code> (_int_): The layer to clip the raster to. (Default: <strong>0</strong>) </br>\n<code>prefix</code> (_str_): The prefix of the output raster. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix of the output raster. (Default: <strong>\"_resampled\"</strong>) </br>\n<code>add_uuid</code> (_bool_): If True, a unique identifier is added to the output raster. (Default: <strong>False</strong>) </br>\n<code>overwrite</code> (_bool_): If True, the output raster is overwritten if it already exists. (Default: <strong>True</strong>) </br>\n<code>creation_options</code> (_list_): The creation options of the output raster. (Default: <strong>None</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path to the warped output raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_size</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_in_pixels</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">crop_to_geom</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">all_touch</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">adjust_bbox</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">src_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">layer_to_clip</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_resampled&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils", "modulename": "buteo.utils", "kind": "module", "doc": "<p>Various utility functions to work with the underlying systems.</p>\n"}, {"fullname": "buteo.utils.aux_utils", "modulename": "buteo.utils.aux_utils", "kind": "module", "doc": "<h3 id=\"generic-utility-functions\">Generic utility functions</h3>\n\n<p>Functions that make interacting with the toolbox easier.</p>\n"}, {"fullname": "buteo.utils.aux_utils.channel_first_to_last", "modulename": "buteo.utils.aux_utils", "qualname": "channel_first_to_last", "kind": "function", "doc": "<p>Converts a numpy array from channel first to channel last format.\n(-batch-, channel, height, width) -> (-batch-, height, width, channel)</p>\n\n<p>If 4D, it is assumed that the input array is in batch, channel, height, width format.\nIf 3D, it is assumed that the input array is in channel, height, width format.</p>\n\n<p>Args:\n    arr (np.ndarray): The array to convert.</p>\n\n<p>Returns:\n    (np.ndarray): The converted array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.channel_last_to_first", "modulename": "buteo.utils.aux_utils", "qualname": "channel_last_to_first", "kind": "function", "doc": "<p>Converts a numpy array from channel last to channel first format.</p>\n\n<p>(-batch-, height, width, channel) -> (-batch-, channel, height, width)</p>\n\n<p>If 4D, it is assumed that the input array is in batch, channel, height, width format.\nIf 3D, it is assumed that the input array is in channel, height, width format.</p>\n\n<p>Args:\n    arr(np.ndarray): The array to convert.</p>\n\n<p>Returns:\n    (np.ndarray): The converted array.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.create_grid", "modulename": "buteo.utils.aux_utils", "qualname": "create_grid", "kind": "function", "doc": "<p>Create a grid of rows and columns</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">range_rows</span>, </span><span class=\"param\"><span class=\"n\">range_cols</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.calculate_pixel_distances", "modulename": "buteo.utils.aux_utils", "qualname": "calculate_pixel_distances", "kind": "function", "doc": "<p>Calculate the distance from each pixel to the nearest target pixel.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">maximum_distance</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_width</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_height</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.fill_nodata_with_nearest_average", "modulename": "buteo.utils.aux_utils", "qualname": "fill_nodata_with_nearest_average", "kind": "function", "doc": "<p>Calculate the distance from each pixel to the nearest target pixel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">nodata_value</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">max_iterations</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">channel</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils", "modulename": "buteo.utils.bbox_utils", "kind": "module", "doc": "<h3 id=\"bounding-box-utility-functions\">Bounding box utility functions</h3>\n\n<p>Various utility functions to work with bounding boxes and gdal.</p>\n\n<p>There are two different formats for bounding boxes used by GDAL:</br>\nOGR:  <code>[x_min, x_max, y_min, y_max]</code></br>\nWARP: <code>[x_min, y_min, x_max, y_max]</code></br></p>\n\n<p>_If nothing else is stated, the OGR format is used._</p>\n\n<p>The GDAL geotransform is a list of six parameters:</br>\n<code>x_min, pixel_width, row_skew, y_max, column_skew, pixel_height (negative for north-up)</code></p>\n"}, {"fullname": "buteo.utils.bbox_utils.is_valid_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "is_valid_bbox", "kind": "function", "doc": "<p>Checks if a bbox is valid.</p>\n\n<p>A valid ogr formatted bbox has the form: </br>\n<code>[x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bbox is valid, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.is_valid_bbox_latlng", "modulename": "buteo.utils.bbox_utils", "qualname": "is_valid_bbox_latlng", "kind": "function", "doc": "<p>Checks if a bbox is valid and latlng.</p>\n\n<p>A valid ogr formatted bbox has the form: </br>\n<code>[x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr_latlng</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bbox is valid, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr_latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.is_valid_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "is_valid_geotransform", "kind": "function", "doc": "<p>Checks if a geotransform is valid.</p>\n\n<p>A valid geotransform has the form: </br>\n<code>[x_min, pixel_width, row_skew, y_max, column_skew, pixel_height]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_/_tuple_): A GDAL formatted geotransform.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the geotransform is valid, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.ensure_negative", "modulename": "buteo.utils.bbox_utils", "qualname": "ensure_negative", "kind": "function", "doc": "<p>Ensures that a valid is negative. If the number is positive, it is made negative.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>number</code> (_int_/_float_): A float or int number. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_int_/_float_): The same number made <strong>negative</strong> if necesary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">number</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_pixel_offsets", "modulename": "buteo.utils.bbox_utils", "qualname": "get_pixel_offsets", "kind": "function", "doc": "<p>Get the pixels offsets for a bbox and a geotransform.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_/_tuple_): A GDAL GeoTransform. </br>\n<code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A list of pixel offsets. <code>[x_start, y_start, x_size, y_size]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span>, </span><span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_geotransform", "kind": "function", "doc": "<p>Get an OGR bounding box from a geotransform and raster sizes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_/_tuple_): A GDAL GeoTransform. </br>\n<code>raster_x_size</code> (_int_): The number of pixels in the x direction. </br>\n<code>raster_y_size</code> (_int_): The number of pixels in the y direction. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span>, </span><span class=\"param\"><span class=\"n\">raster_x_size</span>, </span><span class=\"param\"><span class=\"n\">raster_y_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_raster", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_raster", "kind": "function", "doc": "<p>Gets an OGR bounding box from a GDAL raster dataframe.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_dataframe</code> (_gdal.DataFrame_): A GDAL raster dataframe. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_dataframe</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_vector", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_vector", "kind": "function", "doc": "<p>Gets an OGR bounding box from an OGR dataframe.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector_dataframe</code> (_ogr.DataSource_): An OGR vector dataframe. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector_dataframe</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_vector_layer", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_vector_layer", "kind": "function", "doc": "<p>Gets an OGR bounding box from an OGR dataframe layer.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector_layer</code> (_ogr.Layer_): An OGR vector dataframe layer. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector_layer</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_dataset", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_dataset", "kind": "function", "doc": "<p>Get the bbox from a dataset.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource): A dataset or dataset path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The bounding box in ogr format: [x_min, x_max, y_min, y_max].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_sub_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "get_sub_geotransform", "kind": "function", "doc": "<p>Create a GeoTransform and the raster sizes for an OGR formatted bbox.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_): A GDAL geotransform. </br>\n<code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_): { \"Transform\": _list_, \"RasterXSize\": _int_, \"RasterYSize\": _int_ }</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span>, </span><span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_geom", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_geom", "kind": "function", "doc": "<p>Convert an OGR bounding box to ogr.Geometry.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; ogr.Geometry</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.Geometry_): An OGR geometry.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_geom_to_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_geom_to_bbox", "kind": "function", "doc": "<p>Convert an ogr.Geometry to an OGR bounding box.</br>\n<code>ogr.Geometry -&gt; [x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geom</code> (_ogr.Geometry_): An OGR geometry. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geom</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_geotransform", "kind": "function", "doc": "<p>Convert an OGR formatted bounding box to a GDAL GeoTransform.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; [x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>raster_x_size</code> (_int_): The number of pixels in the x direction. </br>\n<code>raster_y_size</code> (_int_): The number of pixels in the y direction. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A GDAL GeoTransform. <code>[x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">raster_x_size</span>, </span><span class=\"param\"><span class=\"n\">raster_y_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_ogr_bbox_to_gdal_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_ogr_bbox_to_gdal_bbox", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to a GDAL formatted one.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; [x_min, y_min, x_max, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A GDAL formatted bbox. <code>[x_min, y_min, x_max, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_gdal_bbox_to_ogr_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_gdal_bbox_to_ogr_bbox", "kind": "function", "doc": "<p>Converts a GDAL formatted bbox to an OGR formatted one.</br>\n<code>[x_min, y_min, x_max, y_max] -&gt; [x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_gdal</code> (_list_): A GDAL formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_gdal</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_wkt", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_wkt", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to a WKT string.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; WKT</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): A WKT Polygon string. <code>POLYGON ((...))</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_geojson", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_geojson", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to a GeoJson dictionary.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; GeoJson</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): an OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_): A GeoJson Dictionary. <code>{ \"type\": \"Polygon\", \"coordinates\": [ ... ] }</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_vector", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_vector", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to an in-memory vector.</br>\n_Vectors are stored in /vsimem/ as .gpkg files._</br>\n<strong>OBS</strong>: Layers should be manually cleared when no longer used.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): an OGR formatted bbox. </br>\n<code>projection_osr</code> (_osr.SpatialReference_): The projection of the vector. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.DataSource_): The bounding box as a vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">projection_osr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.bboxes_intersect", "modulename": "buteo.utils.bbox_utils", "qualname": "bboxes_intersect", "kind": "function", "doc": "<p>Checks if two OGR formatted bboxes intersect.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bboxes intersect, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.bboxes_within", "modulename": "buteo.utils.bbox_utils", "qualname": "bboxes_within", "kind": "function", "doc": "<p>Checks if one OGR formatted bbox is within another.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bbox is within the other, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_intersection_bboxes", "modulename": "buteo.utils.bbox_utils", "qualname": "get_intersection_bboxes", "kind": "function", "doc": "<p>Get the intersection of two OGR formatted bboxes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox of the intersection. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_union_bboxes", "modulename": "buteo.utils.bbox_utils", "qualname": "get_union_bboxes", "kind": "function", "doc": "<p>Get the union of two OGR formatted bboxes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox of the union. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_projection_from_raster", "modulename": "buteo.utils.bbox_utils", "qualname": "get_projection_from_raster", "kind": "function", "doc": "<p>Get the projection from a raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.Dataset_): A raster or raster path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The projection in OSR format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_projection_from_vector", "modulename": "buteo.utils.bbox_utils", "qualname": "get_projection_from_vector", "kind": "function", "doc": "<p>Get the projection from a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_gdal.Dataset_): A vector or vector path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The projection in OSR format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_projection_from_dataset", "modulename": "buteo.utils.bbox_utils", "qualname": "get_projection_from_dataset", "kind": "function", "doc": "<p>Get the projection from a dataset.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource): A dataset or dataset path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The projection in OSR format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.align_bboxes_to_pixel_size", "modulename": "buteo.utils.bbox_utils", "qualname": "align_bboxes_to_pixel_size", "kind": "function", "doc": "<p>Aligns two OGR formatted bboxes to a pixel size. Output is an augmented version\nof bbox2.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>pixel_width</code> (_float_/_int_): The width of the pixel. </br>\n<code>pixel_height</code> (_float_/_int_): The height of the pixel. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox of the alignment. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span>, </span><span class=\"param\"><span class=\"n\">pixel_width</span>, </span><span class=\"param\"><span class=\"n\">pixel_height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.reproject_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "reproject_bbox", "kind": "function", "doc": "<p>Reprojects an OGR formatted bbox.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>source_projection_osr</code> (_osr.SpatialReference_): The source projection. </br>\n<code>target_projection_osr</code> (_osr.SpatialReference_): The target projection. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted reprojected bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">source_projection</span>, </span><span class=\"param\"><span class=\"n\">target_projection</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_latlng", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_latlng", "kind": "function", "doc": "<p>Get the UTM ZONE from a latlng list.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The UTM zone projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">latlng</span>, </span><span class=\"param\"><span class=\"n\">return_epsg</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_bbox", "kind": "function", "doc": "<p>Get the UTM zone from an OGR formatted bbox.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The UTM zone projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr_latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_dataset", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_dataset", "kind": "function", "doc": "<p>Get the UTM zone from a GDAL dataset.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_obj_): A GDAL dataset. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The UTM zone.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_dataset_list", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_dataset_list", "kind": "function", "doc": "<p>Get the UTM zone from a list of GDAL datasets.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>datasets</code> (_list_): A list of GDAL datasets. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The UTM zone.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">datasets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.reproject_latlng_point_to_utm", "modulename": "buteo.utils.bbox_utils", "qualname": "reproject_latlng_point_to_utm", "kind": "function", "doc": "<p>Converts a latlng point into an UTM point.</p>\n\n<p>Takes point in [lat, lng], returns [utm_x, utm_y].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.geometry_latlng_from_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "geometry_latlng_from_bbox", "kind": "function", "doc": "<p>This is an internal utility function for metadata generation. It takes a standard\nOGR bounding box and the geometry of the source dataset in latlng and returns a\ngeometry in the source dataset's projection. This is important as, as when \nreprojecting to latlng, you might get a skewed bounding box. This function returns\nthe skewed bounds in latlng, which is what you want for overlap checks across\nprojections.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>projection_osr</code> (_osr.SpatialReference_): The projection. </br>\n<code>latlng_projection</code> (_osr.SpatialReference_): The latlng projection. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.Geometry_): The geometry in the source dataset's projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">projection_osr</span>, </span><span class=\"param\"><span class=\"n\">latlng_projection_osr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.additional_bboxes", "modulename": "buteo.utils.bbox_utils", "qualname": "additional_bboxes", "kind": "function", "doc": "<p>This is an internal utility function for metadata generation. It takes a standard\nOGR bounding box and returns a list of variations of bounding boxes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>projection_osr</code> (_osr.SpatialReference_): The projection. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_): A dictionary of the added bboxes. Contains the following keys: </br>\n<code>bbox_latlng</code>: The bbox in latlng coordinates. </br>\n<code>bbox_wkt</code>: The bbox in WKT format. </br>\n<code>bbox_wkt_latlng</code>: The bbox in WKT format in latlng coordinates. </br>\n<code>bbox_geom</code>: The bbox in ogr.Geometry format. </br>\n<code>bbox_geom_latlng</code>: The bbox in ogr.Geometry format in latlng coordinates. </br>\n<code>bbox_gdal</code>: The bbox in GDAL format. </br>\n<code>bbox_gdal_latlng</code>: The bbox in GDAL format in latlng coordinates. </br>\n<code>bbox_dict</code>: The bbox in a dictionary format. { \"x_min\": x_min, ... } </br>\n<code>bbox_dict_latlng</code>: The bbox in a dictionary format in latlng coordinates. </br></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">projection_osr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils", "modulename": "buteo.utils.core_utils", "kind": "module", "doc": "<h3 id=\"generic-utility-functions\">Generic utility functions</h3>\n\n<p>Functions that make interacting with the toolbox easier.</p>\n"}, {"fullname": "buteo.utils.core_utils.get_unix_seconds_as_str", "modulename": "buteo.utils.core_utils", "qualname": "get_unix_seconds_as_str", "kind": "function", "doc": "<p>Get a string of the current UNIX time in seconds.</p>\n\n<p>Returns:\n    str: A string of the current UNIX time in seconds.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_float", "modulename": "buteo.utils.core_utils", "qualname": "is_float", "kind": "function", "doc": "<p>Check if a value is a float. If it is a string, try to convert it to a float.</p>\n\n<p>Args:\n    value (any): The value to check.</p>\n\n<p>Returns:\n    bool: True if the value is a float, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_number", "modulename": "buteo.utils.core_utils", "qualname": "is_number", "kind": "function", "doc": "<p>Check if variable is a number.</p>\n\n<p>Args:\n    potential_number (any): The variable to check.</p>\n\n<p>Returns:\n    bool: True if the variable is a number, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_number</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_int", "modulename": "buteo.utils.core_utils", "qualname": "is_int", "kind": "function", "doc": "<p>Check if a value is an integer. If it is a string, try to convert it to an integer.</p>\n\n<p>Args:\n    value (any): The value to check.</p>\n\n<p>Returns:\n    bool: True if the variable is an int, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_list_all_the_same", "modulename": "buteo.utils.core_utils", "qualname": "is_list_all_the_same", "kind": "function", "doc": "<p>Check if a list contains all the same elements.</p>\n\n<p>Args:\n    lst (list): The list to check.</p>\n\n<p>Returns:\n    bool: True if the list contains all the same elements, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lst</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.file_exists", "modulename": "buteo.utils.core_utils", "qualname": "file_exists", "kind": "function", "doc": "<p>Check if a file exists. Also checks vsimem.</p>\n\n<p>Args:\n    path (str): The path to the file.</p>\n\n<p>Returns:\n    bool: True if the file exists, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.folder_exists", "modulename": "buteo.utils.core_utils", "qualname": "folder_exists", "kind": "function", "doc": "<p>Check if a folder exists.</p>\n\n<p>Args:\n    path (str): The path to the folder.</p>\n\n<p>Returns:\n    bool: True if the folder exists, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.delete_files_in_folder", "modulename": "buteo.utils.core_utils", "qualname": "delete_files_in_folder", "kind": "function", "doc": "<p>Delete all files in a folder. Does not remove subfolders.</p>\n\n<p>Args:\n    folder (str): The path to the folder.</p>\n\n<p>Returns:\n    bool: True if the files were deleted, raises warning otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.delete_folder", "modulename": "buteo.utils.core_utils", "qualname": "delete_folder", "kind": "function", "doc": "<p>Delete a folder.</p>\n\n<p>Args:\n    folder (str): The path to the folder.</p>\n\n<p>Returns:\n    bool: True if the folder was deleted, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.delete_file", "modulename": "buteo.utils.core_utils", "qualname": "delete_file", "kind": "function", "doc": "<p>Delete a File</p>\n\n<p>Args:\n    file (str): The path to the file.</p>\n\n<p>Returns:\n    bool: True if the file was deleted, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.to_number", "modulename": "buteo.utils.core_utils", "qualname": "to_number", "kind": "function", "doc": "<p>Attempts to convert a variable to a number.</p>\n\n<p>Args:\n    variable (any): The value to convert.</p>\n\n<p>Returns:\n    (float): The value converted to a number.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variable</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.make_dir_if_not_exists", "modulename": "buteo.utils.core_utils", "qualname": "make_dir_if_not_exists", "kind": "function", "doc": "<p>Make a directory if it doesn't exist.</p>\n\n<p>Args:\n    path (str): The path to the directory.</p>\n\n<p>Returns:\n    (str): The path to the created directory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.path_to_ext", "modulename": "buteo.utils.core_utils", "qualname": "path_to_ext", "kind": "function", "doc": "<p>Get the extension of a file. If the file has no extension, raise an error.</p>\n\n<p>Args:\n    path (str): The path to the file.</p>\n\n<p>Kwargs:\n    with_dot (bool = False): If True, return the extension with a dot.</p>\n\n<p>Returns:\n    str: The extension of the file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">with_dot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.path_to_folder", "modulename": "buteo.utils.core_utils", "qualname": "path_to_folder", "kind": "function", "doc": "<p>Get the folder of a file.</p>\n\n<p>Args:\n    path (str): The path to the file.</p>\n\n<p>Returns:\n    str: The folder of the file.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.change_path_ext", "modulename": "buteo.utils.core_utils", "qualname": "change_path_ext", "kind": "function", "doc": "<p>Change the extension of a file.</p>\n\n<p>Args:\n    path (str): The path to the file.\n    target_ext (str): The new extension.</p>\n\n<p>Returns:\n    str: The path to the file with the new extension.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target_ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_mem_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_mem_path", "kind": "function", "doc": "<p>Check if a path is a valid memory path that has an extension. vsizip also works.</p>\n\n<p>Args:\n    path (str): The path to test.</p>\n\n<p>Returns:\n    bool: True if path is a valid memory path, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_non_memory_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_non_memory_path", "kind": "function", "doc": "<p>Check if a path is valid, not in memory, and has an extension.</p>\n\n<p>Args:\n    path (str): The path to the file.</p>\n\n<p>Returns:\n    bool: True if the path has an extension, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_file_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_file_path", "kind": "function", "doc": "<p>Check if a path is valid and has an extension. Path can be in memory.</p>\n\n<p>Args:\n    path (str): The path to the file.</p>\n\n<p>Returns:\n    bool: True if the path has an extension, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_output_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_output_path", "kind": "function", "doc": "<p>Check if an output path is valid.</p>\n\n<p>Args:\n    path (str): The path to the file.</p>\n\n<p>Keyword Args:\n    overwrite (bool = True): True if the file should be overwritten, False otherwise.</p>\n\n<p>Returns:\n    bool: True if the output path is valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_output_path_list", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_output_path_list", "kind": "function", "doc": "<p>Check if a list of output paths are valid.</p>\n\n<p>Args:\n    output_list (list): The list of paths to the files.</p>\n\n<p>Keyword Args:\n    overwrite (bool = True): True if the file should be overwritten, False otherwise.</p>\n\n<p>Returns:\n    bool: True if the list of output paths are valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">output_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.remove_if_required", "modulename": "buteo.utils.core_utils", "qualname": "remove_if_required", "kind": "function", "doc": "<p>Remove a file if overwrite is True.</p>\n\n<p>Args:\n    path (str): The path to the file.\n    overwrite (bool = True): If True, overwrite the file.</p>\n\n<p>Returns:\n    bool: True if the file was removed, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.remove_if_required_list", "modulename": "buteo.utils.core_utils", "qualname": "remove_if_required_list", "kind": "function", "doc": "<p>Remove a list of files if overwrite is True.</p>\n\n<p>Args:\n    output_list (list): The list of paths to the files.\n    overwrite (bool): If True, overwrite the files.</p>\n\n<p>Returns:\n    bool: True if the files were removed, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">output_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.get_augmented_path", "modulename": "buteo.utils.core_utils", "qualname": "get_augmented_path", "kind": "function", "doc": "<p>Gets a basename from a string in the format:\n<code>dir/prefix_basename_time_uuid_suffix.ext</code></p>\n\n<p>Args:\n    path (str): The path to the original file.</p>\n\n<p>Keyword Args:\n    prefix (str = \"\"): The prefix to add to the memory path.\n    suffix (str = \"\"): The suffix to add to the memory path.\n    add_uuid (bool = True): If True, add a uuid to the memory path.\n    folder (str = None): The folder to save the file in.</p>\n\n<p>Returns:\n    str: A string of the current UNIX time in seconds.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.get_size", "modulename": "buteo.utils.core_utils", "qualname": "get_size", "kind": "function", "doc": "<p>Get the size of a folder.</p>\n\n<p>Keyword Args:\n    start_path (str = \".\"): The path to the folder.\n    rough (bool = True): If True, return a rough estimate.</p>\n\n<p>Returns:\n    int: The size of the folder.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.&#39;</span>, </span><span class=\"param\"><span class=\"n\">rough</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.divide_into_steps", "modulename": "buteo.utils.core_utils", "qualname": "divide_into_steps", "kind": "function", "doc": "<p>Divide a number into steps.</p>\n\n<p>Args:\n    total int: The total number.\n    step int: The step size.</p>\n\n<p>Returns:\n    list: The list of steps.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">step</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.divide_arr_into_steps", "modulename": "buteo.utils.core_utils", "qualname": "divide_arr_into_steps", "kind": "function", "doc": "<p>Divide an array into steps.</p>\n\n<p>Args:\n    arr (list): The array.\n    steps_length (int): The length of each step.</p>\n\n<p>Returns:\n    list: An array divided into steps.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">steps_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.step_ranges", "modulename": "buteo.utils.core_utils", "qualname": "step_ranges", "kind": "function", "doc": "<p>Get the ranges of each step.</p>\n\n<p>Args:\n    arr_with_steps (list): The array with steps.</p>\n\n<p>Returns:\n    list: A list of dictionaries of type: { \"id\": int, \"start\": int, \"stop\": int}.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr_with_steps</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.recursive_check_type_list_none_or_tuple", "modulename": "buteo.utils.core_utils", "qualname": "recursive_check_type_list_none_or_tuple", "kind": "function", "doc": "<p>Recursively check if a type, list or tuple.</p>\n\n<p>Args:\n    potential_type (any): The variable to test.</p>\n\n<p>Returns:\n    bool: True if a type, list, or tuple, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_type</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.type_check", "modulename": "buteo.utils.core_utils", "qualname": "type_check", "kind": "function", "doc": "<p>Utility function to type check the inputs of a function. Check two levels down.</p>\n\n<p>Args:\n    variable (any): The variable to check.\n    types (tuple): The types to check against. (float, int, ...)</p>\n\n<p>Keyword Args:\n    name (str = \"\"): The name printed in the error string if an error is thrown.\n    throw_error (bool = True): If True, raise an error if the type is not correct.</p>\n\n<p>Returns:\n    bool: A boolean indicating if the type is valid. If throw_error an error is raised if the input is not a valid type.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">types</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">throw_error</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_list_all_val", "modulename": "buteo.utils.core_utils", "qualname": "is_list_all_val", "kind": "function", "doc": "<p>Check if a list is all a value. This also considers type.</p>\n\n<p>Args:\n    arr (list): The list to check.\n    val (any): The value to check against.</p>\n\n<p>Returns:\n    bool: True if all elements are x, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">val</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.progress", "modulename": "buteo.utils.core_utils", "qualname": "progress", "kind": "function", "doc": "<p>Print a progress bar.</p>\n\n<p>Args:\n    count (int): The current count.\n    total (int): The total count.</p>\n\n<p>Keyword Args:\n    name (str = \"Processing\"): The name to show in the progress bar. Default: \"Processing\".</p>\n\n<p>Returns:\n    None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Processing&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.timing", "modulename": "buteo.utils.core_utils", "qualname": "timing", "kind": "function", "doc": "<p>Get the time elapsed since the given time.</p>\n\n<p>Args:\n    before (datetime): The time to compare.</p>\n\n<p>Keyword Args:\n    print_msg (bool = True): If True, print the time elapsed.</p>\n\n<p>Returns:\n    None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">before</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span>, </span><span class=\"param\"><span class=\"n\">print_msg</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.get_dynamic_memory_limit_bytes", "modulename": "buteo.utils.core_utils", "qualname": "get_dynamic_memory_limit_bytes", "kind": "function", "doc": "<p>Returns a dynamic memory limit taking into account total memory and CPU cores.</p>\n\n<p>Keyword Args:\n    percentage (float = 80.0): The percentage of the total memory to use.\n    min_bytes (int = 1000000): The minimum number of bytes to be returned.\n    available (bool = True): If True, consider available memory instead of total memory.</p>\n\n<p>Returns:\n    int: The dynamic memory limit in bytes.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">percentage</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">80.0</span>,</span><span class=\"param\">\t<span class=\"n\">min_bytes</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1000000</span>,</span><span class=\"param\">\t<span class=\"n\">available</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_str_a_glob", "modulename": "buteo.utils.core_utils", "qualname": "is_str_a_glob", "kind": "function", "doc": "<p>Check if a string is a glob.</p>\n\n<p>Args:\n    test_str (str): The string to check.</p>\n\n<p>Returns:\n    bool: True if the string is a glob, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">test_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.parse_glob_path", "modulename": "buteo.utils.core_utils", "qualname": "parse_glob_path", "kind": "function", "doc": "<p>Parses a string containing a glob path.</p>\n\n<p>Args:\n    test_str (str): The string to parse the pattern from.</p>\n\n<p>Returns:\n    list: A list of the matching paths.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">test_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.ensure_list", "modulename": "buteo.utils.core_utils", "qualname": "ensure_list", "kind": "function", "doc": "<p>Ensure that a variable is a list.</p>\n\n<p>Args:\n    variable_or_list (any): The variable to check.</p>\n\n<p>Returns:\n    list: The variable as a list.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variable_or_list</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.all_arrays_are_same_size", "modulename": "buteo.utils.core_utils", "qualname": "all_arrays_are_same_size", "kind": "function", "doc": "<p>Check if all arrays in a list are the same size.</p>\n\n<p>Args:\n    list_of_arrays (list): The list of numpy arrays to check.</p>\n\n<p>Returns:\n    bool: True if all arrays are the same size, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_of_arrays</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.force_garbage_collect", "modulename": "buteo.utils.core_utils", "qualname": "force_garbage_collect", "kind": "function", "doc": "<p>Clears the memory by deleting all objects in the main namespace.</p>\n\n<p>Args:\n    delete_functions (bool, optional): Whether to delete functions as well. Defaults to True.</p>\n\n<p>Returns:\n    None</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">delete_functions</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums", "modulename": "buteo.utils.gdal_enums", "kind": "module", "doc": "<h3 id=\"gdal-enum-functions\">GDAL Enum Functions</h3>\n\n<p>Functions to translate between <strong>GDAL</strong> and <strong>NumPy</strong> datatypes.</p>\n"}, {"fullname": "buteo.utils.gdal_enums.get_available_drivers", "modulename": "buteo.utils.gdal_enums", "qualname": "get_available_drivers", "kind": "function", "doc": "<p>Returns a list of all available drivers.</p>\n\n<p>Returns:\n    List[Dict[str, str]]: List of dicts containing available drivers. Each dict has the following keys:\n        - 'short_name' (str): Driver short name (e.g. GTiff).\n        - 'long_name' (str): Driver long name (e.g. GeoTiff).\n        - 'extension' (str): Driver file extension (e.g. tif). Note: Can be an empty string.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_valid_raster_driver_extensions", "modulename": "buteo.utils.gdal_enums", "qualname": "get_valid_raster_driver_extensions", "kind": "function", "doc": "<p>Returns a list of valid raster driver extensions.</p>\n\n<p>Returns:\n    list: List of valid raster driver extensions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_valid_vector_driver_extensions", "modulename": "buteo.utils.gdal_enums", "qualname": "get_valid_vector_driver_extensions", "kind": "function", "doc": "<p>Returns a list of valid vector driver extensions.</p>\n\n<p>Returns:\n    list: List of valid vector driver extensions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_valid_driver_extensions", "modulename": "buteo.utils.gdal_enums", "qualname": "get_valid_driver_extensions", "kind": "function", "doc": "<p>Returns a list of all valid driver extensions (<strong>GDAL</strong> + <strong>OGR</strong>).</p>\n\n<p>Returns:\n    list: List of all valid driver extensions.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_valid_driver_extension", "modulename": "buteo.utils.gdal_enums", "qualname": "is_valid_driver_extension", "kind": "function", "doc": "<p>Checks if a file extension is a valid GDAL or OGR driver extension.</p>\n\n<p>Args:\n    ext (str): The file extension.</p>\n\n<p>Returns:\n    bool: True if valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_valid_raster_driver_extension", "modulename": "buteo.utils.gdal_enums", "qualname": "is_valid_raster_driver_extension", "kind": "function", "doc": "<p>Checks if a raster file extension is a valid GDAL driver extension.</p>\n\n<p>Args:\n    ext (str): The file extension.</p>\n\n<p>Returns:\n    bool: True if valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_valid_vector_driver_extension", "modulename": "buteo.utils.gdal_enums", "qualname": "is_valid_vector_driver_extension", "kind": "function", "doc": "<p>Checks if a vector file extension is a valid <strong>OGR</strong> driver extension.</p>\n\n<p>Args:\n    ext (str): The file extension.</p>\n\n<p>Returns:\n    bool: True if valid, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.convert_raster_ext_to_driver_shortname", "modulename": "buteo.utils.gdal_enums", "qualname": "convert_raster_ext_to_driver_shortname", "kind": "function", "doc": "<p>Converts a raster file extension to a GDAL driver short name.</p>\n\n<p>Args:\n    ext (str): The file extension.</p>\n\n<p>Returns:\n    str: The GDAL driver short name (e.g. \"GTiff\").</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.convert_extension_to_driver_shortname", "modulename": "buteo.utils.gdal_enums", "qualname": "convert_extension_to_driver_shortname", "kind": "function", "doc": "<p>Converts a file extension to a driver short name for either OGR or GDAL.</p>\n\n<p>Args:\n    ext (str): The file extension.</p>\n\n<p>Returns:\n    str: The driver short name (e.g. GPKG or GTiff).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.convert_vector_ext_to_driver_shortname", "modulename": "buteo.utils.gdal_enums", "qualname": "convert_vector_ext_to_driver_shortname", "kind": "function", "doc": "<p>Converts a vector file extension to an <strong>OGR</strong> driver short_name name.</p>\n\n<p>Args:\n    ext (str): The file extension.</p>\n\n<p>Returns:\n    str: The driver short_name (e.g. GPKG).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.translate_resample_method", "modulename": "buteo.utils.gdal_enums", "qualname": "translate_resample_method", "kind": "function", "doc": "<p>Translate a string of a resampling method to a GDAL integer (e.g. gdal.GRA_NearestNeighbour).</p>\n\n<p>Args:\n    method (str): The resampling method.</p>\n\n<p>Returns:\n    int: The GDAL resampling integer (e.g. \"nearest\"=1).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.translate_gdal_dtype_to_str", "modulename": "buteo.utils.gdal_enums", "qualname": "translate_gdal_dtype_to_str", "kind": "function", "doc": "<p>Translates the <strong>GDAL</strong> datatype integer into a string. Can be used by <strong>NumPy</strong>.</p>\n\n<p>Args:\n    gdal_datatype_int (int): The <strong>GDAL</strong> datatype integer.</p>\n\n<p>Returns:\n    str: The translated string (e.g. <code>0=\"uint8\"</code>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gdal_datatype_int</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.translate_str_to_gdal_dtype", "modulename": "buteo.utils.gdal_enums", "qualname": "translate_str_to_gdal_dtype", "kind": "function", "doc": "<p>Translates the datatype string into a <strong>GDAL</strong> datatype integer. Can be used by <strong>GDAL</strong>.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>dtype_str (str): The datatype string (e.g. \"float32\").</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>int: The <strong>GDAL</strong> datatype integer corresponding to the input datatype string (e.g. <code>\"uint8\"=1</code>).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_default_nodata_value", "modulename": "buteo.utils.gdal_enums", "qualname": "get_default_nodata_value", "kind": "function", "doc": "<p>Returns the default fill value for masked numpy arrays.</p>\n\n<p>Args:\n    dtype: The data type of the array, can be either a numpy dtype object, a string representing a\n        data type (e.g. 'float32') or an integer representing a numpy data type (e.g. 5 for 'float32').</p>\n\n<p>Returns:\n    The default fill value for the given data type.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_range_for_numpy_datatype", "modulename": "buteo.utils.gdal_enums", "qualname": "get_range_for_numpy_datatype", "kind": "function", "doc": "<p>Returns the range of values that can be represented by a given numpy dtype.</p>\n\n<p>Args:\n    numpy_dtype (str/np.dtype): The numpy dtype.</p>\n\n<p>Returns:\n    tuple: (min_value, max_value) that can be represented by the numpy dtype.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">numpy_dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.value_is_within_datatype_range", "modulename": "buteo.utils.gdal_enums", "qualname": "value_is_within_datatype_range", "kind": "function", "doc": "<p>Checks if a value is within the range of a numpy datatype.</p>\n\n<p>Args:\n    value (int/float): The value to check.\n    numpy_dtype (str/np.dtype): The numpy dtype.</p>\n\n<p>Returns:\n    bool: True if the value is within the range of the numpy dtype, False otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">numpy_dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_gdal_datatype_a_float", "modulename": "buteo.utils.gdal_enums", "qualname": "is_gdal_datatype_a_float", "kind": "function", "doc": "<p>Checks if a GDAL datatype integer is a floating-point datatype:\n(Float32, Float64, cFloat32, cFloat64)</p>\n\n<p>Args:\n    gdal_dtype (int): The GDAL datatype integer.</p>\n\n<p>Returns:\n    bool: True if the datatype is a float, otherwise False.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gdal_dtype</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils", "modulename": "buteo.utils.gdal_utils", "kind": "module", "doc": "<h3 id=\"utility-functions-to-work-with-gdal\">Utility functions to work with GDAL</h3>\n\n<p>These functions are used to interact with basic GDAL objects.</p>\n\n<p>TODO:\n    * Should file_path_lists be able to handle mixed inputs?\n    * Make delete_raster_or_vector and the like accept a list of file paths?</p>\n"}, {"fullname": "buteo.utils.gdal_utils.default_creation_options", "modulename": "buteo.utils.gdal_utils", "qualname": "default_creation_options", "kind": "function", "doc": "<p>Takes a list of GDAL creation options and adds the following defaults to it if their not specified: </br></p>\n\n<ul>\n<li><code>\"TILED=YES\"</code></li>\n<li><code>\"NUM_THREADS=ALL_CPUS\"</code></li>\n<li><code>\"BIGG_TIF=YES\"</code></li>\n<li><code>\"COMPRESS=LZW\"</code></li>\n</ul>\n\n<p>If any of the options are already specified, they are not added.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>options</code> (_list_/None): The GDAL creation options to add to. (Default: <strong>None</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A list containing the default values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_default_projection", "modulename": "buteo.utils.gdal_utils", "qualname": "get_default_projection", "kind": "function", "doc": "<p>Get the default projection for a new raster.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The default projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_valid_datatype", "modulename": "buteo.utils.gdal_utils", "qualname": "is_valid_datatype", "kind": "function", "doc": "<p>Check if a file path has a valid GDAL or OGR driver.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file path is a valid GDAL or OGR driver, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_valid_raster_datatype", "modulename": "buteo.utils.gdal_utils", "qualname": "is_valid_raster_datatype", "kind": "function", "doc": "<p>Check if a file path has a valid GDAL driver.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file path is a valid GDAL Raster driver, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_valid_vector_datatype", "modulename": "buteo.utils.gdal_utils", "qualname": "is_valid_vector_datatype", "kind": "function", "doc": "<p>Check if a file path has a valid OGR driver.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file path is a valid OGR Vector driver, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.path_to_driver", "modulename": "buteo.utils.gdal_utils", "qualname": "path_to_driver", "kind": "function", "doc": "<p>Convert a file path to a GDAL or OGR driver ShortName (e.g. \"GTiff\" for \"new_york.tif\")</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to convert.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The GDAL or OGR driver ShortName.</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p><code>ValueError</code>: If the file path is not a valid GDAL or OGR driver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.path_to_driver_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "path_to_driver_vector", "kind": "function", "doc": "<p>Convert a file path to an OGR driver ShortName (e.g. \"FlatGeoBuf\" for \"new_york.fgb\")</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to convert.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The OGR driver ShortName.</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p><code>ValueError</code>: If the file path is not a valid OGR driver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.path_to_driver_raster", "modulename": "buteo.utils.gdal_utils", "qualname": "path_to_driver_raster", "kind": "function", "doc": "<p>Convert a file path to a GDAL driver ShortName (e.g. \"GTiff\" for \"new_york.tif\")</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to convert.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The GDAL driver ShortName.</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p><code>ValueError</code>: If the file path is not a valid GDAL driver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_gdal_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "get_gdal_memory", "kind": "function", "doc": "<p>Get at list of all active memory layers in GDAL.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_in_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "is_in_memory", "kind": "function", "doc": "<p>Check if vector is in memory</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_or_vector</code> (_str_/_gdal.Dataset_/ogr.DataSource): The vector or raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the vector is in memory, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_or_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.delete_if_in_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "delete_if_in_memory", "kind": "function", "doc": "<p>Delete raster or vector if it is in memory</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_or_vector</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The vector or raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the vector is deleted, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_or_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.delete_if_in_memory_list", "modulename": "buteo.utils.gdal_utils", "qualname": "delete_if_in_memory_list", "kind": "function", "doc": "<p>Deletes a list of raster or vector if they are in memory</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>list_of_raster_or_vectors</code> (_list_): The vector(s) or raster(s) to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if they were all deleted, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_of_raster_or_vectors</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.delete_raster_or_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "delete_raster_or_vector", "kind": "function", "doc": "<p>Delete raster or vector. Can be used on both in memory and on disk.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_or_vector</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The vector or raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file is deleted, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_or_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_empty", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_empty", "kind": "function", "doc": "<p>Check if a raster has bands or zero width and zero height.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_gdal.Dataset_): The raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the raster has bands, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_vector_empty", "modulename": "buteo.utils.gdal_utils", "qualname": "is_vector_empty", "kind": "function", "doc": "<p>Check if a vector has features with geometries</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_ogr.DataSource_): The vector to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the vector has features, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster", "kind": "function", "doc": "<p>Checks if a variable is a valid raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster is considered invalid. (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the variable is a valid raster, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of rasters.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster_list</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster_list</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_path_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_path_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_path_list</span>, </span><span class=\"param\"><span class=\"n\">allow_none</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "is_vector", "kind": "function", "doc": "<p>Checks if a variable is a valid vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_vector</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty vector is considered invalid. (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the variable is a valid vector, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_vector</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_vector_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_vector_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of vectors.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_vector_list</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty vector is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_vector_list</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_or_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_or_vector", "kind": "function", "doc": "<p>Checks if a variable is a valid raster or vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster_or_vector</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster or vector is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster_or_vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_or_vector_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_or_vector_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of rasters or vectors.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster_or_vector_list</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster or vector is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster_or_vector_list</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.clear_gdal_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "clear_gdal_memory", "kind": "function", "doc": "<p>Clears all gdal memory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.gdal_print_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "gdal_print_memory", "kind": "function", "doc": "<p>Prints all gdal memory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.create_memory_path", "modulename": "buteo.utils.gdal_utils", "qualname": "create_memory_path", "kind": "function", "doc": "<p>Gets a memory path from a string in the format: </br>\n<code>/vsimem/prefix_basename_time_uuid_suffix.ext</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>path</code> (_str_): The path to the original file. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>prefix</code> (_str_): The prefix to add to the memory path. (<strong>Default</strong>: <code>\"\"</code>) </br>\n<code>suffix</code> (_str_): The suffix to add to the memory path. (<strong>Default</strong>: <code>\"\"</code>) </br>\n<code>add_uuid</code> (_bool_): If True, add a uuid to the memory path. (<strong>Default</strong>: <code>True</code>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): A string to the memory path. <code>/vsimem/prefix_basename_time_uuid_suffix.ext</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_path_from_dataset", "modulename": "buteo.utils.gdal_utils", "qualname": "get_path_from_dataset", "kind": "function", "doc": "<p>Gets the path from a datasets. Can be vector or raster, string or opened.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The dataset.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>dataset_type</code> (_str_): The type of dataset. If not specified, it is guessed. (<strong>Default</strong>: <code>None</code>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The path to the dataset.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">dataset_type</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_path_from_dataset_list", "modulename": "buteo.utils.gdal_utils", "qualname": "get_path_from_dataset_list", "kind": "function", "doc": "<p>Gets the paths from a list of datasets.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>datasets</code> (_list_): The list of datasets.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>allow_mixed</code> (_bool_): If True, allow mixed raster/vector datasets. (<strong>Default</strong>: <code>False</code>) </br>\n<code>dataset_type</code> (_str_/_None_): The type of dataset. If not specified, it is guessed. (<strong>Default</strong>: <code>None</code>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">datasets</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">allow_mixed</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">dataset_type</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.convert_geom_to_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "convert_geom_to_vector", "kind": "function", "doc": "<p>Converts a geometry to a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geom</code> (_ogr.Geometry_): The geometry to convert.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>layer_name</code> (_str_): The name of the layer. (Default: <strong>\"geom\"</strong>)\n<code>add_uuid</code> (_bool_): If <strong>True</strong>, a UUID will be added to the layer. (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.DataSource_): The vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geom</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.import_esri_projection", "modulename": "buteo.utils.gdal_utils", "qualname": "import_esri_projection", "kind": "function", "doc": "<p>Imports a projection from an ESRI code.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">esri_code</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.parse_projection", "modulename": "buteo.utils.gdal_utils", "qualname": "parse_projection", "kind": "function", "doc": "<p>Parses a gdal, ogr og osr data source and extraction the projection. If\na string or int is passed, it attempts to open it and return the projection as\nan osr.SpatialReference.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>projection</code> (_str_/_int_/_gdal.Dataset_/_ogr.DataSource_/_osr.SpatialReference_): The projection to parse.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>return_wkt</code> (_bool_): If <strong>True</strong> the projection will be returned as a WKT string, otherwise an osr.SpatialReference is returned. (Default: <strong>False</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">projection</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">return_wkt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.projections_match", "modulename": "buteo.utils.gdal_utils", "qualname": "projections_match", "kind": "function", "doc": "<p>Tests if two projection sources have the same projection.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>source1</code> (_str_/_int_/_gdal.Dataset_/_ogr.DataSource_/_osr.SpatialReference_): The first projection to parse.\n<code>source1</code> (_str_/_int_/_gdal.Dataset_/_ogr.DataSource_/_osr.SpatialReference_): The second projection to parse.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the projections match, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source1</span>, </span><span class=\"param\"><span class=\"n\">source2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.projections_match_list", "modulename": "buteo.utils.gdal_utils", "qualname": "projections_match_list", "kind": "function", "doc": "<p>Tests if a list of projection sources all have the same projection.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>list_of_projection_sources</code> (_list_): A list of projections to test.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the projections match, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_of_projection_sources</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.parse_raster_size", "modulename": "buteo.utils.gdal_utils", "qualname": "parse_raster_size", "kind": "function", "doc": "<p>Parses the raster size from either a list of numbers or a GDAL raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>target_size</code> (_any_): The target to parse raster_size from.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>target_in_pixels</code> (_bool_): If <strong>True</strong>, the target size is in pixels, otherwise it is in the rasters_units. (Default: <strong>False</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_tuple_): The raster size in the form of: <code>(x_res, y_res, x_size, y_size)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">target_in_pixels</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_gdalwarp_ram_limit", "modulename": "buteo.utils.gdal_utils", "qualname": "get_gdalwarp_ram_limit", "kind": "function", "doc": "<p>Converts a RAM limit to a GDALWarp RAM limit.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>limit</code> (_str_/_int_): The RAM limit to convert. Can be auto, a percentage \"80%\" or a number in MB.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_int_): The GDALWarp RAM limit in bytes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">limit_in_mb</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.to_array_list", "modulename": "buteo.utils.gdal_utils", "qualname": "to_array_list", "kind": "function", "doc": "<p>Converts a numpy array or list of numpy arrays to a list of arrays.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>array_or_list_of_array</code> (_numpy.ndarray_/_list_/_str_): The numpy array or list of numpy arrays to convert to a list of arrays.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The list of arrays.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array_or_list_of_array</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.to_band_list", "modulename": "buteo.utils.gdal_utils", "qualname": "to_band_list", "kind": "function", "doc": "<p>Converts a band number or list of band numbers to a list of band numbers.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>band_number</code> (_int_/_float_/_list_): The band number or list of band numbers to convert to a list of band numbers. </br>\n<code>band_count</code> (_int_): The number of bands in the raster. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The list of band numbers.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">band_number</span>, </span><span class=\"param\"><span class=\"n\">band_count</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.create_output_path", "modulename": "buteo.utils.gdal_utils", "qualname": "create_output_path", "kind": "function", "doc": "<p>Prepares a raster/vector for writing. Generates an output path. If no output path is\nspecified, the raster is written to memory. If a folder is given, that output directory is used\nalong with the input filename.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset_path</code> (_gdal.Dataset_/_ogr.DataSource_/_str_): A <strong>GDAL</strong> or <strong>OGR</strong> dataframe, a name (with extension) of a raster </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): A path to a directory to write the raster to. (Default: <strong>None</strong>). </br>\n<code>overwrite</code> (_bool_): If True, the output raster will be overwritten if it already exists. (Default: <strong>True</strong>). </br>\n<code>prefix</code> (_str_): A string to prepend to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>suffix</code> (_str_): A string to append to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>add_uuid</code> (_bool_): If True, a UUID will be added to the output filename. (Default: <strong>False</strong>). </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): A path to the output raster or a list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset_path</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ext</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.create_output_path_list", "modulename": "buteo.utils.gdal_utils", "qualname": "create_output_path_list", "kind": "function", "doc": "<p>Prepares a raster/vector or a list of rasters/vectors for writing. Generates output paths. If no output paths are\nspecified, the rasters are written to memory. If a folder is given, the output directory is chosen,\nthe input filenames remain the same. If a specific path is used it must be the same length as the\ninput.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset_path</code> (_gdal.Dataset_/_ogr.DataSource_/_str_/_list__): A <strong>GDAL</strong> or <strong>OGR</strong> dataframe, a path to a raster or a list of same. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): A path to a directory to write the raster to. (Default: <strong>None</strong>). </br>\n<code>overwrite</code> (_bool_): If True, the output raster will be overwritten if it already exists. (Default: <strong>True</strong>). </br>\n<code>prefix</code> (_str_): A string to prepend to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>suffix</code> (_str_): A string to append to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>add_uuid</code> (_bool_): If True, a UUID will be added to the output filename. (Default: <strong>False</strong>). </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): A path to the output raster or a list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset_path</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ext</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.save_dataset_to_disk", "modulename": "buteo.utils.gdal_utils", "qualname": "save_dataset_to_disk", "kind": "function", "doc": "<p>Writes a dataset to disk. Can be a raster or a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource_/_list_): The dataset(s) to save. </br>\n<code>out_path</code> (_str_/_list_): The path(s) to save the dataset(s) to. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>overwrite</code> (_bool_): Whether to overwrite the file if it already exists. (Default: <strong>True</strong>) </br>\n<code>creation_options</code> (_list_/_None_): A list of creation options to pass to GDAL if saving as raster. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Whether to add a UUID to the file name. (Default: <strong>False</strong>) </br></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.save_dataset_to_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "save_dataset_to_memory", "kind": "function", "doc": "<p>Writes a dataset to memory. Can be a raster or a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource_/_list_): The dataset(s) to save. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>overwrite</code> (_bool_): Whether to overwrite the file if it already exists. (Default: <strong>True</strong>) </br>\n<code>creation_options</code> (_list_/_None_): A list of creation options to pass to GDAL if saving as raster. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Whether to add a UUID to the file name. (Default: <strong>True</strong>) </br></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector", "modulename": "buteo.vector", "kind": "module", "doc": "<p>Work with vector data and attributes with ease.</p>\n"}, {"fullname": "buteo.vector.buffer", "modulename": "buteo.vector.buffer", "kind": "module", "doc": "<h3 id=\"clip-vectors-to-other-geometries\">Clip vectors to other geometries</h3>\n\n<p>Clip vector files with other geometries. Can come from rasters or vectors.</p>\n"}, {"fullname": "buteo.vector.buffer.buffer_vector", "modulename": "buteo.vector.buffer", "qualname": "buffer_vector", "kind": "function", "doc": "<p>Buffers a vector with a fixed distance or an attribute.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): Vector(s) to buffer. </br>\n<code>distance</code> (_int_/_float_/_str_): The distance to buffer with. If string, uses the attribute of that name. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): Output path. If None, memory vectors are created. (Default: <strong>None</strong>) </br>\n<code>prefix</code> (_str_): Prefix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): Suffix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add UUID to the output path. (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow lists of vectors as input. (Default: <strong>True</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite output if it already exists. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Output path(s) of clipped vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.clip", "modulename": "buteo.vector.clip", "kind": "module", "doc": "<h3 id=\"clip-vectors-to-other-geometries\">Clip vectors to other geometries</h3>\n\n<p>Clip vector files with other geometries. Can come from rasters or vectors.</p>\n"}, {"fullname": "buteo.vector.clip.clip_vector", "modulename": "buteo.vector.clip", "qualname": "clip_vector", "kind": "function", "doc": "<p>Clips a vector to a geometry.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): Vector(s) to clip. </br>\n<code>clip_geom</code> (_str_/_ogr.Geometry_): Vector to clip with. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): Output path. If None, memory vectors are created. (Default: <strong>None</strong>) </br>\n<code>to_extent</code> (_bool_): Clip to extent. (Default: <strong>False</strong>) </br>\n<code>target_projection</code> (_str_/_ogr.DataSource_/_gdal.Dataset_/_osr.SpatialReference_/_int_/_None_): Target projection. (Default: <strong>None</strong>) </br>\n<code>preserve_fid</code> (_bool_): Preserve fid. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): Prefix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): Suffix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add UUID to the output path. (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow lists of vectors as input. (Default: <strong>True</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite output if it already exists. (Default: <strong>True</strong>) </br>\n<code>promote_to_multi</code> (_bool_): Should POLYGON by promoted to MULTIPOLYGON.. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Output path(s) of clipped vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">to_extent</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">target_projection</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">preserve_fid</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">promote_to_multi</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.convert_parts", "modulename": "buteo.vector.convert_parts", "kind": "module", "doc": "<h3 id=\"convert-geometry-composition\">Convert geometry composition.</h3>\n\n<p>Convert geometries from multiparts and singleparts and vice versa.</p>\n"}, {"fullname": "buteo.vector.convert_parts.singlepart_to_multipart", "modulename": "buteo.vector.convert_parts", "qualname": "singlepart_to_multipart", "kind": "function", "doc": "<p>Converts a singlepart vector to multipart.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): The vector(s) to convert. </br></p>\n\n<h2 id=\"kvargs\">Kvargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): The path(s) to the output vector. If None a memory output is produced. (Default: <strong>None</strong>) </br>\n<code>add_index</code> (_bool_): Add an geospatial index to the output vector. (Default: <strong>True</strong>) </br>\n<code>process_layer</code> (_int_): The layer index to process. (Default: <strong>-1</strong>) </br>\n<code>prefix</code> (_str_): The prefix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add a UUID field to the output vector. (Default: <strong>False</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite the output vector if it already exists. (Default: <strong>True</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow the input to be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the output vector.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.convert_parts.multipart_to_singlepart", "modulename": "buteo.vector.convert_parts", "qualname": "multipart_to_singlepart", "kind": "function", "doc": "<p>Converts a multipart vector to singlepart.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): The vector(s) to convert. </br></p>\n\n<h2 id=\"kvargs\">Kvargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): The path(s) to the output vector. If None a memory output is produced. (Default: <strong>None</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite the output vector if it already exists. (Default: <strong>True</strong>) </br>\n<code>add_index</code> (_bool_): Add an geospatial index to the output vector. (Default: <strong>True</strong>) </br>\n<code>process_layer</code> (_int_): The layer index to process. (Default: <strong>-1</strong>) </br>\n<code>verbose</code> (_bool_): Print progress. (Default: <strong>False</strong>) </br>\n<code>prefix</code> (_str_): The prefix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add a UUID field to the output vector. (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow the input to be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the output vector.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector", "modulename": "buteo.vector.core_vector", "kind": "module", "doc": "<h3 id=\"basic-io-functions-for-working-with-vectprs\">Basic IO functions for working with Vectprs</h3>\n\n<p>The basic module for interacting with vector data</p>\n"}, {"fullname": "buteo.vector.core_vector.open_vector", "modulename": "buteo.vector.core_vector", "qualname": "open_vector", "kind": "function", "doc": "<p>Opens a vector to an ogr.Datasource class.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_gdal.Dataset_): The vector to open. If a\nraster is supplied the bounding box is opened as a vector. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>writeable</code> (_bool_): If True, the vector is opened in write mode. (Default: <strong>True</strong>) </br>\n<code>allow_raster</code> (_bool_): If True, a raster will be opened as a vector bounding box. (Default: <strong>True</strong>) </br>\n<code>allow_lists</code> (_bool_): If True, the input can be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.DataSource_/_list_): The opened vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">writeable</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">allow_raster</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_to_metadata", "modulename": "buteo.vector.core_vector", "qualname": "vector_to_metadata", "kind": "function", "doc": "<p>Creates a dictionary with metadata about the vector layer.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_ogr.DataSource_/_str_/_list_): A vector layer(s) or path(s) to a vector file.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>allow_lists</code> (_bool_): If <strong>True</strong>, vector can be a list of vector layers or paths. If <code>False</code>, <code>vector</code> must be a single vector layer or path. (default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_/_list_) A dictionary with metadata about the vector layer(s) or a list of dictionaries with metadata about the vector layer(s).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.filter_vector", "modulename": "buteo.vector.core_vector", "qualname": "filter_vector", "kind": "function", "doc": "<p>Filters a vector using its attribute table and a function.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_ogr.DataSource_/_str_/_list_): A vector layer(s) or path(s) to a vector file.\n<code>filter_function</code> (_function_): A function that takes a dictionary of attributes and returns a boolean.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_): Path to the output vector file. If <code>None</code>, a memory vector will be created. (Default: <strong>None</strong>) </br>\n<code>process_layer</code> (_int_): The index of the layer to process. If <code>-1</code>, all layers will be processed. (Default: <strong>-1</strong>) </br>\n<code>allow_lists</code> (_bool_): If <strong>True</strong>, vector can be a list of vector layers or paths. If <code>False</code>, <code>vector</code> must be a single vector layer or path. (default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the output vector file. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the output vector file. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): If <strong>True</strong>, a UUID will be added to the output vector file. (Default: <strong>False</strong>) </br>\n<code>overwrite</code> (_bool_): If <strong>True</strong>, the output vector file will be overwritten if it already exists. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Path(s) to the output vector file(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">filter_function</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_add_index", "modulename": "buteo.vector.core_vector", "qualname": "vector_add_index", "kind": "function", "doc": "<p>Adds a spatial index to the vector in place, if it doesn't have one.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p>(_ogr.DataSource_/_str_/_list_): A vector layer(s) or path(s) to add indices to.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>allow_lists</code> (_bool_): If <strong>True</strong>, vector can be a list of vector layers or paths. If <code>False</code>, <code>vector</code> must be a single vector layer or path. (default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Path(s) to the input rasters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_add_shapes_in_place", "modulename": "buteo.vector.core_vector", "qualname": "vector_add_shapes_in_place", "kind": "function", "doc": "<p>Adds shape calculations to a vector such as area and perimeter.\nCan also add compactness measurements.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): Vector layer(s) or path(s) to vector layer(s).</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>shapes</code> (_list_/_None_): The shapes to calculate. The following a possible: </br>\n    * Area          (In same unit as projection)\n    * Perimeter     (In same unit as projection)\n    * IPQ           (0-1) given as (4<em>Pi</em>Area)/(Perimeter ** 2)\n    * Hull Area     (The area of the convex hull. Same unit as projection)\n    * Compactness   (0-1) given as sqrt((area / hull_area) * ipq)\n    * Centroid      (Coordinate of X and Y)\nThe default is all shapes. </br>\n<code>prefix</code> (_str_): Prefix to add to the field names.\n<code>allow_lists</code> (_bool_): If True, will accept a list of vectors. If False, will raise an error if a list is passed.\n<code>verbose</code> (_bool_): If True, will print progress.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Path(s) to the original rasters that have been augmented in place.</p>\n\n<p>Returns:\n    Either the path to the updated vector or a list of the input vectors.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">shapes</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_get_attribute_table", "modulename": "buteo.vector.core_vector", "qualname": "vector_get_attribute_table", "kind": "function", "doc": "<p>Get the attribute table(s) of a vector.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">include_fids</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">include_geometry</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">include_attributes</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_filter_layer", "modulename": "buteo.vector.core_vector", "qualname": "vector_filter_layer", "kind": "function", "doc": "<p>Filters a multi-layer vector source to a single layer.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">layer_name_or_idx</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_layer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.dissolve", "modulename": "buteo.vector.dissolve", "kind": "module", "doc": "<h3 id=\"dissolve-vector-geometries\">Dissolve vector geometries.</h3>\n\n<p>Dissolve vectors by attributes or geometry.</p>\n"}, {"fullname": "buteo.vector.dissolve.dissolve_vector", "modulename": "buteo.vector.dissolve", "qualname": "dissolve_vector", "kind": "function", "doc": "<p>Clips a vector to a geometry.\nArgs:\n    vector (list of vectors/path/vector): The vectors(s) to clip.</p>\n\n<pre><code>clip_geom (list of geom/path/vector/rasters): The geometry to use\nfor the clipping\n</code></pre>\n\n<p>**kwargs:</p>\n\n<p>Returns:\n    A clipped ogr.Datasource or the path to one.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">attribute</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.grid", "modulename": "buteo.vector.grid", "kind": "module", "doc": "<p>Create vector grids from references or hardcode</p>\n"}, {"fullname": "buteo.vector.grid.create_grid", "modulename": "buteo.vector.grid", "qualname": "create_grid", "kind": "function", "doc": "<p>Not implemented.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.intersect", "modulename": "buteo.vector.intersect", "kind": "module", "doc": "<h3 id=\"calculate-intersections\">Calculate intersections</h3>\n\n<p>Calculate and tests the intersections between geometries.</p>\n"}, {"fullname": "buteo.vector.intersect.intersect_vector", "modulename": "buteo.vector.intersect", "qualname": "intersect_vector", "kind": "function", "doc": "<p>Clips a vector to a geometry.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): The vector(s) to intersect. </br>\n<code>clip_geom</code> (_str_/_ogr.Geometry_): The geometry to intersect the vector(s) with. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The path(s) to save the clipped vector(s) to. (Default: <strong>None</strong>) </br>\n<code>process_layer</code> (_int_): The layer to process in the vector(s). (Default: <strong>0</strong>) </br>\n<code>process_layer_clip</code> (_int_): The layer to process in the clip geometry. (Default: <strong>0</strong>) </br>\n<code>add_index</code> (_bool_): Add a geospatial index to the vector(s). (Default: <strong>True</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite the output vector(s) if they already exist. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the output vector(s). (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the output vector(s). (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add a UUID to the output vector(s). (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow the input to be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the clipped vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer_clip</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.merge", "modulename": "buteo.vector.merge", "kind": "module", "doc": "<h3 id=\"merge-vectors\">Merge vectors.</h3>\n\n<p>Merges vectors into a single vector file.</p>\n"}, {"fullname": "buteo.vector.merge.merge_vectors", "modulename": "buteo.vector.merge", "qualname": "merge_vectors", "kind": "function", "doc": "<p>Merge vectors to a single geopackage.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vectors</code> (_list_): List of vectors to merge.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_): Path to output vector. (Default: <strong>None</strong>) </br>\n<code>preserve_fid</code> (_bool_): Preserve FIDs? (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): Path to output vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vectors</span>, </span><span class=\"param\"><span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">preserve_fid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.rasterize", "modulename": "buteo.vector.rasterize", "kind": "module", "doc": "<h3 id=\"rasterize-vectors\">Rasterize vectors.</h3>\n\n<p>Functions to rasterize vectors to rasters.</p>\n\n<p>TODO:\n    * Add support for projections</p>\n"}, {"fullname": "buteo.vector.rasterize.rasterize_vector", "modulename": "buteo.vector.rasterize", "qualname": "rasterize_vector", "kind": "function", "doc": "<p>Rasterize a vector to a raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource): The vector to rasterize. </br>\n<code>pixel_size</code> (_float_/_int_): The pixel size of the raster. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): Path to output raster. (Default: <strong>None</strong>) </br>\n<code>extent</code> (_list_/_None_): Extent of raster. (Default: <strong>None</strong>) </br>\n<code>all_touch</code> (_bool_): All touch? (Default: <strong>False</strong>) </br>\n<code>dtype</code> (_str_): Data type of raster. (Default: <strong>\"uint8\"</strong>) </br>\n<code>optim</code> (_str_): Optimization for raster or vector? (Default: <strong>\"raster\"</strong>) </br>\n<code>band</code> (_int_): Band to rasterize. (Default: <strong>1</strong>) </br>\n<code>fill_value</code> (_int_/_float_): Fill value. (Default: <strong>0</strong>) </br>\n<code>nodata_value</code> (_int_/_float_/_None_): Nodata value. (Default: <strong>None</strong>) </br>\n<code>check_memory</code> (_bool_): Check memory? (Default: <strong>True</strong>) </br>\n<code>burn_value</code> (_int_/_float_): Value to burn. (Default: <strong>1</strong>) </br>\n<code>attribute</code> (_str_/_None_): Attribute to burn. (Default: <strong>None</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): Path to output raster.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_size</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">all_touch</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;uint8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">optim</span><span class=\"o\">=</span><span class=\"s1\">&#39;raster&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">band</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fill_value</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">check_memory</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">burn_value</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">attribute</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.reproject", "modulename": "buteo.vector.reproject", "kind": "module", "doc": "<h3 id=\"reproject-vectors\">Reproject vectors.</h3>\n\n<p>Functions to reproject vectors. References can be both vector and raster.</p>\n"}, {"fullname": "buteo.vector.reproject.reproject_vector", "modulename": "buteo.vector.reproject", "qualname": "reproject_vector", "kind": "function", "doc": "<p>Reprojects a vector given a target projection.</p>\n\n<p>Args:\n    vector (_path_/_vector_): The vector to reproject.</p>\n\n<pre><code>projection (_str_/_int_/_vector_/_raster_): The projection is infered from\nthe input. The input can be: WKT proj, EPSG proj, Proj, or read from a\nvector or raster datasource either from path or in-memory.\n</code></pre>\n\n<p>**kwargs:\n    out_path (_path_/_None_): The destination to save to. If None then\n    the output is an in-memory raster.</p>\n\n<pre><code>copy_if_same (_bool_): Create a copy, even if the projections are the same.\n\noverwite (_bool_): Is it possible to overwrite the out_path if it exists.\n</code></pre>\n\n<p>Returns:\n    An in-memory vector. If an out_path is given, the output is a string containing\n    the path to the newly created vecotr.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">copy_if_same</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.split", "modulename": "buteo.vector.split", "kind": "module", "doc": "<h3 id=\"split-functions-for-vector-layers\">Split functions for vector layers.</h3>\n\n<p>Dissolve vectors by attributes or geometry.</p>\n"}, {"fullname": "buteo.vector.split.split_vector_by_fid", "modulename": "buteo.vector.split", "qualname": "split_vector_by_fid", "kind": "function", "doc": "<p>Split a vector by feature id.</p>\n\n<p>Args:\n    vector (ogr.DataSource): Input vector.</p>\n\n<p>Keyword Args:\n    out_folder (str=None): Output folder.\n    prefix (str=''): Prefix for output files.\n    suffix (str=''): Suffix for output files.</p>\n\n<p>Returns:\n    str: Output paths.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_folder</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.zonal_statistics", "modulename": "buteo.vector.zonal_statistics", "kind": "module", "doc": "<p></p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();