window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "buteo", "modulename": "buteo", "kind": "module", "doc": "<h1 id=\"buteo-geospatial-analysis-meets-ai\">Buteo - Geospatial Analysis Meets AI</h1>\n\n<p>Buteo is a toolbox designed to simplify the process of working with geospatial data in machine learning. It includes tools for reading, writing, and processing geospatial data, as well as tools for creating labels from vector data and generating patches from geospatial data. Buteo makes it easy to ingest data, create training data, and perform inference on geospatial data.</p>\n\n<p>Please note that Buteo is under active development, and its API may not be entirely stable. Feel free to report any bugs or suggest improvements.</p>\n\n<p>For documentation, visit: <a href=\"https://casperfibaek.github.io/buteo/\">https://casperfibaek.github.io/buteo/</a></p>\n\n<p><strong>Dependencies</strong> </br>\n<code>numba</code> (<a href=\"https://numba.pydata.org/\">https://numba.pydata.org/</a>) </br>\n<code>gdal</code> (<a href=\"https://gdal.org/\">https://gdal.org/</a>) </br></p>\n\n<p><strong>Installation</strong> </br>\nUsing pip:</p>\n\n<pre><code>pip install buteo\n</code></pre>\n\n<p>Using conda:</p>\n\n<pre><code>conda install gdal\npip install buteo\n</code></pre>\n\n<p><strong>Quickstart</strong></p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n\n<span class=\"n\">OUTDIR</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/output/dir&quot;</span>\n\n<span class=\"c1\"># Reproject (and other functions) to references. (Vector and raster)</span>\n<span class=\"n\">vector_file_correct_projection</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/vector/file.gpkg&quot;</span>\n<span class=\"n\">raster_files_wrong_projection</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/raster/files/*.tif:glob&quot;</span>\n\n<span class=\"n\">paths_to_reprojected_rasters</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">reproject_raster</span><span class=\"p\">(</span>\n    <span class=\"n\">raster_files_with_wrong_projection</span><span class=\"p\">,</span>\n    <span class=\"n\">vector_file_with_correct_projection</span><span class=\"p\">,</span>\n    <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"n\">outdir</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">paths_to_reprojected_rasters</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"p\">[</span><span class=\"n\">path</span><span class=\"o\">/</span><span class=\"n\">to</span><span class=\"o\">/</span><span class=\"n\">output</span><span class=\"o\">/</span><span class=\"nb\">dir</span><span class=\"o\">/</span><span class=\"n\">file1</span><span class=\"o\">.</span><span class=\"n\">tif</span><span class=\"p\">,</span> <span class=\"n\">path</span><span class=\"o\">/</span><span class=\"n\">to</span><span class=\"o\">/</span><span class=\"n\">output</span><span class=\"o\">/</span><span class=\"nb\">dir</span><span class=\"o\">/</span><span class=\"n\">file2</span><span class=\"o\">.</span><span class=\"n\">tif</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n\n<span class=\"c1\"># Align, stack, and make patches from rasters</span>\n\n<span class=\"n\">SRCDIR</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/src/dir/&quot;</span>\n\n<span class=\"n\">paths_to_aligned_rasters_in_memory</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">align_rasters</span><span class=\"p\">(</span>\n    <span class=\"n\">SRCDIR</span> <span class=\"o\">+</span> <span class=\"s2\">&quot;*.tif:glob&quot;</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">stacked_numpy_arrays</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span>\n    <span class=\"n\">paths_to_aligned_rasters_in_memory</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"n\">patches</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">array_to_patches</span><span class=\"p\">(</span>\n    <span class=\"n\">path_to_stacked_numpy_arrays</span><span class=\"p\">,</span>\n    <span class=\"mi\">256</span><span class=\"p\">,</span>\n    <span class=\"n\">offsets_y</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>\n    <span class=\"n\">offsets_x</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># patches_nr, height, width, channels</span>\n<span class=\"n\">patches</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">([</span><span class=\"mi\">10000</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">256</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">])</span>\n</code></pre>\n</div>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">buteo</span> <span class=\"k\">as</span> <span class=\"nn\">beo</span>\n\n<span class=\"c1\"># Predict a raster using a model</span>\n\n<span class=\"n\">RASTER_PATH</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/raster/raster.tif&quot;</span>\n<span class=\"n\">RASTER_OUT_PATH</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;path/to/raster/raster_pred.tif&quot;</span>\n\n<span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">raster_to_array</span><span class=\"p\">(</span><span class=\"n\">RASTER_PATH</span><span class=\"p\">)</span>\n\n<span class=\"n\">callback</span> <span class=\"o\">=</span> <span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">predict</span> <span class=\"c1\"># from pytorch, keras, etc..</span>\n\n<span class=\"c1\"># Predict the raster using overlaps, and borders.</span>\n<span class=\"c1\"># Merge using different methods. (median, mad, mean, mode, ...)</span>\n<span class=\"n\">predicted</span> <span class=\"o\">=</span> <span class=\"n\">predict_array</span><span class=\"p\">(</span>\n    <span class=\"n\">array</span><span class=\"p\">,</span>\n    <span class=\"n\">callback</span><span class=\"p\">,</span>\n    <span class=\"n\">tile_size</span><span class=\"o\">=</span><span class=\"mi\">256</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\n<span class=\"c1\"># Write the predicted raster to disk</span>\n<span class=\"n\">beo</span><span class=\"o\">.</span><span class=\"n\">array_to_raster</span><span class=\"p\">(</span>\n    <span class=\"n\">predicted</span><span class=\"p\">,</span>\n    <span class=\"n\">reference</span><span class=\"o\">=</span><span class=\"n\">RASTER_PATH</span><span class=\"p\">,</span>\n    <span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"n\">RASTER_OUT_PATH</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n</code></pre>\n</div>\n\n<p></br></p>\n\n<table>\n<thead>\n<tr>\n  <th>Example Colabs</th>\n  <th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>Create labels from OpenStreetMap data</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/create_labels_from_osm_data.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Scheduled cleaning of geospatial data</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/rocket_example.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Clip and remove noise from rasters</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/clip_and_remove_noise_raster.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Sharpen nightlights data</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/process_nightlights.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n<tr>\n  <td>Filters and morphological operations</td>\n  <td><a href=\"https://colab.research.google.com/github/casperfibaek/buteo/blob/master/examples/filters_and_morphology.ipynb\"><img src=\"https://colab.research.google.com/assets/colab-badge.svg\" alt=\"Open All Collab\" /></a></td>\n</tr>\n</tbody>\n</table>\n\n<p></br></p>\n\n<p>The toolbox is being developed by ESA-Philab, NIRAS, and Aalborg University.</p>\n\n<h1 id=\"dependencies\">Dependencies</h1>\n\n<p>gdal\nnumba</p>\n\n<p>optional:\norfeo-toolbox\nesa-snap</p>\n\n<h1 id=\"build-steps\">Build steps</h1>\n\n<p>python -m run_tests; python -m build_documentation;\npython -m build; python -m twine upload dist/*;</p>\n\n<p>python -m run_tests &amp;&amp; python -m build_documentation\npython -m build &amp;&amp; python -m twine upload dist/*</p>\n\n<p>python -m build_anaconda -forge -clean;</p>\n"}, {"fullname": "buteo.ai", "modulename": "buteo.ai", "kind": "module", "doc": "<p>Tools for working with sentinel data</p>\n"}, {"fullname": "buteo.ai.augmentation", "modulename": "buteo.ai.augmentation", "kind": "module", "doc": "<p>This module contains functions for augmenting images that are\nsuited to remote sensing imagery.</p>\n"}, {"fullname": "buteo.ai.augmentation.apply_augmentations", "modulename": "buteo.ai.augmentation", "qualname": "apply_augmentations", "kind": "function", "doc": "<p>Apply a list of augmentations to a batch of images.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>batch_x (np.ndarray):</strong>  The batch of images to augment.</li>\n<li><strong>batch_y (np.ndarray/None=None):</strong>  The batch of labels to augment.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>augmentations (list/dict=None): The list of augmentations to apply.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple(np.ndarray, np.ndarray): The augmented batch of images and labels (if provided).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">batch_x</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">batch_y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">augmentations</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation.augmentation_generator", "modulename": "buteo.ai.augmentation", "qualname": "augmentation_generator", "kind": "function", "doc": "<p>Generate batches of augmented data.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The data to augment.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>y (np.ndarray): The labels for the data.\n  batch_size (int): The size of the batches to generate.\n  augmentations (list): The augmentations to apply.\n  shuffle (bool): Whether to shuffle the data before generating batches.\n  seed (int): The seed to use for shuffling.\n  channel_last (bool): Whether the data is in channel last format.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A generator yielding batches of augmented data.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">64</span>,</span><span class=\"param\">\t<span class=\"n\">augmentations</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shuffle</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation.AugmentationDataset", "modulename": "buteo.ai.augmentation", "qualname": "AugmentationDataset", "kind": "class", "doc": "<p>A dataset that applies augmentations to the data.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The data to augment.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>y (np.ndarray): The labels for the data.\n  batch_size (int): The size of the batches to generate.\n  augmentations (list): The augmentations to apply.\n  shuffle (bool): Whether to shuffle the data before generating batches.\n      and whenever the dataset is iterated over.\n  seed (int): The seed to use for shuffling.\n  channel_last (bool): Whether the data is in channel last format.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A dataset yielding batches of augmented data. For Pytorch,\n      convert the batches to tensors before ingestion.</p>\n</blockquote>\n"}, {"fullname": "buteo.ai.augmentation.AugmentationDataset.__init__", "modulename": "buteo.ai.augmentation", "qualname": "AugmentationDataset.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">batch_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">64</span>,</span><span class=\"param\">\t<span class=\"n\">augmentations</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">shuffle</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span>)</span>"}, {"fullname": "buteo.ai.augmentation_batch", "modulename": "buteo.ai.augmentation_batch", "kind": "module", "doc": "<p>This module contains functions for augmenting images that are\nsuited to remote sensing imagery.</p>\n"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_rotation", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_rotation", "kind": "function", "doc": "<p>Randomly rotates images in a batch by 90 degrees intervals. Images\ncan be (batch, channels, height, width) or (batch, height, width, channels).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to rotate.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label of images to rotate. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>y (np.ndarray/none=None): The batch of labels to rotate.\n  chance (float=0.5): The chance of rotating the image.\n  max_images (float=None): The maximum proportion of the images in the batch to possibly rotate.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The rotated images and optionally labels.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_mirror", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_mirror", "kind": "function", "doc": "<p>Randomly mirrors images in a batch. Images can be (batch, channels, height, width) or (batch, height, width, channels).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to mirror.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to mirror. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of mirroring the image.\n  max_images (float=1.0): The maximum proportion  of images in the batch to possibly mirror.\n  k (int=None): If None, randomly mirrors the image along the horizontal or vertical axis.\n      If 1, mirrors the image along the horizontal axis.\n      If 2, mirrors the image along the vertical axis.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The mirrored images and optionally labels.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_noise", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_noise", "kind": "function", "doc": "<p>Adds random noise seperately to each channel of the batch of images. The noise works\nfor both channel first and last images.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to add noise to.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to add noise to. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of adding noise.\n  amount (float=0.01): The amount of noise to add.\n  max_amount (float=0.1): The maximum amount of noise to add, sampled uniformly.\n  max_images (float=1.0): The maximum proportion of images in the batch to add noise to.\n  additive (bool=False): Whether to add or multiply the noise.\n  channel_last (any=None): Whether the image is (channels, height, width) or (height, width, channels).\n      ignored for this function. Kept to keep the same function signature as other augmentations.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The batch of images with noise and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">additive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_channel_scale", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_channel_scale", "kind": "function", "doc": "<p>Scales the channels of the batch of images seperately by a fixed amount.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to scale the channels of.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to scale the channels of. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of scaling the channels.\n  max_amount (float=0.1): The amount to possible scale the channels by. Sampled uniformly.\n  max_images (float=1.0): The maximum number of images to add noise to.\n  additive (bool=False): Whether to add or multiply the scaling.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuble[np.ndarray, Optional[np.ndarray]]: The batch of images with scaled channels and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">additive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_contrast", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_contrast", "kind": "function", "doc": "<p>Changes the contrast of a batch of images by a random amount, seperately for each channel.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to change the contrast of.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to change the contrast of. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of changing the contrast.\n  max_amount (float=0.01): The amount to change the contrast by.\n  max_images (float=1.0): The maximum proportion of images in the batch to change the contrast of.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuble[np.ndarray, Optional[np.ndarray]]: The batch of images with changed contrast and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_drop_pixel", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_drop_pixel", "kind": "function", "doc": "<p>Drops a random pixels from a batch of images.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to drop a pixel from.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to drop pixels from. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of dropping a pixel.\n  drop_probability (float=0.05): The probability of dropping a pixel.\n  drop_value (float=0.0): The value to drop the pixel to.\n  max_images (float=1.0): The maximum proportion of images in the batch to drop a pixel from.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The batch of images with the dropped pixels and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">drop_probability</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">drop_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_drop_channel", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_drop_channel", "kind": "function", "doc": "<p>Drops a random channel from a batch of images.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).\nA maximum of one channel will be dropped.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to drop a channel from.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to drop channels from. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of dropping a channel.\n  max_images (float=1.0): The maximum proportion of images in the batch to drop a channel from.\n  drop_probability (float=0.1): The probability of dropping a channel.\n  drop_value (float=0.0): The value to drop the channel to.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">drop_probability</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">drop_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_blur", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_blur", "kind": "function", "doc": "<p>Blurs a batch of images at random.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to potentially blur.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to potentially blur. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of blurring a pixel.\n  max_images (float=1.0): The maximum proportion of images in the batch to blur.\n  intensity (float=1.0): The intensity of the blur. from 0.0 to 1.0.\n  apply_to_y (bool=False): Whether to blur the label as well.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">intensity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">apply_to_y</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_sharpen", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_sharpen", "kind": "function", "doc": "<p>Sharpens a batch of images at random.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to potentially sharpen.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to potentially sharpen. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of sharpening a pixel.\n  max_images (float=1.0): The maximum proportion of images in the batch to sharpen.\n  intensity (float=1.0): The intensity of the sharpening. from 0.0 to 1.0.\n  apply_to_y (bool=False): Whether to sharpen the label as well.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">intensity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">apply_to_y</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_misalign", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_misalign", "kind": "function", "doc": "<p>Misaligns the channels of a batch of images at random.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to potentially misalign the channels of.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to potentially misalign the channels of. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of misaligning the channels of a pixel.\n  max_offset (float=0.5): The maximum offset to misalign the channels by.\n  max_images (float=0.2): The maximum number of images to misalign the channels of.\n  max_channels (int=1): The maximum number of channels to misalign.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_offset</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_cutmix", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_cutmix", "kind": "function", "doc": "<p>Cutmixes a batch of images at random.\ninput should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to potentially cutmix.</li>\n<li><strong>y (np.ndarray/None):</strong>  The labels of images to potentially cutmix. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of cutmixing a pixel.\n  min_size (float=0.333): The minimum size of the patch to cutmix. In percentage of the image width.\n  max_size (float=0.666): The maximum size of the patch to cutmix. In percentage of the image width.\n  max_images (float=0.2): The maximum percentage of images in a batch to mixup.\n  label_mix (int=0): if\n      0 - The labels will be mixed by the weights.</p>\n\n<pre><code>1 - The target label will be used.\n\n2 - The source label will be used.\n\n3 - The max of the labels will be used.\n\n4 - The min of the labels will be used.\n\n5 - The max of the image with the highest weight will be used.\n\n6 - The min of the image with the highest weight will be used.\n</code></pre>\n  \n  <p>feather (bool=True): Whether to feather the edges of the cutmix.\n  feather_dist (int=3): The distance to feather the edges of the cutmix in pixels\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">min_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.333</span>,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.666</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">label_mix</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">feather</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">feather_dist</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_batch.augmentation_batch_mixup", "modulename": "buteo.ai.augmentation_batch", "qualname": "augmentation_batch_mixup", "kind": "function", "doc": "<p>Mixups a batch of images at random. This works by doing a linear intepolation between\ntwo images in the batch and then adding a random weight to each image.</p>\n\n<p>Mixup involves taking two images and blending them together by randomly interpolating\ntheir pixel values. More specifically, suppose we have two images x and x' with their\ncorresponding labels y and y'. To generate a new training example, mixup takes a\nweighted sum of x and x', such that the resulting image x^* = \u03bbx + (1-\u03bb)x',\nwhere \u03bb is a randomly chosen interpolation coefficient. The label for the new image\nis also a weighted sum of y and y' based on the same interpolation coefficient.</p>\n\n<p>input should be (batch, height, width, channels) or (batch, channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The batch of images to potentially mixup.</li>\n<li><strong>y (np.ndarray/None):</strong>  The batch of labels to potentially mixup.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of mixuping a pixel.\n  max_images (float=0.2): The maximum percentage of images in a batch to mixup.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">min_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.333</span>,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.666</span>,</span><span class=\"param\">\t<span class=\"n\">label_mix</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">max_images</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs", "modulename": "buteo.ai.augmentation_funcs", "kind": "module", "doc": "<p>This module contains functions for augmenting images that are\nsuited to remote sensing imagery.</p>\n"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_rotation", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_rotation", "kind": "function", "doc": "<p>Randomly rotate the image by 90 degrees intervals. Images\ncan be (channels, height, width) or (height, width, channels).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to rotate.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to rotate.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of rotating the image.\n  k (int=None): The number of 90 degree intervals to rotate by.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The rotated image and optionally the label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_mirror", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_mirror", "kind": "function", "doc": "<p>Randomly mirrors the image. Images can be (channels, height, width) or (height, width, channels).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to mirror.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to mirror.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of mirroring the image.\n  k (int=None): If None, randomly mirrors the image along the horizontal or vertical axis.\n      If 1, mirrors the image along the horizontal axis.\n      If 2, mirrors the image along the vertical axis.\n      If 3, mirrors the image along both the horizontal and vertical axis.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The mirrored image and optionally the label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_noise", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_noise", "kind": "function", "doc": "<p>Adds random noise seperately to each pixel of the image. The noise works\nfor both channel first and last images.\ninput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to add noise to.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to add noise to. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of adding noise.\n  max_amount (float=0.1): The maximum amount of noise to add, sampled uniformly.\n  additive (bool=False): Whether to add or multiply the noise.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).\n      ignored for this function. Kept to keep the same function signature as other augmentations.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The image with noise and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">additive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"n\">Any</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_channel_scale", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_channel_scale", "kind": "function", "doc": "<p>Scales the channels of the image seperately by a fixed amount.\ninput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to scale the channels of.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to scale the channels of. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of scaling the channels.\n  max_amount (float=0.1): The amount to possible scale the channels by. Sampled uniformly.\n  additive (bool=False): Whether to add or multiply the scaling.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The image with scaled channels and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">additive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_contrast", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_contrast", "kind": "function", "doc": "<p>Changes the contrast of an image by a random amount, seperately for each channel.\ninput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to change the contrast of.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to change the contrast of. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of changing the contrast.\n  max_amount (float=0.1): The max amount to change the contrast by.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The image with changed contrast and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_amount</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_drop_pixel", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_drop_pixel", "kind": "function", "doc": "<p>Drops a random pixels from an image.\ninput should be (height, width, channels) or (channels, height, width).\nOnly drops pixels from features, not labels.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to drop a pixel from.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to drop a pixel from. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of dropping a pixel.\n  drop_probability (float=0.05): The probability of dropping a pixel.\n  drop_value (float=0.0): The value to drop the pixel to.\n  apply_to_y (bool=False): Whether to apply the drop to the label.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, Optional[np.ndarray]]: The image with the dropped pixels and optionally the unmodified label.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">drop_probability</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>,</span><span class=\"param\">\t<span class=\"n\">drop_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_drop_channel", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_drop_channel", "kind": "function", "doc": "<p>Drops a random channel from an image.\ninput should be (height, width, channels) or (channels, height, width).\nA maximum of one channel will be dropped.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to drop a channel from.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to drop a channel from. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of dropping a channel.\n  drop_probability (float=0.1): The probability of dropping a channel.\n  drop_value (float=0.0): The value to drop the channel to.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">drop_probability</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">drop_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_blur", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_blur", "kind": "function", "doc": "<p>Blurs an image at random.\ninput should be (height, width, channels) or (channels, height, width).\nSame goes for the label if apply_to_y is True.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to potentially blur.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to potentially blur. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of blurring a pixel.\n  intensity (float=1.0): The intensity of the blur. from 0.0 to 1.0.\n  apply_to_y (bool=False): Whether to blur the label as well.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">intensity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">apply_to_y</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_sharpen", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_sharpen", "kind": "function", "doc": "<p>Sharpens an image at random.\ninput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to potentially sharpen.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to potentially sharpen. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of sharpening a pixel.\n  intensity (float=1.0): The intensity of the sharpening. from 0.0 to 1.0.\n  apply_to_y (bool=False): Whether to sharpen the label as well.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">intensity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">apply_to_y</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_misalign_pixels", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_misalign_pixels", "kind": "function", "doc": "<p>Misaligns one channel in the image at random.\ninput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The image to potentially misalign the channels of.</li>\n<li><strong>y (np.ndarray/None):</strong>  The label to potentially misalign the channels of. If None, no label is returned.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of misaligning the channels of a pixel.\n  max_offset (float=0.5): The maximum offset to misalign the channels by.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">max_offset</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_cutmix", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_cutmix", "kind": "function", "doc": "<p>Cutmixes two images.\ninput should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X_target (np.ndarray):</strong>  The image to transfer the cutmix to.</li>\n<li><strong>y_target (np.ndarray):</strong>  The label to transfer the cutmix to.</li>\n<li><strong>X_source (np.ndarray):</strong>  The image to cutmix from.</li>\n<li><strong>y_source (np.ndarray):</strong>  The label to cutmix from.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>chance (float=0.5): The chance of cutmixing a pixel.\n  min_size (float=0.333): The minimum size of the patch to cutmix. In percentage of the image width.\n  max_size (float=0.666): The maximum size of the patch to cutmix. In percentage of the image width.\n  label_mix (int=0): if\n      0 - The labels will be mixed by the weights.</p>\n\n<pre><code>1 - The target label will be used.\n\n2 - The source label will be used.\n\n3 - The max of the labels will be used.\n\n4 - The min of the labels will be used.\n\n5 - The max of the image with the highest weight will be used.\n\n6 - The min of the image with the highest weight will be used.\n</code></pre>\n  \n  <p>feather (bool=True): Whether to feather the edges of the cutmix.\n  feather_dist (int=3): The distance to feather the edges of the cutmix in pixels\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">X_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">min_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.333</span>,</span><span class=\"param\">\t<span class=\"n\">max_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.666</span>,</span><span class=\"param\">\t<span class=\"n\">label_mix</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">feather</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">feather_dist</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_funcs.augmentation_mixup", "modulename": "buteo.ai.augmentation_funcs", "qualname": "augmentation_mixup", "kind": "function", "doc": "<p>Mixups two images at random. This works by doing a linear intepolation between\ntwo images and then adding a random weight to each image.</p>\n\n<p>Mixup involves taking two images and blending them together by randomly interpolating\ntheir pixel values. More specifically, suppose we have two images x and x' with their\ncorresponding labels y and y'. To generate a new training example, mixup takes a\nweighted sum of x and x', such that the resulting image x^* = \u03bbx + (1-\u03bb)x',\nwhere \u03bb is a randomly chosen interpolation coefficient. The label for the new image\nis also a weighted sum of y and y' based on the same interpolation coefficient.</p>\n\n<p>input should be (height, width, channels) or (channels, height, width).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X_target (np.ndarray):</strong>  The image to transfer to.</li>\n<li><strong>y_target (np.ndarray):</strong>  The label to transfer to.</li>\n<li><strong>X_source (np.ndarray):</strong>  The image to transfer from.</li>\n<li><strong>y_source (np.ndarray):</strong>  The label to transfer from.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>min_mix (float=0.333): The minimum mixup coefficient.\n  max_mix (float=0.666): The maximum mixup coefficient.\n  label_mix (int=0): if\n      0 - The labels will be mixed by the weights.</p>\n\n<pre><code>1 - The target label will be used.\n\n2 - The source label will be used.\n\n3 - The max of the labels will be used.\n\n4 - The min of the labels will be used.\n\n5 - The max of the image with the highest weight will be used.\n\n6 - The min of the image with the highest weight will be used.\n</code></pre>\n  \n  <p>chance (float=0.5): The chance of mixuping a pixel.\n  channel_last (bool=True): Whether the image is (channels, height, width) or (height, width, channels).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_target</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">X_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y_source</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">min_mix</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.333</span>,</span><span class=\"param\">\t<span class=\"n\">max_mix</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.666</span>,</span><span class=\"param\">\t<span class=\"n\">label_mix</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">chance</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>,</span><span class=\"param\">\t<span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils", "modulename": "buteo.ai.augmentation_utils", "kind": "module", "doc": "<p>This module contains utility functions for augmenting images that are\nsuited to remote sensing imagery.</p>\n"}, {"fullname": "buteo.ai.augmentation_utils.is_integer_dtype", "modulename": "buteo.ai.augmentation_utils", "qualname": "is_integer_dtype", "kind": "function", "doc": "<p>Check if a dtype is an integer type </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dtype (np.dtype):</strong>  The dtype to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the dtype is an integer type.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.fit_data_to_dtype", "modulename": "buteo.ai.augmentation_utils", "qualname": "fit_data_to_dtype", "kind": "function", "doc": "<p>Fit data to a dtype. If the dtype is an integer type, the data will be\n    rounded to the nearest integer. If the dtype is a float type, the data\n    will be clipped to the min and max values of the dtype.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>data (np.ndarray):</strong>  The data to fit to the dtype.</li>\n<li><strong>dtype (np.dtype):</strong>  The dtype to fit the data to.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The data fitted to the dtype.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.feather_box_2d", "modulename": "buteo.ai.augmentation_utils", "qualname": "feather_box_2d", "kind": "function", "doc": "<p>Feather a box into an array (2D). Box should be the original box\n    buffered by feather_dist.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>array_whole (np.ndarray):</strong>  The array containing the box.</li>\n<li><strong>bbox (Union[List[int], Tuple[int]]):</strong>  The box.\nthe bbox should be in the form [x_min, x_max, y_min, y_max].</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>feather_dist (int=3): The distance to feather the box.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, np.ndarray]: The featherweights for the array and the bbox.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">bbox</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">feather_dist</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.simple_blur_kernel_2d_3x3", "modulename": "buteo.ai.augmentation_utils", "qualname": "simple_blur_kernel_2d_3x3", "kind": "function", "doc": "<p>Create a 2D blur kernel.</p>\n\n<p>[1, 2, 1],\n[2, 4, 2],\n[1, 2, 1],</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, np.ndarray]: The offsets and weights.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.simple_unsharp_kernel_2d_3x3", "modulename": "buteo.ai.augmentation_utils", "qualname": "simple_unsharp_kernel_2d_3x3", "kind": "function", "doc": "<p>Create a 2D unsharp kernel.</p>\n\n<p>baseweights:\n    0.09911165, 0.15088834, 0.09911165,\n    0.15088834, 0.        , 0.15088834,\n    0.09911165, 0.15088834, 0.09911165,</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, np.ndarray]: The offsets and weights.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">strength</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.simple_shift_kernel_2d", "modulename": "buteo.ai.augmentation_utils", "qualname": "simple_shift_kernel_2d", "kind": "function", "doc": "<p>Create a 2D shift kernel. Useful for either aligning rasters at the sub-pixel\nlevel or for shifting a raster by a whole pixel while keeping the bbox.\nCan be used to for an augmentation, where channel misalignment is simulated.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>x_offset (float):</strong>  The x offset.</li>\n<li><strong>y_offset (float):</strong>  The y offset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[np.ndarray, np.ndarray]: The offsets and weights.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x_offset</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">y_offset</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.convolution_simple", "modulename": "buteo.ai.augmentation_utils", "qualname": "convolution_simple", "kind": "function", "doc": "<p>Convolve a kernel with an array using a simple method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>array (np.ndarray):</strong>  The array to convolve.</li>\n<li><strong>offsets (np.ndarray):</strong>  The offsets of the kernel.</li>\n<li><strong>weights (np.ndarray):</strong>  The weights of the kernel.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>intensity (float=1.0): The intensity of the convolution. If\n      1.0, the convolution is applied as is. If 0.5, the\n      convolution is applied at half intensity.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The convolved array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">intensity</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.rotate_90", "modulename": "buteo.ai.augmentation_utils", "qualname": "rotate_90", "kind": "function", "doc": "<p>Rotate a 3D array 90 degrees clockwise.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to rotate.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The rotated array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.rotate_180", "modulename": "buteo.ai.augmentation_utils", "qualname": "rotate_180", "kind": "function", "doc": "<p>Rotate a 3D array 180 degrees clockwise.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to rotate.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The rotated array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.rotate_270", "modulename": "buteo.ai.augmentation_utils", "qualname": "rotate_270", "kind": "function", "doc": "<p>Rotate a 3D image array 270 degrees clockwise.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to rotate.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The rotated array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.rotate_arr", "modulename": "buteo.ai.augmentation_utils", "qualname": "rotate_arr", "kind": "function", "doc": "<p>Rotate an array by 90 degrees intervals clockwise.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to rotate.</li>\n<li><strong>k (int):</strong>  The number of 90 degree intervals to rotate by.\n1 for 90 degrees, 2 for 180 degrees, 3 for 270 degrees. 0 for no rotation.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The rotated array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.mirror_horizontal", "modulename": "buteo.ai.augmentation_utils", "qualname": "mirror_horizontal", "kind": "function", "doc": "<p>Mirror a 3D array horizontally.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to mirror.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The mirrored array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.mirror_vertical", "modulename": "buteo.ai.augmentation_utils", "qualname": "mirror_vertical", "kind": "function", "doc": "<p>Mirror a 3D array vertically.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to mirror.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The mirrored array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.mirror_horisontal_vertical", "modulename": "buteo.ai.augmentation_utils", "qualname": "mirror_horisontal_vertical", "kind": "function", "doc": "<p>Mirror a 3D array horizontally and vertically.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to mirror.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The mirrored array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.augmentation_utils.mirror_arr", "modulename": "buteo.ai.augmentation_utils", "qualname": "mirror_arr", "kind": "function", "doc": "<p>Mirror an array horizontally and/or vertically.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to mirror.</li>\n<li><strong>k (int):</strong>  1 for horizontal, 2 for vertical, 3 for both, 0 for no mirroring.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>channel_last (bool=True): Whether the last axis is the channel axis.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">k</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">channel_last</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers", "modulename": "buteo.ai.scalers", "kind": "module", "doc": "<p>This module provides a set of functions to normalise data for machine learning.</p>\n"}, {"fullname": "buteo.ai.scalers.scaler_minmax", "modulename": "buteo.ai.scalers", "qualname": "scaler_minmax", "kind": "function", "doc": "<p>Normalise an array using the min-max method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.array):</strong>  The array to normalise.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.array: The normalised array. (dtype: float32)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_standardise", "modulename": "buteo.ai.scalers", "qualname": "scaler_standardise", "kind": "function", "doc": "<p>Normalise an array using the mean and standard deviation method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.array):</strong>  The array to normalise.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.array: The normalised array. (dtype: float32)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_standardise_mad", "modulename": "buteo.ai.scalers", "qualname": "scaler_standardise_mad", "kind": "function", "doc": "<p>Normalise an array using the median absolute deviation (MAD) method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.array):</strong>  The array to normalise.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.array: The normalised array. (dtype: float32)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_iqr", "modulename": "buteo.ai.scalers", "qualname": "scaler_iqr", "kind": "function", "doc": "<p>Normalise an array using the interquartile range (IQR) method.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.array):</strong>  The array to normalise.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>q1 (float=0.25): The lower quartile.\n  q3 (float=0.75): The upper quartile.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.array: The normalised array. (dtype: float32)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">q1</span><span class=\"o\">=</span><span class=\"mf\">0.25</span>,</span><span class=\"param\">\t<span class=\"n\">q3</span><span class=\"o\">=</span><span class=\"mf\">0.75</span></span><span class=\"return-annotation\">) -> <span class=\"o\">&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">function</span> <span class=\"n\">array</span><span class=\"o\">&gt;</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_to_range", "modulename": "buteo.ai.scalers", "qualname": "scaler_to_range", "kind": "function", "doc": "<p>Normalise an array to a given range.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.array):</strong>  The array to normalise.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>min_val (float=0.0): The minimum value.\n  max_val (float=1.0): The maximum value.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.array: The normalised array. (dtype: float32)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">min_val</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">max_val</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.scalers.scaler_truncate", "modulename": "buteo.ai.scalers", "qualname": "scaler_truncate", "kind": "function", "doc": "<p>Truncate an array and then normalise it to a given range.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.array):</strong>  The array to normalise</li>\n<li><strong>trunc_min (float/int):</strong>  The minimum value to truncate to.</li>\n<li><strong>trunc_max (float/int):</strong>  The maximum value to truncate to.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>target_min (float=0.0): The minimum value to normalise to.\n  target_max (float=1.0): The maximum value to normalise to.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.array: The normalised array. (dtype: float32)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">trunc_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">trunc_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">target_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">target_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.selection", "modulename": "buteo.ai.selection", "kind": "module", "doc": "<p>This module contains function to select features from a dataset for machine learning.</p>\n"}, {"fullname": "buteo.ai.selection.train_val_split", "modulename": "buteo.ai.selection", "qualname": "train_val_split", "kind": "function", "doc": "<p>Split a dataset into training and validation sets. Always shuffles.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The input data.</li>\n<li><strong>y (np.ndarray):</strong>  The target data.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>val_size (float=0.25): The size of the validation set as a fraction of the total dataset.\n  random_state (float=None): The random seed to use for the split.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>x_train, x_val, y_train, y_val (np.ndarray): The training and validation sets in a tuple.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">val_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.selection.train_val_test_split", "modulename": "buteo.ai.selection", "qualname": "train_val_test_split", "kind": "function", "doc": "<p>Split a dataset into training, validation, and test sets. Always shuffles.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The input data.</li>\n<li><strong>y (np.ndarray):</strong>  The target data.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>val_size (float=0.1): The size of the validation set as a fraction of the total dataset.\n  test_size (float=0.2): The size of the test set as a fraction of the total dataset.\n  random_state (float=None): The random seed to use for the split.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>x_train, x_val, x_test, y_train, y_val, y_test (np.ndarray): The training, validation, and test sets in a tuple.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">val_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.1</span>,</span><span class=\"param\">\t<span class=\"n\">test_size</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">random_state</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.ai.selection.stratified_sampling", "modulename": "buteo.ai.selection", "qualname": "stratified_sampling", "kind": "function", "doc": "<p>Stratified sampling of a dataset. Can be used for regression or classification.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>X (np.ndarray):</strong>  The input data.</li>\n<li><strong>y (np.ndarray):</strong>  The target data.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>regression (bool=False): Whether the dataset is for regression or classification.\n  samples_per_class (int=None): The number of samples to take per class. If None,\n      takes the same number of samples per class as the smallest class.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>X, y (np.ndarray): The stratified dataset.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">X</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">y</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">regression</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">samples_per_class</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo", "modulename": "buteo.eo", "kind": "module", "doc": "<p>Tools for working with sentinel data</p>\n"}, {"fullname": "buteo.eo.s1_preprocess", "modulename": "buteo.eo.s1_preprocess", "kind": "module", "doc": "<p>This module preprocesses Sentinel-1 data. Using SNAP GPT.</p>\n\n<h6 id=\"todo\">TODO:</h6>\n\n<blockquote>\n  <ul>\n  <li>Enable support for processing only VV or VH.</li>\n  <li>Improve documentation</li>\n  </ul>\n</blockquote>\n"}, {"fullname": "buteo.eo.s1_preprocess.find_gpt", "modulename": "buteo.eo.s1_preprocess", "qualname": "find_gpt", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">test_gpt_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_preprocess.backscatter_step1", "modulename": "buteo.eo.s1_preprocess", "qualname": "backscatter_step1", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">zip_file</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span>,</span><span class=\"param\">\t<span class=\"n\">gpt_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;~/snap/bin/gpt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">tmp_folder</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_preprocess.backscatter_step2", "modulename": "buteo.eo.s1_preprocess", "qualname": "backscatter_step2", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim_file</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span>,</span><span class=\"param\">\t<span class=\"n\">speckle_filter</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">epsg</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">gpt_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;~/snap/bin/gpt&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">tmp_folder</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_preprocess.convert_to_tiff", "modulename": "buteo.eo.s1_preprocess", "qualname": "convert_to_tiff", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dim_file</span>,</span><span class=\"param\">\t<span class=\"n\">out_folder</span>,</span><span class=\"param\">\t<span class=\"n\">decibel</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">use_nodata</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_preprocess.clear_tmp_folder", "modulename": "buteo.eo.s1_preprocess", "qualname": "clear_tmp_folder", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tmp_folder</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_preprocess.backscatter", "modulename": "buteo.eo.s1_preprocess", "qualname": "backscatter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">zip_file</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span>,</span><span class=\"param\">\t<span class=\"n\">tmp_folder</span>,</span><span class=\"param\">\t<span class=\"n\">extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">epsg</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">use_nodata</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">speckle_filter</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">decibel</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">clean_tmp</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">gpt_path</span><span class=\"o\">=</span><span class=\"s1\">&#39;~/snap/bin/gpt&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_utils", "modulename": "buteo.eo.s1_utils", "kind": "module", "doc": "<p>This module provides functions to ease the preprocessing of Sentinel 1 data\nand finding the GPT tools.</p>\n\n<h6 id=\"todo\">TODO:</h6>\n\n<blockquote>\n  <ul>\n  <li>Improve documentation</li>\n  </ul>\n</blockquote>\n"}, {"fullname": "buteo.eo.s1_utils.s1_kml_to_bbox", "modulename": "buteo.eo.s1_utils", "qualname": "s1_kml_to_bbox", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_to_kml</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s1_utils.get_metadata", "modulename": "buteo.eo.s1_utils", "qualname": "get_metadata", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">image_paths</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices", "modulename": "buteo.eo.s2_indices", "kind": "module", "doc": "<p>This module provides varoius indices for Sentinel 2 imagery.</p>\n\n<h6 id=\"todo\">TODO:</h6>\n\n<blockquote>\n  <p>Convert to numpy functions.\n  Handle resampling</p>\n</blockquote>\n"}, {"fullname": "buteo.eo.s2_indices.s2_index_chlre", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_chlre", "kind": "function", "doc": "<p>Red Edge Chlorophyll Index\nCalc: B05 / B08</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_rendvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_rendvi", "kind": "function", "doc": "<p>Red Edge NDVI\nCalc: (B08 - B06) / (B08 + B06)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_06</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_s2_rep", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_s2_rep", "kind": "function", "doc": "<p>Sentinel 2 Red Edge Position\nCalc: 705 + 35 * ((((B07 + B04) / 2) - B05) / (B06 - B05))</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_07</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_06</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ireci", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ireci", "kind": "function", "doc": "<p>Red Edge Chlorophyll Index\nCalc: (B07 - B04) * B06 / B05</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_07</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_06</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_mcari", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_mcari", "kind": "function", "doc": "<p>Modified Chlorophyll Absorption in Reflectance Index\nCalc: (B05 - B04) - 0.2 * (B05 - B03) * (B05 / B04)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_05</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_arvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_arvi", "kind": "function", "doc": "<p>Atmospherically Resistant Vegetation Index\nCalc: (B08 - b) / (B08 + b), b = 2 * B04 - B02</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_02</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_savi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_savi", "kind": "function", "doc": "<p>Soil Adjusted Vegetation Index\nCalc: ((B08 - B04) / ((B08 + B04) + 0.428)) * 1.856</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_msavi2", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_msavi2", "kind": "function", "doc": "<p>Modified Soil Adjusted Vegetation Index v2\nCalc: (2 * B08 + 1 - sqrt((2 * B08 + 1) ** 2) - 8 * (B08 - B04)) / 2</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_gndvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_gndvi", "kind": "function", "doc": "<p>Green Normalized Difference Vegetation Index\nCalc: (B08 - B03) / (B08 + B03)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndvi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndvi", "kind": "function", "doc": "<p>Normalized Difference Vegetation Index\nCalc: (B08 - B04) / (B08 + B04)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_moist", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_moist", "kind": "function", "doc": "<p>Soil Moisture Index\nCalc: (B8A - B11) / (B8A + B11)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_8A</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndwi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndwi", "kind": "function", "doc": "<p>Normalized Difference Water Index\nCalc: (B08 - B11) / (B08 + B11)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndwi_v2", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndwi_v2", "kind": "function", "doc": "<p>Normalized Difference Water Index v2\nCalc: (B03 - B08) / (B03 + B08)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_nbr", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_nbr", "kind": "function", "doc": "<p>Normalized Burn Ratio\nCalc: (B08 - B12) / (B08 + B12)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_12</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_nvei", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_nvei", "kind": "function", "doc": "<p>Non-elimination vegetation index\nCalc: (B02 - B04) / (B08 + B04)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_02</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_nbai", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_nbai", "kind": "function", "doc": "<p>Built-up area index\nCalc: (B12 - d) / (B12 + d), d = B08 / B02</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_02</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_12</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_brba", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_brba", "kind": "function", "doc": "<p>Band ratio for built-up areas\nCalc: (B03 / B08)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ndbi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ndbi", "kind": "function", "doc": "<p>Normalised difference built-up index\nCalc: (B11 - B08) / (B11 + B08)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_blfei", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_blfei", "kind": "function", "doc": "<p>Built-up features extraction\nCalc: (bix - B11) / (bix + B11), bix = (B03 + B04 + B12) / 3</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_12</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_indices.s2_index_ibi", "modulename": "buteo.eo.s2_indices", "qualname": "s2_index_ibi", "kind": "function", "doc": "<p>Built-up features extraction\nCalc: (ndbi - ((savi + ndwi2) / 2)) / (ndbi + ((savi + ndwi2) / 2))\n    savi = ((B08 - B04) / ((B08 + B04) + 0.428)) * 1.856\n    ndwi2 = (B03 - B08) / (B03 + B08)\n    ndbi = (B11 - B08) / (B11 + B08</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">b_03</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_04</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_08</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">b_11</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_utils", "modulename": "buteo.eo.s2_utils", "kind": "module", "doc": "<p>This module contains utility functions to work with sentinel 2 data.</p>\n"}, {"fullname": "buteo.eo.s2_utils.s2_l2a_get_bands", "modulename": "buteo.eo.s2_utils", "qualname": "s2_l2a_get_bands", "kind": "function", "doc": "<p>Get the bands from a sentinel 2 L2A product.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>zip_or_safe_folder (str):</strong>  Path to the zip file or SAFE folder.</li>\n</ul>\n\n<h6 id=\"key-args\">Key Args:</h6>\n\n<blockquote>\n  <p>zipfile (bool=True): If True, the zip file is used. If False, the SAFE folder is used.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary with the bands.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zip_or_safe_folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">zipfile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.eo.s2_utils.s2_l2a_get_metadata", "modulename": "buteo.eo.s2_utils", "qualname": "s2_l2a_get_metadata", "kind": "function", "doc": "<p>Get metadata from the SAFE folder or the zip file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>zip_or_safe_folder (str):</strong>  Path to the zip file or the SAFE folder.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>zipfile (bool): If True, the zip file is used. If False, the SAFE folder is used.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict: Dictionary with the metadata.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zip_or_safe_folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">zipfile</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">dict</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster", "modulename": "buteo.raster", "kind": "module", "doc": "<p>Make simple work of raster analysis!</p>\n"}, {"fullname": "buteo.raster.align", "modulename": "buteo.raster.align", "kind": "module", "doc": "<h3 id=\"align-rasters\">Align rasters</h3>\n\n<p>Functions to align a series of rasters to a master or a reference.</p>\n"}, {"fullname": "buteo.raster.align.align_rasters_to_reference", "modulename": "buteo.raster.align", "qualname": "align_rasters_to_reference", "kind": "function", "doc": "<p>Aligns a series of rasters to a reference.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  A list of rasters to align.</li>\n<li><strong>reference (str/gdal.Dataset):</strong>  Path to the reference raster\nor vector.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str/list, default=None): Paths to the output. If not provided,\n      the output will be in-memory rasters.\n  resample_alg (str, default=\"nearest\"): Resampling algorithm to use.\n  target_nodata (int/float, default=None): Nodata value to use for the\n      output rasters.\n  overwrite (bool, default=True): Overwrite existing files.\n  creation_options (list, default=None): List of creation options.\n  prefix (str, default=\"\"): Prefix to add to the output file name.\n  suffix (str, default=\"\"): Suffix to add to the output file name.\n  ram (int/str, default=\"auto\"): Amount of RAM to use in MB. If \"auto\",\n      the amount of RAM will be determined automatically.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">target_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">ram</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.align.find_best_reference", "modulename": "buteo.raster.align", "qualname": "find_best_reference", "kind": "function", "doc": "<p>Find the best reference raster for aligning a list of rasters.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (str/list):</strong>  List of rasters to align.</li>\n<li><strong>method (str):</strong>  Bounding box method to use for finding the best reference.\nOptions include: \"reference\", \"intersection\", and \"union\".</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: Path to the best reference raster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.align.align_rasters", "modulename": "buteo.raster.align", "qualname": "align_rasters", "kind": "function", "doc": "<p>Aligns rasters either to a reference raster or to each other using the\none of three methods: reference, intersection, or union.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (Union[str, gdal.Dataset, List[Union[str, gdal.Dataset]]]):</strong>  The rasters to align.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (Optional[Union[str, List[str]]], optional): The output path(s). Defaults to None.\n  reference (Optional[Union[str, gdal.Dataset]], optional): The reference raster to align to. Defaults to None.\n  method (str, optional): The method to use. Defaults to \"reference\" [reference, intersection, union].\n  resample_alg (str, optional): The resampling algorithm to use. Defaults to \"nearest\".\n  overwrite (bool, optional): Whether to overwrite existing files. Defaults to True.\n  creation_options (Optional[List[str]], optional): The creation options to use. Defaults to None.\n  prefix (str, optional): The prefix to add to the output file name. Defaults to \"\".\n  suffix (str, optional): The suffix to add to the output file name. Defaults to \"\".\n  ram (int/str, default=\"auto\"): Amount of RAM to use in MB. If \"auto\",\n      the amount of RAM will be determined automatically.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[str]: The aligned rasters.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;reference&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">target_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">ram</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.borders", "modulename": "buteo.raster.borders", "kind": "module", "doc": "<h3 id=\"handle-and-create-borders-on-rasters\">Handle and create borders on rasters.</h3>\n\n<p>Functions to add or remove borders from rasters.\nUseful for warped satellite images and for proximity searching.</p>\n"}, {"fullname": "buteo.raster.borders.add_border_to_raster", "modulename": "buteo.raster.borders", "qualname": "add_border_to_raster", "kind": "function", "doc": "<p>Add a border to a raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>input_raster (str/gdal.DataSet):</strong>  The input raster.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str/None, default=None): The output path. If None, the output\n      will be a memory raster.\n  border_size (int, default=100): The size of the border.\n  border_size_unit (str, default='px'): The unit of the border size.\n  border_value (int, default=0): The value of the border.\n  overwrite (bool, default=True): If True, the output raster will be\n      overwritten.\n  allow_lists (bool, default=True): If True, lists of rasters will be\n      allowed.\n  creation_options (list/None, default=None): Creation options for the\n      output raster.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str/gdal.DataSet: The output raster with added borders.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">border_size</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">border_size_unit</span><span class=\"o\">=</span><span class=\"s1\">&#39;px&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">border_value</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.clip", "modulename": "buteo.raster.clip", "kind": "module", "doc": "<h3 id=\"clip-rasters\">Clip rasters</h3>\n\n<p>Clips a raster using a vector geometry or the extents of a raster.</p>\n"}, {"fullname": "buteo.raster.clip.clip_raster", "modulename": "buteo.raster.clip", "qualname": "clip_raster", "kind": "function", "doc": "<p>Clips a raster(s) using a vector geometry or the extents of a raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (list/str/gdal.Dataset):</strong>  The raster(s) to clip.</li>\n<li><strong>clip_geom (str/ogr.DataSource/gdal.Dataset):</strong>  The geometry to use to\nclip the raster.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str/list/None, default=None): The path(s) to save the\n      clipped raster to. If None, a memory raster is created.\n  resample_alg (str, default=\"nearest\"): The resampling algorithm to use.\n      Options include: nearest, bilinear, cubic, cubicspline, lanczos, average,\n          mode, max, min, median, q1, q3, sum, rms.\n  crop_to_geom (bool, default=True): If True, the output raster will be\n      cropped to the extent of the clip geometry.\n  adjust_bbox (bool, default=False): If True, the output raster will have its\n      bbox adjusted to match the clip geometry.\n  all_touch (bool, default=False): If true, all pixels touching the\n      clipping geometry will be included.\n  to_extent (bool, default=False): If True, the output raster will be\n      cropped to the extent of the clip geometry.\n  prefix (str, default=\"\"): The prefix to use for the output raster.\n  suffix (str, default=\"\"): The suffix to use for the output raster.\n  overwrite (bool, default=True): If True, the output raster will be\n      overwritten if it already exists.\n  creation_options (list/None, default=None): A list of creation options\n      to pass to gdal.\n  dst_nodata (int/float/None, default=\"infer\"): The nodata value to use for\n      the output raster.\n  src_nodata (int/float/None, default=\"infer\"): The nodata value to use for\n      the input raster.\n  layer_to_clip (int/str, default=0): The layer ID or name in the\n      vector to use for clipping.\n  verbose (int, default=0): The verbosity level.\n  add_uuid (bool, default=False): If True, a UUID will be added to the\n      output raster.\n  ram (str, default=\"auto\"): The amount of RAM to use for the operation.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str/list: A string or list of strings representing the path(s) to\n      the clipped raster(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">crop_to_geom</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">adjust_bbox</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">all_touch</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">to_extent</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">src_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">layer_to_clip</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ram</span><span class=\"o\">=</span><span class=\"s1\">&#39;auto&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution", "modulename": "buteo.raster.convolution", "kind": "module", "doc": "<h3 id=\"perform-convolutions-on-arrays\">Perform convolutions on arrays.</h3>\n"}, {"fullname": "buteo.raster.convolution.weight_distance", "modulename": "buteo.raster.convolution", "qualname": "weight_distance", "kind": "function", "doc": "<p>Weights the kernel by distance using various methods.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (numpy.ndarray):</strong>  The input array.</li>\n<li><strong>method (str, default=None):</strong>  The weighting method to use.\n\"none\": No weighting (default).\n\"linear\": Linear decay.\n\"sqrt\": Square root decay.\n\"power\": Power decay.\n\"log\": Logarithmic decay.\n\"gaussian\": Gaussian decay.</li>\n<li><strong>decay (float, default=0.2):</strong>  The decay rate for the <code>linear</code>, <code>sqrt</code>, and <code>power</code> methods.</li>\n<li><strong>sigma (float, default=1.0):</strong>  The standard deviation for the Gaussian method.</li>\n<li><strong>center (float, default=0.0):</strong>  The center of the array.</li>\n<li><strong>spherical (bool, default=False):</strong>  If True, adjust weights based on the radius.</li>\n<li><strong>radius (float, default=3.0):</strong>  The radius for spherical adjustments.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: The computed weight.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">center</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">radius</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">3.0</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution.rotate_kernel", "modulename": "buteo.raster.convolution", "qualname": "rotate_kernel", "kind": "function", "doc": "<p>Creates a whole kernel from a quadrant.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>bottom_right (numpy.ndarray):</strong>  The bottom-right quadrant of the kernel.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: The complete kernel generated from the given quadrant.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bottom_right</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution.get_kernel", "modulename": "buteo.raster.convolution", "qualname": "get_kernel", "kind": "function", "doc": "<p>Generates a square kernel for convolutions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>size (int):</strong>  Size of the kernel (must be odd).</li>\n<li><strong>depth (int, default=1):</strong>  Depth of the kernel.</li>\n<li><strong>hole (bool, default=False):</strong>  Create a hole in the center of the kernel.</li>\n<li><strong>inverted (bool, default=False):</strong>  Invert the kernel values.</li>\n<li><strong>normalise (bool, default=True):</strong>  Normalize the kernel values.</li>\n<li><strong>multi_dimensional (bool, default=False):</strong>  Consider the kernel multi-dimensional.</li>\n<li><strong>multi_dimensional_center (int, default=0):</strong>  Center of the\nmulti-dimensional kernel.</li>\n<li><strong>spherical (bool, default=False):</strong>  Consider the kernel spherical.</li>\n<li><strong>distance_weight (str or None, default=None):</strong>  Distance weighting method.</li>\n<li><strong>distance_decay (float, default=0.2):</strong>  Distance decay factor.</li>\n<li><strong>distance_sigma (float, default=1):</strong>  Distance sigma for Gaussian distance weighting.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing the kernel, weights, and offsets.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">depth</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">hole</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">inverted</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">normalise</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">multi_dimensional</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">multi_dimensional_center</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution.pad_array", "modulename": "buteo.raster.convolution", "qualname": "pad_array", "kind": "function", "doc": "<p>Create a padded view of an array using SAME padding.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (numpy.ndarray):</strong>  The input array to be padded.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>pad_size (int, default=1): The number of padding elements to add\n      to each side of the array. Default is 1.\n  method (str, default=\"same\"): The padding method to use. Default\n      is \"same\". Other options are \"edge\" and \"constant\".\n  constant_value (int, default=None): The constant value to use\n      when padding with \"constant\". Default is 0.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: A padded view of the input array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">pad_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;same&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">constant_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution.hood_to_value", "modulename": "buteo.raster.convolution", "qualname": "hood_to_value", "kind": "function", "doc": "<p>Convert a array of values and weights to a single value using a given method.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">method</span>,</span><span class=\"param\">\t<span class=\"n\">values</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.9</span>,</span><span class=\"param\">\t<span class=\"n\">center_value</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"o\">=</span><span class=\"mf\">0.5</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution.convolve_array", "modulename": "buteo.raster.convolution", "qualname": "convolve_array", "kind": "function", "doc": "<p>Convolve an image with a function.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (numpy.ndarray):</strong>  The input array to convolve.</li>\n<li><strong>offsets (list of tuples):</strong>  The list of offsets for the neighborhood\nused in the convolution.</li>\n<li><strong>weights (list):</strong>  The list of weights used in the convolution.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>method (int=1): The method to use for the convolution.\n      1: hood_sum\n      2: hood_mode\n      3: hood_max\n      4: hood_min\n      5: hood_contrast\n      6: hood_quantile\n      7: hood_standard_deviation\n      8: hood_median_absolute_deviation\n      9: hood_z_score\n      10: hood_z_score_mad\n      11: hood_sigma_lee\n  nodata (bool=False): If True, nodata values are considered\n      in the convolution.\n  nodata_value (float=-9999.9): The value representing nodata.\n  normalise_edges (bool=True): If True, the weights at the edges\n      are normalised to sum to one. Only relavant for border pixels.\n      Use false, if you are interested in the sum, otherwise you likely\n      want to use True.\n  collapse (bool=False): If True, the convolution results in a (height, width, 1)\n      array. Otherwise, the convolution results in a (height, width, depth) applied\n      channelwise.\n  value (Union[int, float, None]=None): If not None, the value to use for the convolution.\n      depending on the method specified.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>numpy.ndarray: The convolved array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mf\">9999.9</span>,</span><span class=\"param\">\t<span class=\"n\">normalise_edges</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">collapse</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs", "modulename": "buteo.raster.convolution_funcs", "kind": "module", "doc": "<h3 id=\"perform-convolutions-on-arrays-funcs\">Perform convolutions on arrays. (Funcs)</h3>\n"}, {"fullname": "buteo.raster.convolution_funcs.hood_max", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_max", "kind": "function", "doc": "<p>Get the weighted maximum.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_min", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_min", "kind": "function", "doc": "<p>Get the weighted minimum.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_sum", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_sum", "kind": "function", "doc": "<p>Get the weighted sum.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_mode", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_mode", "kind": "function", "doc": "<p>Get the weighted sum.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_count_occurances", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_count_occurances", "kind": "function", "doc": "<p>Count how many times a number appears in an array. \nCan be normalised to the size of the array to do feathering.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">normalise</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_contrast", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_contrast", "kind": "function", "doc": "<p>Get the local contrast.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_quantile", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_quantile", "kind": "function", "doc": "<p>Get the weighted median.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">quantile</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_median_absolute_deviation", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_median_absolute_deviation", "kind": "function", "doc": "<p>Get the median absolute deviation</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_z_score", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_z_score", "kind": "function", "doc": "<p>Get the local z score .</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">center_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_z_score_mad", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_z_score_mad", "kind": "function", "doc": "<p>Get the local z score calculated around the MAD.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">center_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_standard_deviation", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_standard_deviation", "kind": "function", "doc": "<p>Get the weighted standard deviation.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.k_to_size", "modulename": "buteo.raster.convolution_funcs", "qualname": "k_to_size", "kind": "function", "doc": "<p>Preprocess Sigma Lee limits.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.convolution_funcs.hood_sigma_lee", "modulename": "buteo.raster.convolution_funcs", "qualname": "hood_sigma_lee", "kind": "function", "doc": "<p>Sigma lee SAR filter.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">weights</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster", "modulename": "buteo.raster.core_raster", "kind": "module", "doc": "<h3 id=\"basic-io-functions-for-working-with-rasters\">Basic IO functions for working with Rasters</h3>\n\n<p>This module does standard raster operations related to read, write, and metadata.</p>\n"}, {"fullname": "buteo.raster.core_raster.open_raster", "modulename": "buteo.raster.core_raster", "qualname": "open_raster", "kind": "function", "doc": "<p>Opens a raster from a path to a raster. Can be in-memory or local. If a\ngdal.Dataset is passed, it is returned. Supports lists. If a list is passed,\na list is returned with the opened raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (gdal.Dataset/str/list):</strong>  A path to a raster or a GDAL dataframe.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>writeable (bool, default=True): If True, the raster is opened in write mode. Default is True.\n  allow_lists (bool, default=True): If True, the input can be a list of rasters. Otherwise,\n      only a single raster is allowed. Default is True.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>gdal.Dataset/list: A gdal.Dataset or a list of gdal.Datasets.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">writeable</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.get_projection", "modulename": "buteo.raster.core_raster", "qualname": "get_projection", "kind": "function", "doc": "<p>Gets the projection from a dataset, either as WKT or osr.\nThe input can be a path or a gdal.Dataset.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str/gdal.Dataset):</strong>  A path to a raster or a gdal.Dataset.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>wkt (bool, default=True): If True, returns the projection as WKT.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The projection of the input raster in the specified format.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">wkt</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_to_metadata", "modulename": "buteo.raster.core_raster", "qualname": "raster_to_metadata", "kind": "function", "doc": "<p>Reads metadata from a raster dataset or a list of raster datasets, and returns a dictionary or a list of dictionaries\ncontaining metadata information for each raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str/gdal.Dataset/list):</strong>  A path to a raster or a gdal.Dataset,\nor a list of paths to rasters.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>allow_lists (bool, default=True): If True, allows the input to be a\n      list of rasters. Otherwise, only a single raster is allowed.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>dict/list of dict: A dictionary or a list of dictionaries containing\n      metadata information for each raster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">dict</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_are_aligned", "modulename": "buteo.raster.core_raster", "qualname": "rasters_are_aligned", "kind": "function", "doc": "<p>Verifies whether a list of rasters are aligned.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  A list of rasters, either in gdal.Dataset or a string\nreferring to the dataset.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>same_extent (bool, default=True): If True, all the rasters should have\n      the same extent.\n  same_dtype (bool, default=False): If True, all the rasters should have\n      the same data type.\n  same_nodata (bool, default=False): If True, all the rasters should have\n      the same nodata value.\n  threshold (float, default=0.001): The threshold for the difference between\n      the rasters.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if rasters are aligned and optional parameters are True, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">same_extent</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">same_dtype</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">same_nodata</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">threshold</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">0.001</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_has_nodata", "modulename": "buteo.raster.core_raster", "qualname": "raster_has_nodata", "kind": "function", "doc": "<p>Verifies whether a raster has any nodata values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str):</strong>  A raster, either in gdal.Dataset or a string\nreferring to the dataset.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if raster has nodata values, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_have_nodata", "modulename": "buteo.raster.core_raster", "qualname": "rasters_have_nodata", "kind": "function", "doc": "<p>Verifies whether a list of rasters have any nodata values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  A list of rasters, either in gdal.Dataset or a string</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_have_same_nodata", "modulename": "buteo.raster.core_raster", "qualname": "rasters_have_same_nodata", "kind": "function", "doc": "<p>Verifies whether a list of rasters have the same nodata values.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  A list of rasters, either in gdal.Dataset or a string</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.get_first_nodata_value", "modulename": "buteo.raster.core_raster", "qualname": "get_first_nodata_value", "kind": "function", "doc": "<p>Gets the first nodata value from a raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str/gdal.Dataset):</strong>  The raster to get the nodata value from.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.count_bands_in_rasters", "modulename": "buteo.raster.core_raster", "qualname": "count_bands_in_rasters", "kind": "function", "doc": "<p>Counts the number of bands in a list of rasters.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  A list of rasters, either in gdal.Dataset or a string</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: The number of bands in the rasters.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_to_array", "modulename": "buteo.raster.core_raster", "qualname": "raster_to_array", "kind": "function", "doc": "<p>Converts a raster or a list of rasters into a NumPy array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (gdal.Dataset/str/list):</strong>  Raster(s) to convert.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>bands (list/str/int, default=\"all\"): Bands from the raster to convert to a numpy array.\n      Can be \"all\", an int, or a list of integers, or a single integer.\n  masked (bool/str, default=\"auto\"): If the array contains nodata values, determines whether\n      the resulting array should be a masked numpy array or a regular numpy array. If \"auto\",\n      the array will be masked only if the raster has nodata values.\n  filled (bool, default=False): If the array contains nodata values, determines whether\n      the resulting array should be a filled numpy array or a masked array.\n  fill_value (int/float, default=None): Value to fill the array with if filled is True.\n      If None, the nodata value of the raster is used.\n  bbox (list, default=None): A list of <code>[xmin, xmax, ymin, ymax]</code> to use as\n      the extent of the raster. Uses coordinates and the OGR format.\n  pixel_offsets (list/tuple, default=None): A list of\n      <code>[x_offset, y_offset, x_size, y_size]</code> to use as the extent of the\n      raster. Uses pixel offsets and the OGR format.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A numpy array in the 3D channel-last format.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;all&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">masked</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;auto&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">filled</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">fill_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bbox</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_offsets</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.array_to_raster", "modulename": "buteo.raster.core_raster", "qualname": "array_to_raster", "kind": "function", "doc": "<p>Turns a NumPy array into a GDAL dataset or exported\nas a raster using a reference raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>array (np.ndarray):</strong>  The numpy array to convert.</li>\n<li><strong>reference (str/gdal.Dataset):</strong>  The reference raster to use for the output.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (path, default=None): The destination to save to.\n  set_nodata (bool/float/int, default=\"arr\"): Can be set to\n      \u2022 \"arr\": The nodata value will be the same as the NumPy array.\n      \u2022 \"ref\": The nodata value will be the same as the reference raster.\n      \u2022 value: The nodata value will be the value provided.\n  allow_mismatches (bool, default=False): If True, the array can have a\n      different shape than the reference raster.\n  pixel_offsets (list/tuple, default=None): If provided, the array will be\n      written to the reference raster at the specified pixel offsets.\n      The list should be in the format [x_offset, y_offset, x_size, y_size].\n  bbox (list, default=None): If provided, the array will be written to\n      the reference raster at the specified bounding box.\n      The list should be in the format [min_x, min_y, max_x, max_y].\n  overwrite (bool, default=True): If the file exists, should it be\n      overwritten?\n  creation_options (list, default=[\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\",\n      \"BIGTIFF=YES\", \"COMPRESS=LZW\"]): List of GDAL creation options.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The filepath to the newly created raster(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">set_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;arr&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">allow_mismatches</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_offsets</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">bbox</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.raster_set_datatype", "modulename": "buteo.raster.core_raster", "qualname": "raster_set_datatype", "kind": "function", "doc": "<p>Converts the datatype of a raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str/gdal.Dataset/list):</strong>  The input raster(s) for which the\ndatatype will be changed.</li>\n<li><strong>dtype (str):</strong>  The target datatype for the output raster(s).</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (path/list, default=None): The output location for the\n      processed raster(s).\n  overwrite (bool, default=True): Determines whether to overwrite\n      existing files with the same name.\n  allow_lists (bool, default=True): Allows processing multiple\n      rasters as a list. If set to False, only single rasters are\n      accepted.\n  creation_options (list, default=[\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\",\n      \"BIGTIFF=YES\", \"COMPRESS=LZW\"]): A list of GDAL creation options\n      for the output raster(s).</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str/list: The filepath(s) of the newly created raster(s) with\n      the specified datatype.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.stack_rasters", "modulename": "buteo.raster.core_raster", "qualname": "stack_rasters", "kind": "function", "doc": "<p>Stacks a list of aligned rasters.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  List of rasters to stack.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str/None, default=None): The destination to save the output raster.\n  overwrite (bool, default=True): If the file exists, should it be overwritten?\n  dtype (str, default=None): The data type of the output raster.\n  creation_options (list,\n      default=[\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\", \"BIGTIFF=YES\", \"COMPRESS=LZW\"]):\n          A list of GDAL creation options for the output raster.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str/list: The filepath(s) to the newly created raster(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.stack_rasters_vrt", "modulename": "buteo.raster.core_raster", "qualname": "stack_rasters_vrt", "kind": "function", "doc": "<p>Stacks a list of rasters into a virtual raster (.vrt).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  List of rasters to stack.</li>\n<li><strong>out_path (str):</strong>  The destination to save the output raster.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>separate (bool, default=True): If the raster bands should be separated.\n  resample_alg (str, default='nearest'): The resampling algorithm to use.\n  nodata_src (float, default=None): The NoData value to use for the source rasters.\n  nodata_VRT (float, default=None): The NoData value to use for the VRT raster.\n  nodata_hide (bool, default=None): If the NoData value should be hidden.\n  options (list, default=[]): List of VRT options for GDAL.\n  overwrite (bool, default=True): If the file exists, should it be overwritten?\n  reference (str, default=None): The reference raster to use.\n  creation_options (list, default=[\"TILED=YES\", \"NUM_THREADS=ALL_CPUS\",\n                                   \"BIGTIFF=YES\", \"COMPRESS=LZW\"]):\n      A list of GDAL creation options for the output raster.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The filepath to the newly created VRT raster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"n\">separate</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_src</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_VRT</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_hide</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_intersect", "modulename": "buteo.raster.core_raster", "qualname": "rasters_intersect", "kind": "function", "doc": "<p>Checks if two rasters intersect using their latlong boundaries.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster1 (str/gdal.Dataset):</strong>  The first raster.</li>\n<li><strong>raster2 (str/gdal.Dataset):</strong>  The second raster.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: If the rasters intersect.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">raster2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.rasters_intersection", "modulename": "buteo.raster.core_raster", "qualname": "rasters_intersection", "kind": "function", "doc": "<p>Gets the latlng intersection of two rasters.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster1 (str/gdal.Dataset):</strong>  The first raster.</li>\n<li><strong>raster2 (str/gdal.Dataset):</strong>  The second raster.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>return_as_vector (bool, default=False): If True, the intersection will be returned as a vector.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: If the rasters intersect.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">raster2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">return_as_vector</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">Geometry</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.get_overlap_fraction", "modulename": "buteo.raster.core_raster", "qualname": "get_overlap_fraction", "kind": "function", "doc": "<p>Get the fraction of the overlap between two rasters.\n(e.g. 0.9 for mostly overlapping rasters)</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster1 (str/gdal.Dataset):</strong>  The first raster (master).</li>\n<li><strong>raster2 (str/gdal.Dataset):</strong>  The second raster.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: A value (0.0 - 1.0) representing the degree of overlap between the two rasters.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster1</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">raster2</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.create_empty_raster", "modulename": "buteo.raster.core_raster", "qualname": "create_empty_raster", "kind": "function", "doc": "<p>Create an empty raster.</p>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str, default=None): The output path. If None, a temporary file will be created.\n  width (int, default=100): The width of the raster in pixels.\n  height (int, default=100): The height of the raster in pixels.\n  pixel_size (int/float/list/tuple, default=10.0): The pixel size in units of the projection.\n  bands (int, default=1): The number of bands in the raster.\n  dtype (str, default=\"uint8\"): The data type of the raster.\n  x_min (int/float, default=0.0): The x coordinate of the top left corner of the raster.\n  y_max (int/float, default=0.0): The y coordinate of the top left corner of the raster.\n  nodata_value (int/float/None, default=None): The nodata value of the raster.\n  projection (int/str/gdal.Dataset/ogr.DataSource/osr.SpatialReference, default=\"EPSG:3857\"): The projection of the raster.\n  creation_options (list, default=None): A list of creation options.\n  overwrite (bool, default=True): If True, overwrite the output file if it exists.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The path to the output raster.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">width</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">height</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>,</span><span class=\"param\">\t<span class=\"n\">bands</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;uint8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">x_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">y_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">osr</span><span class=\"o\">.</span><span class=\"n\">SpatialReference</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;EPSG:3857&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.create_raster_from_array", "modulename": "buteo.raster.core_raster", "qualname": "create_raster_from_array", "kind": "function", "doc": "<p>Create a raster from a numpy array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to convert to a raster.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str, default=None): The output path. If None, a temporary file will be created.\n  pixel_size (int/float/list/tuple, default=10.0): The pixel size of the output raster.\n  x_min (int/float, default=0.0): The x coordinate of the top left corner of the output raster.\n  y_max (int/float, default=0.0): The y coordinate of the top left corner of the output raster.\n  projection (int/str/gdal.Dataset/ogr.DataSource/osr.SpatialReference,\n      default=\"EPSG:3857\"): The projection of the output raster.\n  creation_options (list, default=None): The creation options for the output raster.\n  overwrite (bool, default=True): If True, the output raster will be overwritten if it already exists.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_size</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]]</span> <span class=\"o\">=</span> <span class=\"mf\">10.0</span>,</span><span class=\"param\">\t<span class=\"n\">x_min</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">y_max</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">osr</span><span class=\"o\">.</span><span class=\"n\">SpatialReference</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;EPSG:3857&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.create_grid_with_coordinates", "modulename": "buteo.raster.core_raster", "qualname": "create_grid_with_coordinates", "kind": "function", "doc": "<p>Create a grid of coordinates from a raster. Format is (x, y, xy).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str/gdal.Dataset):</strong>  The raster to create the grid from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: (x, y, xy-coordinates)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.core_raster.mosaic_rasters", "modulename": "buteo.raster.core_raster", "qualname": "mosaic_rasters", "kind": "function", "doc": "<p>NOT YET IMPLEMENTED: Mosaic a list of rasters into a single raster.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster_paths (str/list):</strong>  The list of rasters to mosaic.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str, default=None): The output path. If None, a temporary file will be created.\n  creation_options (list, default=None): The creation options for the output raster.\n  overwrite (bool, default=True): If True, the output raster will be overwritten if it already exists.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster_paths</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.edge_detection", "modulename": "buteo.raster.edge_detection", "kind": "module", "doc": "<h3 id=\"perform-morphological-operations-on-arrays-and-rasters\">Perform morphological operations on arrays and rasters.</h3>\n"}, {"fullname": "buteo.raster.edge_detection.adjust_kernel", "modulename": "buteo.raster.edge_detection", "qualname": "adjust_kernel", "kind": "function", "doc": "<p>Adjust an edge kernel by a normal kernel. Only works for symmetric kernels.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">kernel</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.edge_detection.get_sobel_kernel", "modulename": "buteo.raster.edge_detection", "qualname": "get_sobel_kernel", "kind": "function", "doc": "<p>Get a sobel kernel of arbitrary size.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">size</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.edge_detection.get_roberts_prewitt_kernel", "modulename": "buteo.raster.edge_detection", "qualname": "get_roberts_prewitt_kernel", "kind": "function", "doc": "<p>Get a roberts cross or prewitt kernel, only available for size 2x2 and 3x3</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">roberts</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.edge_detection.edge_detection", "modulename": "buteo.raster.edge_detection", "qualname": "edge_detection", "kind": "function", "doc": "<p>Perform an detection method.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">method</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">merge_results</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">gradient_output</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.9</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.edge_detection.edge_detection_sobel", "modulename": "buteo.raster.edge_detection", "qualname": "edge_detection_sobel", "kind": "function", "doc": "<p>Detect edges using the sobel filtering method.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">merge_results</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">gradient_output</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.9</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.edge_detection.edge_detection_roberts", "modulename": "buteo.raster.edge_detection", "qualname": "edge_detection_roberts", "kind": "function", "doc": "<p>Detect edges using the roberts filtering method.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">merge_results</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">gradient_output</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.9</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.edge_detection.edge_detection_prewitt", "modulename": "buteo.raster.edge_detection", "qualname": "edge_detection_prewitt", "kind": "function", "doc": "<p>Detect edges using the prewitt filtering method.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">merge_results</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">gradient_output</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=-</span><span class=\"mf\">9999.9</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.grid", "modulename": "buteo.raster.grid", "kind": "module", "doc": "<h3 id=\"create-grids-from-rasters\">Create grids from rasters.</h3>\n\n<p>Cut rasters to grids. Use vectors or rasters as grids.</p>\n"}, {"fullname": "buteo.raster.grid.raster_to_grid", "modulename": "buteo.raster.grid", "qualname": "raster_to_grid", "kind": "function", "doc": "<p>Clips a raster to a grid. Generate .vrt.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.DataSet_): The input raster. </br>\n<code>grid</code> (_str_/ogr.DataSource): The grid to use. </br>\n<code>out_dir</code> (_str_): The output directory. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>use_field</code> (_str_/_None_): A field to use to name the grid cells. </br>\n<code>generate_vrt</code> (_bool_): If <strong>True</strong>, the output raster will be a .vrt. </br>\n<code>overwrite</code> (_bool_): If <strong>True</strong>, the output raster will be overwritten. </br>\n<code>process_layer</code> (_int_): The layer from the grid to process. </br>\n<code>creation_options</code> (_list_/_None_): Creation options for the output raster. </br>\n<code>verbose</code> (_int_): The verbosity level. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The filepath for the newly created raster.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">grid</span>,</span><span class=\"param\">\t<span class=\"n\">out_dir</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">use_field</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">generate_vrt</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.morphology", "modulename": "buteo.raster.morphology", "kind": "module", "doc": "<h3 id=\"perform-morphological-operations-on-arrays-and-rasters\">Perform morphological operations on arrays and rasters.</h3>\n"}, {"fullname": "buteo.raster.morphology.morph_erode", "modulename": "buteo.raster.morphology", "qualname": "morph_erode", "kind": "function", "doc": "<p>Erode an array by taking the local minimum.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.morphology.morph_dilate", "modulename": "buteo.raster.morphology", "qualname": "morph_dilate", "kind": "function", "doc": "<p>Dilate an array by taking the local maximum.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.morphology.morph_open", "modulename": "buteo.raster.morphology", "qualname": "morph_open", "kind": "function", "doc": "<p>Perform the open mortholigical operation on an array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.morphology.morph_close", "modulename": "buteo.raster.morphology", "qualname": "morph_close", "kind": "function", "doc": "<p>Perform the close morphological operation on an array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.morphology.morph_tophat", "modulename": "buteo.raster.morphology", "qualname": "morph_tophat", "kind": "function", "doc": "<p>Perform the top_hat morphological operation on the array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.morphology.morph_bothat", "modulename": "buteo.raster.morphology", "qualname": "morph_bothat", "kind": "function", "doc": "<p>Perform the bottom_hat morphological operation on the array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.morphology.morph_difference", "modulename": "buteo.raster.morphology", "qualname": "morph_difference", "kind": "function", "doc": "<p>Perform the difference morphological operation on the array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata", "modulename": "buteo.raster.nodata", "kind": "module", "doc": "<h3 id=\"handle-nodata-values-in-rasters\">Handle nodata values in rasters.</h3>\n\n<p>A module to handle the various aspects of NODATA in raster files.</p>\n"}, {"fullname": "buteo.raster.nodata.raster_has_nodata_value", "modulename": "buteo.raster.nodata", "qualname": "raster_has_nodata_value", "kind": "function", "doc": "<p>Check if a raster or a list of rasters contain nodata values</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.Dataset_, _list_): The raster to check for nodata values.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the raster or list of rasters contain nodata values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_get_nodata_value", "modulename": "buteo.raster.nodata", "qualname": "raster_get_nodata_value", "kind": "function", "doc": "<p>Get the nodata value of a raster or a list of rasters.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.Dataset_, _list_): The raster(s) to get nodata values from.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_float_/_int_/_list_): The nodata value(s) of the raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_set_nodata", "modulename": "buteo.raster.nodata", "qualname": "raster_set_nodata", "kind": "function", "doc": "<p>Sets all the nodata for raster(s) to a value.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.Dataset_/_list_): The raster(s) to set nodata values for. </br>\n<code>dst_nodata</code> (_float_/_int_/_str_/_None_): The target nodata value. If 'infer' the nodata\n    value is set based on the input datatype. A list of nodata values can be based matching\n    the amount of input rasters. If multiple nodata values should be set,\n    use raster_mask_values. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The destination of the changed rasters. (Default: <strong>None</strong>) </br>\n<code>overwrite</code> (_bool_): Should the rasters be overwritten if they already exist? (Default: <strong>True</strong>) </br>\n<code>in_place</code> (_bool_): Should the rasters be changed in_place or copied? (Default: <strong>False</strong>) </br>\n<code>prefix</code> (_str_): Prefix to add to the output. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str): Suffix to add to the output. (Default: <strong>\"\"</strong>) </br>\n<code>creation_options</code> (_list_): Creation options for the output rasters. (Default: <strong>None</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Returns the rasters with nodata set. If in_place is True a reference to the\nchanged orignal is returned, otherwise a copied memory raster or the path to the\ngenerated raster is outputted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_nodata_set&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_remove_nodata", "modulename": "buteo.raster.nodata", "qualname": "raster_remove_nodata", "kind": "function", "doc": "<p>Removes all the nodata from a raster or a list of rasters.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.Dataset_/_list_): The raster(s) to remove nodata values for. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The destination of the changed rasters. (Default: <strong>None</strong>) </br>\n<code>overwrite</code> (_bool_): Should the rasters be overwritten if they already exist? (Default: <strong>True</strong>) </br>\n<code>in_place</code> (_bool_): Should the rasters be changed in_place or copied? (Default: <strong>False</strong>) </br>\n<code>prefix</code> (_str_): Prefix to add to the output. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): Suffix to add to the output. (Default: <strong>\"_nodata_removed\"</strong>) </br>\n<code>creation_options</code> (_list_): Creation options for the output rasters. (Default: <strong>None</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Returns the rasters with nodata removed. If in_place is True a reference to the\nchanged orignal is returned, otherwise a copied memory raster or the path to the\ngenerated raster is outputted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_nodata_removed&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.nodata.raster_mask_values", "modulename": "buteo.raster.nodata", "qualname": "raster_mask_values", "kind": "function", "doc": "<p>Mask a raster with a list of values.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.Dataset_/_list_): The raster(s) to mask. </br>\n<code>values_to_mask</code> (_list_): The values to mask. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>include_original_nodata</code> (_bool_): Should the nodata_value of the input raster be added\nto the list of masked values? (Default: <strong>True</strong>) </br>\n<code>dst_nodata</code> (_float_/_int_/_str_/_list_): The nodata value to use for the output raster.\nIf infer, the nodata_value from the input raster is used. (Default: <strong>\"infer\"</strong>) </br>\n<code>out_path</code> (_str_/_list_/_None_): The destination of the changed rasters.\nIf out_paths are specified, in_place is automatically set to False. The path can be a folder. (Default: <strong>None</strong>)</br>\n<code>in_place</code> (_bool_): Should the rasters be changed in_place or copied? (Default: <strong>False</strong>) </br>\n<code>overwrite</code> (_bool_): If the output path exists already, should it be overwritten? (Default: <strong>True</strong>)</br>\n<code>prefix</code> (_str_): Prefix to add to the output. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): Suffix to add to the output. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Should a uuid be added to the output path? (Default: <strong>False</strong>) </br>\n<code>creation_options</code> (_list_/_None_): The GDAL creation options to be passed. (Default: <strong>None</strong>) </br></p>\n\n<p>Returns:\n(_str_/_list_): Returns the rasters with nodata removed. If in_place is True a reference to the\nchanged orignal is returned, otherwise a copied memory raster or the path to the\ngenerated raster is outputted.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">values_to_mask</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">include_original_nodata</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"p\">[]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches", "modulename": "buteo.raster.patches", "kind": "module", "doc": "<p>Create patches from rasters, used for machine learnign applications.</p>\n"}, {"fullname": "buteo.raster.patches.get_kernel_weights", "modulename": "buteo.raster.patches", "qualname": "get_kernel_weights", "kind": "function", "doc": "<p>Weight a kernel according to how close to an edge a given pixel is.</p>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>tile_size (int=64): The size of the square kernel.\n  edge_distance (int=5): The distance from the edge to consider for weighting.\n  epsilon (float=1e-7): A small value to prevent division by zero.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 2D NumPy array of shape (tile_size, tile_size) with the kernel weights.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">64</span>,</span><span class=\"param\">\t<span class=\"n\">edge_distance</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">epsilon</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">1e-07</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.merge_weighted_median", "modulename": "buteo.raster.patches", "qualname": "merge_weighted_median", "kind": "function", "doc": "<p>Calculate the weighted median of a multi-dimensional array along the first axis.\nThis is the order (number_of_overlaps, tile_size, tile_size, number_of_bands)</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The input array.</li>\n<li><strong>arr_weight (np.ndarray):</strong>  The weight array with the same shape as the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 3D NumPy array of shape (arr.shape[1], arr.shape[2], arr.shape[3]) with the weighted medians.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">arr_weight</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.merge_weighted_average", "modulename": "buteo.raster.patches", "qualname": "merge_weighted_average", "kind": "function", "doc": "<p>Calculate the weighted average of a multi-dimensional array along the last axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The input array.</li>\n<li><strong>arr_weight (np.ndarray):</strong>  The weight array with the same shape as the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted averages.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">arr_weight</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.merge_weighted_minmax", "modulename": "buteo.raster.patches", "qualname": "merge_weighted_minmax", "kind": "function", "doc": "<p>Calculate the weighted min or max of a multi-dimensional array along the last axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The input array.</li>\n<li><strong>arr_weight (np.ndarray):</strong>  The weight array with the same shape as the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted min or max.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">arr_weight</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">method</span><span class=\"o\">=</span><span class=\"s1\">&#39;max&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.merge_weighted_olympic", "modulename": "buteo.raster.patches", "qualname": "merge_weighted_olympic", "kind": "function", "doc": "<p>Calculate the olympic value of a multi-dimensional array along the last axis.\nUsing olympic sort, the highest and lowest values are removed from the calculation.\nIf level is 1, then the highest and loweest values are removed. If the level is 2,\nthen the 2 highest and lowest values are removed, and so on.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The input array.</li>\n<li><strong>arr_weight (np.ndarray):</strong>  The weight array with the same shape as the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the olympic value.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">arr_weight</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">level</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.merge_weighted_mad", "modulename": "buteo.raster.patches", "qualname": "merge_weighted_mad", "kind": "function", "doc": "<p>Merge an array of predictions using the MAD-merge methodology.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The input array.</li>\n<li><strong>arr_weight (np.ndarray):</strong>  The weight array with the same shape as the input array.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>mad_dist (float=2.0): The MAD distance.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the MAD-merged values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">arr_weight</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">mad_dist</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">2.0</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.unique_values", "modulename": "buteo.raster.patches", "qualname": "unique_values", "kind": "function", "doc": "<p>Find the unique values in a 1D NumPy array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 1D NumPy array with the unique values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.merge_weighted_mode", "modulename": "buteo.raster.patches", "qualname": "merge_weighted_mode", "kind": "function", "doc": "<p>Calculate the weighted mode of a multi-dimensional array along the last axis.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The input array.</li>\n<li><strong>arr_weight (np.ndarray):</strong>  The weight array with the same shape as the input array.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A 3D NumPy array of shape (arr.shape[0], arr.shape[1], 1) with the weighted modes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">arr_weight</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.calculate_offset_single", "modulename": "buteo.raster.patches", "qualname": "calculate_offset_single", "kind": "function", "doc": "<p>Calculate a list of offset values for a given tile size and number of offsets.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tile_size (int):</strong>  The size of each tile.</li>\n<li><strong>num_offsets (int):</strong>  The desired number of offsets to be calculated.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[int]: A list of calculated offset values.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">num_offsets</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.get_offsets", "modulename": "buteo.raster.patches", "qualname": "get_offsets", "kind": "function", "doc": "<p>Generate a list of offset pairs for a given tile size and number of offsets in x and y dimensions.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>tile_size (int):</strong>  The size of each tile.</li>\n<li><strong>offsets_y (int):</strong>  The desired number of offsets to be calculated in the y dimension.</li>\n<li><strong>offsets_x (int):</strong>  The desired number of offsets to be calculated in the x dimension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[Tuple[int, int]]: A list of tuples containing offset pairs for y and x dimensions.\n  order is (y, x)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">offsets_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">offsets_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.borders_are_necessary", "modulename": "buteo.raster.patches", "qualname": "borders_are_necessary", "kind": "function", "doc": "<p>Checks if borders are necessary for the given array.\nWidth and height are returned as a tuple.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to be checked.</li>\n<li><strong>tile_size (int):</strong>  The size of each tile.</li>\n<li><strong>offset (list):</strong>  The offset to be used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing of borders are needed in (height, width) dims.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.borders_are_necessary_list", "modulename": "buteo.raster.patches", "qualname": "borders_are_necessary_list", "kind": "function", "doc": "<p>Checks if borders are necessary for the given array.\nWidth and height are returned as a tuple.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  The array to be checked.</li>\n<li><strong>tile_size (int):</strong>  The size of each tile.</li>\n<li><strong>offsets (list):</strong>  The offset to be used.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: A tuple containing of borders are needed in (height, width) dims.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.array_to_patches_single", "modulename": "buteo.raster.patches", "qualname": "array_to_patches_single", "kind": "function", "doc": "<p>Generate patches from an array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  A numpy array to be divided into patches.</li>\n<li><strong>tile_size (int):</strong>  The size of each tile/patch, e.g., 64 for 64x64 tiles.</li>\n<li><strong>offset (list/tuple/None=None):</strong>  The x and y offset values for the input\narray. If not provided, defaults to [0, 0].</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>nd.array: A numpy array containing the patches.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.patches_to_array_single", "modulename": "buteo.raster.patches", "qualname": "patches_to_array_single", "kind": "function", "doc": "<p>Reconstitute an array from patches.</p>\n\n<p>Given an array of patches, this function stitches them back together\nto form the original array of the specified shape.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>patches (np.ndarray):</strong>  A numpy array containing the patches to be\nstitched together.</li>\n<li><strong>shape (list/tuple):</strong>  The desired shape of the output array.</li>\n<li><strong>tile_size (int):</strong>  The size of each tile/patch Eg. 64 for 64x64 tiles.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>offset (list/tuple/None=None): The x and y offset values for the\n      target array. If not provided, defaults to [0, 0].</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: A numpy array with the original shape, formed by stitching\n      together the provided patches.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">patches</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">shape</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">Tuple</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">offset</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">Tuple</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">background_value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.patches_to_weights", "modulename": "buteo.raster.patches", "qualname": "patches_to_weights", "kind": "function", "doc": "<p>Calculate the weights for each patch based on the distance to the edge.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">patches</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>, </span><span class=\"param\"><span class=\"n\">edge_distance</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.array_to_patches", "modulename": "buteo.raster.patches", "qualname": "array_to_patches", "kind": "function", "doc": "<p>Generate patches from an array based on the specified parameters.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  A numpy array to be divided into patches.</li>\n<li><strong>tile_size (int):</strong>  The size of each tile/patch, e.g., 64 for 64x64 tiles.</li>\n<li><strong>offsets_y (int=3):</strong>  The desired number of offsets to be calculated in the y dimension.</li>\n<li><strong>offsets_x (int=3):</strong>  The desired number of offsets to be calculated in the x dimension.</li>\n<li><strong>border_check (bool=True):</strong>  Whether or not to include border patches.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The concatenate patches along axis 0. In the order (patches, y, x, channels)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"p\">:</span> <span class=\"nb\">int</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_y</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_x</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>,</span><span class=\"param\">\t<span class=\"n\">border_check</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.predict_array", "modulename": "buteo.raster.patches", "qualname": "predict_array", "kind": "function", "doc": "<p>Generate patches from an array. Also outputs the offsets and the shapes of the offsets. Only\nsuppors the prediction of single values in the rasters/arrays. </p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  A numpy array to be divided into patches.</li>\n<li><strong>callback (function):</strong>  The callback function to be used for prediction. The callback function\nmust take a numpy array as input and return a numpy array as output.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>tile_size (int=64): The size of each tile/patch, e.g., 64 for 64x64 tiles.\n  offsets_y (int=1): The desired number of offsets to be calculated in the y dimension.\n  offsets_x (int=1): The desired number of offsets to be calculated in the x dimension.\n  border_check (bool=True): Whether or not to include border patches.\n  merge_method (str=\"median\"): The method to use for merging the patches. Valid methods\n  are ['mad', 'median', 'mean', 'mode', \"min\", \"max\", \"olympic1\", \"olympic2\"]\n  edge_weighted (bool=True): Whether or not to weight the edges patches of patches less\n      than the central parts.\n  edge_distance (int=3): The distance from the edge to be weighted less. Usually good to\n      adjust this to your maximum convolution kernel size.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: The predicted array.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">callback</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">tile_size</span><span class=\"o\">=</span><span class=\"mi\">64</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_y</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">offsets_x</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">border_check</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">merge_method</span><span class=\"o\">=</span><span class=\"s1\">&#39;median&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">edge_weighted</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">edge_distance</span><span class=\"o\">=</span><span class=\"mi\">3</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.patches.predict_array_pixel", "modulename": "buteo.raster.patches", "qualname": "predict_array_pixel", "kind": "function", "doc": "<p>Predicts an array pixel by pixel.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (np.ndarray):</strong>  A numpy array to be divided into patches.</li>\n<li><strong>callback (function):</strong>  The callback function to be used for prediction. The callback function\nmust take a numpy array as input and return a numpy array as output.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>,</span><span class=\"param\">\t<span class=\"n\">callback</span><span class=\"p\">:</span> <span class=\"n\">Callable</span><span class=\"p\">[[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">],</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.proximity", "modulename": "buteo.raster.proximity", "kind": "module", "doc": "<h3 id=\"calculate-distances-on-a-raster\">Calculate distances on a raster.</h3>\n\n<p>Module to calculate the distance from a pixel value to other pixels.</p>\n"}, {"fullname": "buteo.raster.proximity.calc_proximity", "modulename": "buteo.raster.proximity", "qualname": "calc_proximity", "kind": "function", "doc": "<p>Calculate the proximity of input_raster to values</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>input_rasters</code> (_list_): A list of rasters to use as input. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>target_value</code> (_int_/_float_): The value to use as target. (Default: <strong>1</strong>) </br>\n<code>unit</code> (_str_): The unit to use for the distance. GEO or PIXEL. (Default: <strong>\"GEO\"</strong>) </br>\n<code>out_path</code> (_str_/_None_/_list_): The output path. (Default: <strong>None</strong>) </br>\n<code>max_dist</code> (_int_/_float_): The maximum distance to use. (Default: <strong>1000</strong>) </br>\n<code>add_border</code> (_bool_): If <strong>True</strong>, a border will be added to the raster. (Default: <strong>False</strong>) </br>\n<code>border_value</code> (_int_/_float_): The value to use for the border. (Default: <strong>0</strong>) </br>\n<code>weighted</code> (_bool_): If <strong>True</strong>, the distance will be divided by the max distance. (Default: <strong>False</strong>) </br>\n<code>invert</code> (_bool_): If <strong>True</strong>, the target will be inversed. (Default: <strong>False</strong>) </br>\n<code>return_array</code> (_bool_): If <strong>True</strong> a NumPy array will be returned instead of a raster. (Default: <strong>False</strong>) </br>\n<code>prefix</code> (_str_): Prefix to add to the output. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): Suffix to add to the output. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Should a uuid be added to the output path? (Default: <strong>False</strong>) </br>\n<code>creation_options</code> (_list_/_None_): The GDAL creation options to be passed. (Default: <strong>None</strong>) </br>\n<code>overwrite</code> (_bool_): If the output path exists already, should it be overwritten? (Default: <strong>True</strong>)</br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_np.ndarray_): A path to a raster with the calculate proximity, or a numpy array with the data.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">input_rasters</span>,</span><span class=\"param\">\t<span class=\"n\">target_value</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">unit</span><span class=\"o\">=</span><span class=\"s1\">&#39;GEO&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_dist</span><span class=\"o\">=</span><span class=\"mi\">1000</span>,</span><span class=\"param\">\t<span class=\"n\">add_border</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">border_value</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">weighted</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">invert</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">return_array</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_proximity&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.reproject", "modulename": "buteo.raster.reproject", "kind": "module", "doc": "<h3 id=\"reproject-rasters\">Reproject rasters.</h3>\n\n<p>Module to reproject rasters to a target coordinate reference system.\nCan uses references from vector or other raster datasets.</p>\n"}, {"fullname": "buteo.raster.reproject.find_common_projection", "modulename": "buteo.raster.reproject", "qualname": "find_common_projection", "kind": "function", "doc": "<p>Find the common projection of a list of rasters. If no rasters have \nthe majority of the same projection, the function will return the\nprojection of the first raster. If only on raster is provided, the\nprojection of that raster will be returned.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  A list of rasters.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>osr.SpatialReference: The common projection.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.reproject.reproject_raster", "modulename": "buteo.raster.reproject", "qualname": "reproject_raster", "kind": "function", "doc": "<p>Reproject a raster(s) to a target coordinate reference system.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str/list/gdal.Dataset):</strong>  The raster(s) to reproject.</li>\n<li><strong>projection (int/str/gdal.Dataset/ogr.DataSource/osr.SpatialReference):</strong>  The projection is inferred from\nthe input. The input can be: WKT proj, EPSG proj, Proj, osr proj, or read\nfrom a vector or raster datasource either from path or in-memory.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str/list/None, default=None): The output path. If not provided, the output path is inferred from the input.\n  resample_alg (str, default=\"nearest\"): The resampling algorithm.\n  copy_if_same (bool, default=True): If the input and output projections are the same, copy the input raster to the output path.\n  overwrite (bool, default=True): If the output path already exists, overwrite it.\n  creation_options (list/None, default=None): A list of creation options for the output raster.\n  dst_nodata (str/int/float, default=\"infer\"): The nodata value for the output raster.\n  dtype (str/None, default=None): The data type for the output raster.\n  prefix (str, default=\"\"): The prefix to add to the output path.\n  suffix (str, default=\"\"): The suffix to add to the output path.\n  add_uuid (bool, default=False): If True, add a UUID to the output path.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str/list: The output path(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">osr</span><span class=\"o\">.</span><span class=\"n\">SpatialReference</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">copy_if_same</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.reproject.match_raster_projections", "modulename": "buteo.raster.reproject", "qualname": "match_raster_projections", "kind": "function", "doc": "<p>Match a raster or list of rasters to a master layer. The master can be\neither an OGR layer or a GDAL layer.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rasters (list):</strong>  A list of rasters to match.</li>\n<li><strong>reference (str/gdal.Dataset/ogr.DataSource):</strong>  Path to the reference raster\nor vector.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>out_path (str/list, default=None): Paths to the output. If not provided,\n      the output will be in-memory rasters.\n  overwrite (bool, default=True): If True, existing rasters will be\n      overwritten.\n  dst_nodata (str, default='infer'): Value to use for no-data pixels. If not\n      provided, the value will be transfered from the original.\n  copy_if_already_correct (bool, default=True): If True, the raster will be\n      copied if it is already in the correct projection.\n  creation_options (list, default=None): List of creation options to pass\n      to the output raster.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: A list of reprojected input rasters with the correct projection.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">rasters</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">]]]</span>,</span><span class=\"param\">\t<span class=\"n\">reference</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">gdal</span><span class=\"o\">.</span><span class=\"n\">Dataset</span><span class=\"p\">,</span> <span class=\"n\">osgeo</span><span class=\"o\">.</span><span class=\"n\">ogr</span><span class=\"o\">.</span><span class=\"n\">DataSource</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">NoneType</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">copy_if_already_correct</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.resample", "modulename": "buteo.raster.resample", "kind": "module", "doc": "<h3 id=\"resample-rasters\">Resample rasters.</h3>\n\n<p>Module to resample rasters to a target resolution.\nCan uses references from vector or other raster datasets.</p>\n"}, {"fullname": "buteo.raster.resample.resample_raster", "modulename": "buteo.raster.resample", "qualname": "resample_raster", "kind": "function", "doc": "<p>Resampled raster(s) given a target size. </br>\n<strong>Beware</strong> if your input is in latitude and longitude, you'll need to specify the target_size in degrees as well.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>raster (str/list/gdal.Dataset):</strong>  The input raster(s) to resample.</li>\n<li><strong>target_size (str/int/ogr.DataSource/gdal.Dataset):</strong>  The desired resolution for the resampled raster(s),\nin the same unit as the raster projection. For better resampling results, reproject to a projected\ncoordinate system first. If a raster is provided as the target_size, the function will read the pixel\nsize from that raster.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>target_in_pixels (bool, default=False): If True, interprets target_size as the number of pixels.\n  out_path (str/None, default=None): The output path for the resampled raster(s). If not provided, the output\n      path is inferred from the input raster(s).\n  resample_alg (str, default=\"nearest\"): The resampling algorithm to use.\n  copy_if_same (bool, default=True): If input and output projections are the same, copies the input raster\n      to the output path.\n  overwrite (bool, default=True): If the output path already exists, overwrites it.\n  creation_options (list/None, default=None): A list of creation options for the output raster(s).\n  dst_nodata (str/int/float, default=\"infer\"): The nodata value for the output raster(s).\n  prefix (str, default=\"\"): The prefix to add to the output path.\n  suffix (str, default=\"_reprojected\"): The suffix to add to the output path.\n  add_uuid (bool, default=False): If True, adds a UUID to the output path.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str/list: The output path(s) of the resampled raster(s).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">target_size</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">target_in_pixels</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.resample.resample_array", "modulename": "buteo.raster.resample", "qualname": "resample_array", "kind": "function", "doc": "<p>Resample a numpy array using the GDAL algorithms.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">target_shape_pixels</span>, </span><span class=\"param\"><span class=\"n\">resample_alg</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.shift", "modulename": "buteo.raster.shift", "kind": "module", "doc": "<h3 id=\"shift-rasters\">Shift rasters.</h3>\n\n<p>Module to shift the location of rasters in geographic coordinates.</p>\n"}, {"fullname": "buteo.raster.shift.shift_raster", "modulename": "buteo.raster.shift", "qualname": "shift_raster", "kind": "function", "doc": "<p>Shifts a raster in a given direction.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_list_/_gdal.Dataset_): The raster(s) to be shifted. </br>\n<code>shift_list</code> (_list_/_tuple_): The shift in x and y direction. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The path to the output raster. If None, the raster is\ncreated in memory. (Default: <strong>None</strong>)</br>\n<code>overwrite</code> (_bool_): If True, the output raster will be overwritten if it already exists. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): The prefix to be added to the output raster name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix to be added to the output raster name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): If True, a unique identifier will be added to the output raster name. (Default: <strong>False</strong>) </br>\n<code>creation_options</code> (_list_/_None_): The creation options to be used when creating the output. (Default: <strong>None</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the shifted raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">shift_list</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.textures", "modulename": "buteo.raster.textures", "kind": "module", "doc": "<h3 id=\"perform-morphological-operations-on-arrays-and-rasters\">Perform morphological operations on arrays and rasters.</h3>\n"}, {"fullname": "buteo.raster.textures.texture_local_variance", "modulename": "buteo.raster.textures", "qualname": "texture_local_variance", "kind": "function", "doc": "<p>Create a variance texture layer.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.textures.texture_local_median", "modulename": "buteo.raster.textures", "qualname": "texture_local_median", "kind": "function", "doc": "<p>Create a median filtered array.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.textures.texture_local_blur", "modulename": "buteo.raster.textures", "qualname": "texture_local_blur", "kind": "function", "doc": "<p>Apply a blurring filter. Default is a square linear distance weighted blur.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.textures.texture_local_mode", "modulename": "buteo.raster.textures", "qualname": "texture_local_mode", "kind": "function", "doc": "<p>Apply a mode filter. Default is a circular filter with no distance decay.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;none&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.textures.texture_hole_dif", "modulename": "buteo.raster.textures", "qualname": "texture_hole_dif", "kind": "function", "doc": "<p>Create a 'hole' filter, representing the difference between a pixel and its surrounding neighbourhood.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>arr</code> (_np.ndarray_): The array on which to calculate the filter.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>filter_size</code> (_int_): The size of the kernel to use. filter_size x filter_size. (Default: <strong>5</strong>)</p>\n\n<p><code>spherical</code> (_bool_): If True, the filter applied will be weighted by a circle (Default: <strong>False</strong>)</p>\n\n<p><code>nodata</code> (_bool_): Does the array contain nodata and should the values be left? (Default: <strong>False</strong>)</p>\n\n<p><code>nodata_value</code> (_bool_): If nodata is True, what value is nodata. (Default: <strong>9999.9</strong>)</p>\n\n<p><code>distance_weight</code> (_str_): How should the distance from the center be treated: (Default: <strong>\"linear\"</strong>)</p>\n\n<pre><code>* `\"none\"`: no distance weighing will be done.\n\n* `\"linear\"`: np.power((1 - decay), normed).\n\n* `\"sqrt\"`: np.power(np.sqrt((1 - decay)), normed).\n\n* `\"power\"`: np.power(np.power((1 - decay), 2), normed).\n\n* `\"log\"`: np.log(normed + 2).\n\n* `\"gaussian\"`: np.exp(-(np.power(normed, 2)) / (2 * np.power(sigma, 2))).\n</code></pre>\n\n<p><code>distance_decay</code> (_float_): Rate of distance decay. (Default: <strong>0.2</strong>)</p>\n\n<p><code>distance_sigma</code> (_float_): The sigma to use for gaussian decay. (Default: <strong>1.0</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_np.ndarray_): The filtered array.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">arr</span>,</span><span class=\"param\">\t<span class=\"n\">filter_size</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">spherical</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"mf\">9999.0</span>,</span><span class=\"param\">\t<span class=\"n\">distance_weight</span><span class=\"o\">=</span><span class=\"s1\">&#39;linear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">distance_decay</span><span class=\"o\">=</span><span class=\"mf\">0.2</span>,</span><span class=\"param\">\t<span class=\"n\">distance_sigma</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.timeseries", "modulename": "buteo.raster.timeseries", "kind": "module", "doc": "<p>Time series analysis functions.</p>\n"}, {"fullname": "buteo.raster.timeseries.least_squares_slope", "modulename": "buteo.raster.timeseries", "qualname": "least_squares_slope", "kind": "function", "doc": "<p>Compute the least squares slope for a set of data points along the last channel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.timeseries.robust_least_squares_slope", "modulename": "buteo.raster.timeseries", "qualname": "robust_least_squares_slope", "kind": "function", "doc": "<p>Compute the robust least squares slope for a set of data points along the last channel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">std_threshold</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">splits</span><span class=\"o\">=</span><span class=\"mi\">10</span>, </span><span class=\"param\"><span class=\"n\">report_progress</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.vectorize", "modulename": "buteo.raster.vectorize", "kind": "module", "doc": "<h3 id=\"vectorize-rasters\">Vectorize rasters.</h3>\n\n<p>Module to turn rasters into vector representations.</p>\n"}, {"fullname": "buteo.raster.vectorize.vectorize_raster", "modulename": "buteo.raster.vectorize", "qualname": "vectorize_raster", "kind": "function", "doc": "<p>Vectorizes a raster by turning it into polygons per unique value. Works\nbest on integer rasters.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_list_/_gdal.Dataset_): The raster(s) to vectorize.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The path(s) to save the vectorized raster(s) to. (Default: <strong>None</strong>) </br>\n<code>band</code> (_int_): The band to vectorize. (Default: <strong>1</strong>) </br>\n<code>prefix</code> (_str_): The prefix to be added to the output raster name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix to be added to the output raster name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): If True, a unique identifier will be added to the output raster name. (Default: <strong>False</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the vectorized raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">band</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.raster.warp", "modulename": "buteo.raster.warp", "kind": "module", "doc": "<h3 id=\"gdal-warp-functions\">GDAL Warp functions</h3>\n\n<p>Module to wrap the functionality of GDAL's gdalwarp.</p>\n"}, {"fullname": "buteo.raster.warp.warp_raster", "modulename": "buteo.raster.warp", "qualname": "warp_raster", "kind": "function", "doc": "<p>Warps a raster into a target raster. </br></p>\n\n<p>Please be aware that all_touch does not work if target_size is set.\nIf all_touch is required while resampling. Do it in two steps:\nresample -> warp or resample -> clip.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_list_/_gdal.Dataset_): The raster(s) to warp.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The path to the output raster(s). If not set, a memory raster is created. (Default: <strong>None</strong>) </br>\n<code>projection</code> (_str_/_osr.SpatialReference_/_gdal.Dataset_/_ogr.DataSource_): The projection of the output raster. If not set, the projection of the input raster is used. (Default: <strong>None</strong>) </br>\n<code>clip_geom</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The geometry to clip the raster to. (Default: <strong>None</strong>) </br>\n<code>target_size</code> (_tuple_/_None_): The target size of the output raster. If not set, the size of the input raster is used. (Default: <strong>None</strong>) </br>\n<code>target_in_pixels</code> (_bool_): If True, the target size is in pixels. If False, the target size is in map units. (Default: <strong>False</strong>) </br>\n<code>resample_alg</code> (_str_): The resampling algorithm. (Default: <strong>nearest</strong>) </br>\n<code>crop_to_geom</code> (_bool_): If True, the output raster is cropped to the extent of the clip geometry. (Default: <strong>True</strong>) </br>\n<code>all_touch</code> (_bool_): If True, all pixels touching the clipping geometry is included. (Default: <strong>False</strong>) </br>\n<code>adjust_bbox</code> (_bool_): If True, the bounding box of the output raster is adjusted to align with the clipping geometry. (Default: <strong>False</strong>) </br>\n<code>src_nodata</code> (_str_/_int_/_float_/_None_): The nodata value of the input raster. If not set, the nodata value of the input raster is used. (Default: <strong>infer</strong>) </br>\n<code>dst_nodata</code> (_str_/_int_/_float_/_None_): The nodata value of the output raster. If not set, the nodata value of the input raster is used. (Default: <strong>infer</strong>) </br>\n<code>layer_to_clip</code> (_int_): The layer to clip the raster to. (Default: <strong>0</strong>) </br>\n<code>prefix</code> (_str_): The prefix of the output raster. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix of the output raster. (Default: <strong>\"_resampled\"</strong>) </br>\n<code>add_uuid</code> (_bool_): If True, a unique identifier is added to the output raster. (Default: <strong>False</strong>) </br>\n<code>overwrite</code> (_bool_): If True, the output raster is overwritten if it already exists. (Default: <strong>True</strong>) </br>\n<code>creation_options</code> (_list_): The creation options of the output raster. (Default: <strong>None</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path to the warped output raster(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">raster</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_size</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">target_in_pixels</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">resample_alg</span><span class=\"o\">=</span><span class=\"s1\">&#39;nearest&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">crop_to_geom</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">all_touch</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">adjust_bbox</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">src_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dst_nodata</span><span class=\"o\">=</span><span class=\"s1\">&#39;infer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">layer_to_clip</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_resampled&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils", "modulename": "buteo.utils", "kind": "module", "doc": "<p>Various utility functions to work with the underlying systems.</p>\n"}, {"fullname": "buteo.utils.aux_utils", "modulename": "buteo.utils.aux_utils", "kind": "module", "doc": "<h3 id=\"generic-utility-functions\">Generic utility functions</h3>\n\n<p>Functions that make interacting with the toolbox easier.</p>\n"}, {"fullname": "buteo.utils.aux_utils.encode_latitude", "modulename": "buteo.utils.aux_utils", "qualname": "encode_latitude", "kind": "function", "doc": "<p>Latitude goes from -90 to 90</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lat</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.encode_longitude", "modulename": "buteo.utils.aux_utils", "qualname": "encode_longitude", "kind": "function", "doc": "<p>Longitude goes from -180 to 180</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.encode_latlng", "modulename": "buteo.utils.aux_utils", "qualname": "encode_latlng", "kind": "function", "doc": "<p>Encode latitude and longitude values to be used as input to the model.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.encode_latlngs", "modulename": "buteo.utils.aux_utils", "qualname": "encode_latlngs", "kind": "function", "doc": "<p>Encode multiple latitude and longitude values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">latlngs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.decode_latitude", "modulename": "buteo.utils.aux_utils", "qualname": "decode_latitude", "kind": "function", "doc": "<p>Decode encoded latitude values to the original latitude value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">encoded_sin</span>, </span><span class=\"param\"><span class=\"n\">encoded_cos</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.decode_longitude", "modulename": "buteo.utils.aux_utils", "qualname": "decode_longitude", "kind": "function", "doc": "<p>Decode encoded longitude values to the original longitude value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">encoded_sin</span>, </span><span class=\"param\"><span class=\"n\">encoded_cos</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.decode_latlng", "modulename": "buteo.utils.aux_utils", "qualname": "decode_latlng", "kind": "function", "doc": "<p>Decode encoded latitude and longitude values to the original values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">encoded_latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.decode_latlngs", "modulename": "buteo.utils.aux_utils", "qualname": "decode_latlngs", "kind": "function", "doc": "<p>Decode multiple latitude and longitude values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">encoded_latlngs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.encode_width", "modulename": "buteo.utils.aux_utils", "qualname": "encode_width", "kind": "function", "doc": "<p>Longitude goes from -180 to 180</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lng</span>, </span><span class=\"param\"><span class=\"n\">lng_max</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.encode_arr_position", "modulename": "buteo.utils.aux_utils", "qualname": "encode_arr_position", "kind": "function", "doc": "<p>Fast encoding of coordinates where the width is cyclical.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.channel_first_to_last", "modulename": "buteo.utils.aux_utils", "qualname": "channel_first_to_last", "kind": "function", "doc": "<p>Converts a numpy array from channel first to channel last format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.channel_last_to_first", "modulename": "buteo.utils.aux_utils", "qualname": "channel_last_to_first", "kind": "function", "doc": "<p>Converts a numpy array from channel last to channel first format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.scale_to_range", "modulename": "buteo.utils.aux_utils", "qualname": "scale_to_range", "kind": "function", "doc": "<p>Scales the values in the input array to the specified range.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">min_val</span>, </span><span class=\"param\"><span class=\"n\">max_val</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.create_grid", "modulename": "buteo.utils.aux_utils", "qualname": "create_grid", "kind": "function", "doc": "<p>Create a grid of rows and columns</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">range_rows</span>, </span><span class=\"param\"><span class=\"n\">range_cols</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.split_into_offsets", "modulename": "buteo.utils.aux_utils", "qualname": "split_into_offsets", "kind": "function", "doc": "<p>Split a shape into offsets. Usually used for splitting an image into offsets to reduce RAM needed.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">shape</span>, </span><span class=\"param\"><span class=\"n\">offsets_x</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">offsets_y</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">overlap_x</span><span class=\"o\">=</span><span class=\"mi\">0</span>, </span><span class=\"param\"><span class=\"n\">overlap_y</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.calculate_pixel_distances", "modulename": "buteo.utils.aux_utils", "qualname": "calculate_pixel_distances", "kind": "function", "doc": "<p>Calculate the distance from each pixel to the nearest target pixel.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">array</span>,</span><span class=\"param\">\t<span class=\"n\">target</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">maximum_distance</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_width</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_height</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.fill_nodata_with_nearest_average", "modulename": "buteo.utils.aux_utils", "qualname": "fill_nodata_with_nearest_average", "kind": "function", "doc": "<p>Calculate the distance from each pixel to the nearest target pixel.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array</span>, </span><span class=\"param\"><span class=\"n\">nodata_value</span>, </span><span class=\"param\"><span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">max_iterations</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">channel</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.single_hue_to_rgb", "modulename": "buteo.utils.aux_utils", "qualname": "single_hue_to_rgb", "kind": "function", "doc": "<p>Helper function to convert hue to RGB.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>p (float):</strong>  Intermediate value used for hue to RGB conversion.</li>\n<li><strong>q (float):</strong>  Intermediate value used for hue to RGB conversion.</li>\n<li><strong>t (float):</strong>  Hue value.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>float: RGB value.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">q</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.single_hsl_to_rgb", "modulename": "buteo.utils.aux_utils", "qualname": "single_hsl_to_rgb", "kind": "function", "doc": "<p>Convert a single HSL color to RGB.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>h (float):</strong>  Hue component.</li>\n<li><strong>s (float):</strong>  Saturation component.</li>\n<li><strong>l (float):</strong>  Lightness component.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>Tuple[float, float, float]: Tuple of RGB values (r, g, b).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">h</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"p\">:</span> <span class=\"nb\">float</span>, </span><span class=\"param\"><span class=\"n\">l</span><span class=\"p\">:</span> <span class=\"nb\">float</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.hsl_to_rgb", "modulename": "buteo.utils.aux_utils", "qualname": "hsl_to_rgb", "kind": "function", "doc": "<p>Convert an HSL array to an RGB array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>hsl_array (np.ndarray):</strong>  Input HSL array with shape (height, width, 3).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Output RGB array with shape (height, width, 3).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">hsl_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.aux_utils.rgb_to_hsl", "modulename": "buteo.utils.aux_utils", "qualname": "rgb_to_hsl", "kind": "function", "doc": "<p>Convert an RGB array to an HSL array.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>rgb_array (np.ndarray):</strong>  Input RGB array with shape (height, width, 3).</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>np.ndarray: Output HSL array with shape (height, width, 3).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">rgb_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils", "modulename": "buteo.utils.bbox_utils", "kind": "module", "doc": "<h3 id=\"bounding-box-utility-functions\">Bounding box utility functions</h3>\n\n<p>Various utility functions to work with bounding boxes and gdal.</p>\n\n<p>There are two different formats for bounding boxes used by GDAL:</br>\nOGR:  <code>[x_min, x_max, y_min, y_max]</code></br>\nWARP: <code>[x_min, y_min, x_max, y_max]</code></br></p>\n\n<p>_If nothing else is stated, the OGR format is used._</p>\n\n<p>The GDAL geotransform is a list of six parameters:</br>\n<code>x_min, pixel_width, row_skew, y_max, column_skew, pixel_height (negative for north-up)</code></p>\n"}, {"fullname": "buteo.utils.bbox_utils.is_valid_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "is_valid_bbox", "kind": "function", "doc": "<p>Checks if a bbox is valid.</p>\n\n<p>A valid ogr formatted bbox has the form: </br>\n<code>[x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bbox is valid, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.is_valid_bbox_latlng", "modulename": "buteo.utils.bbox_utils", "qualname": "is_valid_bbox_latlng", "kind": "function", "doc": "<p>Checks if a bbox is valid and latlng.</p>\n\n<p>A valid ogr formatted bbox has the form: </br>\n<code>[x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr_latlng</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bbox is valid, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr_latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.is_valid_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "is_valid_geotransform", "kind": "function", "doc": "<p>Checks if a geotransform is valid.</p>\n\n<p>A valid geotransform has the form: </br>\n<code>[x_min, pixel_width, row_skew, y_max, column_skew, pixel_height]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_/_tuple_): A GDAL formatted geotransform.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the geotransform is valid, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.ensure_negative", "modulename": "buteo.utils.bbox_utils", "qualname": "ensure_negative", "kind": "function", "doc": "<p>Ensures that a valid is negative. If the number is positive, it is made negative.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>number</code> (_int_/_float_): A float or int number. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_int_/_float_): The same number made <strong>negative</strong> if necesary.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">number</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_pixel_offsets", "modulename": "buteo.utils.bbox_utils", "qualname": "get_pixel_offsets", "kind": "function", "doc": "<p>Get the pixels offsets for a bbox and a geotransform.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_/_tuple_): A GDAL GeoTransform. </br>\n<code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A list of pixel offsets. <code>[x_start, y_start, x_size, y_size]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span>, </span><span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_geotransform", "kind": "function", "doc": "<p>Get an OGR bounding box from a geotransform and raster sizes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_/_tuple_): A GDAL GeoTransform. </br>\n<code>raster_x_size</code> (_int_): The number of pixels in the x direction. </br>\n<code>raster_y_size</code> (_int_): The number of pixels in the y direction. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span>, </span><span class=\"param\"><span class=\"n\">raster_x_size</span>, </span><span class=\"param\"><span class=\"n\">raster_y_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_raster", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_raster", "kind": "function", "doc": "<p>Gets an OGR bounding box from a GDAL raster dataframe.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_dataframe</code> (_gdal.DataFrame_): A GDAL raster dataframe. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_dataframe</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_vector", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_vector", "kind": "function", "doc": "<p>Gets an OGR bounding box from an OGR dataframe.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector_dataframe</code> (_ogr.DataSource_): An OGR vector dataframe. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector_dataframe</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_vector_layer", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_vector_layer", "kind": "function", "doc": "<p>Gets an OGR bounding box from an OGR dataframe layer.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector_layer</code> (_ogr.Layer_): An OGR vector dataframe layer. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector_layer</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_bbox_from_dataset", "modulename": "buteo.utils.bbox_utils", "qualname": "get_bbox_from_dataset", "kind": "function", "doc": "<p>Get the bbox from a dataset.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource): A dataset or dataset path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The bounding box in ogr format: [x_min, x_max, y_min, y_max].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_sub_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "get_sub_geotransform", "kind": "function", "doc": "<p>Create a GeoTransform and the raster sizes for an OGR formatted bbox.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geotransform</code> (_list_): A GDAL geotransform. </br>\n<code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_): { \"Transform\": _list_, \"RasterXSize\": _int_, \"RasterYSize\": _int_ }</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geotransform</span>, </span><span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_geom", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_geom", "kind": "function", "doc": "<p>Convert an OGR bounding box to ogr.Geometry.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; ogr.Geometry</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.Geometry_): An OGR geometry.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_geom_to_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_geom_to_bbox", "kind": "function", "doc": "<p>Convert an ogr.Geometry to an OGR bounding box.</br>\n<code>ogr.Geometry -&gt; [x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geom</code> (_ogr.Geometry_): An OGR geometry. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geom</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_geotransform", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_geotransform", "kind": "function", "doc": "<p>Convert an OGR formatted bounding box to a GDAL GeoTransform.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; [x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>raster_x_size</code> (_int_): The number of pixels in the x direction. </br>\n<code>raster_y_size</code> (_int_): The number of pixels in the y direction. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A GDAL GeoTransform. <code>[x_min, pixel_width, x_skew, y_max, y_skew, pixel_height]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">raster_x_size</span>, </span><span class=\"param\"><span class=\"n\">raster_y_size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_ogr_bbox_to_gdal_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_ogr_bbox_to_gdal_bbox", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to a GDAL formatted one.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; [x_min, y_min, x_max, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A GDAL formatted bbox. <code>[x_min, y_min, x_max, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_gdal_bbox_to_ogr_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_gdal_bbox_to_ogr_bbox", "kind": "function", "doc": "<p>Converts a GDAL formatted bbox to an OGR formatted one.</br>\n<code>[x_min, y_min, x_max, y_max] -&gt; [x_min, x_max, y_min, y_max]</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_gdal</code> (_list_): A GDAL formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_gdal</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_wkt", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_wkt", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to a WKT string.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; WKT</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): A WKT Polygon string. <code>POLYGON ((...))</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_geojson", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_geojson", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to a GeoJson dictionary.</br>\n<code>[x_min, x_max, y_min, y_max] -&gt; GeoJson</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): an OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_): A GeoJson Dictionary. <code>{ \"type\": \"Polygon\", \"coordinates\": [ ... ] }</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.convert_bbox_to_vector", "modulename": "buteo.utils.bbox_utils", "qualname": "convert_bbox_to_vector", "kind": "function", "doc": "<p>Converts an OGR formatted bbox to an in-memory vector.</br>\n_Vectors are stored in /vsimem/ as .gpkg files._</br>\n<strong>OBS</strong>: Layers should be manually cleared when no longer used.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): an OGR formatted bbox. </br>\n<code>projection_osr</code> (_osr.SpatialReference_): The projection of the vector. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.DataSource_): The bounding box as a vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">projection_osr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.bboxes_intersect", "modulename": "buteo.utils.bbox_utils", "qualname": "bboxes_intersect", "kind": "function", "doc": "<p>Checks if two OGR formatted bboxes intersect.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bboxes intersect, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.bboxes_within", "modulename": "buteo.utils.bbox_utils", "qualname": "bboxes_within", "kind": "function", "doc": "<p>Checks if one OGR formatted bbox is within another.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the bbox is within the other, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_intersection_bboxes", "modulename": "buteo.utils.bbox_utils", "qualname": "get_intersection_bboxes", "kind": "function", "doc": "<p>Get the intersection of two OGR formatted bboxes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox of the intersection. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_union_bboxes", "modulename": "buteo.utils.bbox_utils", "qualname": "get_union_bboxes", "kind": "function", "doc": "<p>Get the union of two OGR formatted bboxes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox of the union. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_projection_from_raster", "modulename": "buteo.utils.bbox_utils", "qualname": "get_projection_from_raster", "kind": "function", "doc": "<p>Get the projection from a raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_str_/_gdal.Dataset_): A raster or raster path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The projection in OSR format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_projection_from_vector", "modulename": "buteo.utils.bbox_utils", "qualname": "get_projection_from_vector", "kind": "function", "doc": "<p>Get the projection from a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_gdal.Dataset_): A vector or vector path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The projection in OSR format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_projection_from_dataset", "modulename": "buteo.utils.bbox_utils", "qualname": "get_projection_from_dataset", "kind": "function", "doc": "<p>Get the projection from a dataset.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource): A dataset or dataset path. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The projection in OSR format.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.align_bboxes_to_pixel_size", "modulename": "buteo.utils.bbox_utils", "qualname": "align_bboxes_to_pixel_size", "kind": "function", "doc": "<p>Aligns two OGR formatted bboxes to a pixel size. Output is an augmented version\nof bbox2.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox1_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>bbox2_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>pixel_width</code> (_float_/_int_): The width of the pixel. </br>\n<code>pixel_height</code> (_float_/_int_): The height of the pixel. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted bbox of the alignment. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox1_ogr</span>, </span><span class=\"param\"><span class=\"n\">bbox2_ogr</span>, </span><span class=\"param\"><span class=\"n\">pixel_width</span>, </span><span class=\"param\"><span class=\"n\">pixel_height</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.reproject_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "reproject_bbox", "kind": "function", "doc": "<p>Reprojects an OGR formatted bbox.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>source_projection_osr</code> (_osr.SpatialReference_): The source projection. </br>\n<code>target_projection_osr</code> (_osr.SpatialReference_): The target projection. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): An OGR formatted reprojected bbox. <code>[x_min, x_max, y_min, y_max]</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">source_projection</span>, </span><span class=\"param\"><span class=\"n\">target_projection</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_latlng", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_latlng", "kind": "function", "doc": "<p>Get the UTM ZONE from a latlng list.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The UTM zone projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">latlng</span>, </span><span class=\"param\"><span class=\"n\">return_epsg</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_bbox", "kind": "function", "doc": "<p>Get the UTM zone from an OGR formatted bbox.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_osr.SpatialReference_): The UTM zone projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr_latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_dataset", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_dataset", "kind": "function", "doc": "<p>Get the UTM zone from a GDAL dataset.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_obj_): A GDAL dataset. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The UTM zone.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.get_utm_zone_from_dataset_list", "modulename": "buteo.utils.bbox_utils", "qualname": "get_utm_zone_from_dataset_list", "kind": "function", "doc": "<p>Get the UTM zone from a list of GDAL datasets.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>datasets</code> (_list_): A list of GDAL datasets. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The UTM zone.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">datasets</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.reproject_latlng_point_to_utm", "modulename": "buteo.utils.bbox_utils", "qualname": "reproject_latlng_point_to_utm", "kind": "function", "doc": "<p>Converts a latlng point into an UTM point.</p>\n\n<p>Takes point in [lat, lng], returns [utm_x, utm_y].</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">latlng</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.geometry_latlng_from_bbox", "modulename": "buteo.utils.bbox_utils", "qualname": "geometry_latlng_from_bbox", "kind": "function", "doc": "<p>This is an internal utility function for metadata generation. It takes a standard\nOGR bounding box and the geometry of the source dataset in latlng and returns a\ngeometry in the source dataset's projection. This is important as, as when \nreprojecting to latlng, you might get a skewed bounding box. This function returns\nthe skewed bounds in latlng, which is what you want for overlap checks across\nprojections.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>projection_osr</code> (_osr.SpatialReference_): The projection. </br>\n<code>latlng_projection</code> (_osr.SpatialReference_): The latlng projection. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.Geometry_): The geometry in the source dataset's projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">projection_osr</span>, </span><span class=\"param\"><span class=\"n\">latlng_projection_osr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.bbox_utils.additional_bboxes", "modulename": "buteo.utils.bbox_utils", "qualname": "additional_bboxes", "kind": "function", "doc": "<p>This is an internal utility function for metadata generation. It takes a standard\nOGR bounding box and returns a list of variations of bounding boxes.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>bbox_ogr</code> (_list_): An OGR formatted bbox. </br>\n<code>projection_osr</code> (_osr.SpatialReference_): The projection. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_): A dictionary of the added bboxes. Contains the following keys: </br>\n<code>bbox_latlng</code>: The bbox in latlng coordinates. </br>\n<code>bbox_wkt</code>: The bbox in WKT format. </br>\n<code>bbox_wkt_latlng</code>: The bbox in WKT format in latlng coordinates. </br>\n<code>bbox_geom</code>: The bbox in ogr.Geometry format. </br>\n<code>bbox_geom_latlng</code>: The bbox in ogr.Geometry format in latlng coordinates. </br>\n<code>bbox_gdal</code>: The bbox in GDAL format. </br>\n<code>bbox_gdal_latlng</code>: The bbox in GDAL format in latlng coordinates. </br>\n<code>bbox_dict</code>: The bbox in a dictionary format. { \"x_min\": x_min, ... } </br>\n<code>bbox_dict_latlng</code>: The bbox in a dictionary format in latlng coordinates. </br></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">bbox_ogr</span>, </span><span class=\"param\"><span class=\"n\">projection_osr</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils", "modulename": "buteo.utils.core_utils", "kind": "module", "doc": "<h3 id=\"generic-utility-functions\">Generic utility functions</h3>\n\n<p>Functions that make interacting with the toolbox easier.</p>\n"}, {"fullname": "buteo.utils.core_utils.get_unix_seconds_as_str", "modulename": "buteo.utils.core_utils", "qualname": "get_unix_seconds_as_str", "kind": "function", "doc": "<p>Get a string of the current UNIX time in seconds.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: A string of the current UNIX time in seconds.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_float", "modulename": "buteo.utils.core_utils", "qualname": "is_float", "kind": "function", "doc": "<p>Check if a value is a float. If it is a string, try to convert it to a float.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>value (any):</strong>  The value to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the value is a float, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_number", "modulename": "buteo.utils.core_utils", "qualname": "is_number", "kind": "function", "doc": "<p>Check if variable is a number.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>potential_number (any):</strong>  The variable to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the variable is a number, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_number</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_int", "modulename": "buteo.utils.core_utils", "qualname": "is_int", "kind": "function", "doc": "<p>Check if a value is an integer. If it is a string, try to convert it to an integer.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>value (any):</strong>  The value to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the variable is an int, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_list_all_the_same", "modulename": "buteo.utils.core_utils", "qualname": "is_list_all_the_same", "kind": "function", "doc": "<p>Check if a list contains all the same elements.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>lst (list):</strong>  The list to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the list contains all the same elements, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lst</span><span class=\"p\">:</span> <span class=\"nb\">list</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.file_exists", "modulename": "buteo.utils.core_utils", "qualname": "file_exists", "kind": "function", "doc": "<p>Check if a file exists. Also checks vsimem.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the file exists, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.folder_exists", "modulename": "buteo.utils.core_utils", "qualname": "folder_exists", "kind": "function", "doc": "<p>Check if a folder exists.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the folder.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the folder exists, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.delete_files_in_folder", "modulename": "buteo.utils.core_utils", "qualname": "delete_files_in_folder", "kind": "function", "doc": "<p>Delete all files in a folder. Does not remove subfolders.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>folder (str):</strong>  The path to the folder.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the files were deleted, raises warning otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.delete_folder", "modulename": "buteo.utils.core_utils", "qualname": "delete_folder", "kind": "function", "doc": "<p>Delete a folder.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>folder (str):</strong>  The path to the folder.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the folder was deleted, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.delete_file", "modulename": "buteo.utils.core_utils", "qualname": "delete_file", "kind": "function", "doc": "<p>Delete a File</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>file (str):</strong>  The path to the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the file was deleted, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.to_number", "modulename": "buteo.utils.core_utils", "qualname": "to_number", "kind": "function", "doc": "<p>Attempts to convert a variable to a number.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>variable (any):</strong>  The value to convert.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>(float): The value converted to a number.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variable</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.make_dir_if_not_exists", "modulename": "buteo.utils.core_utils", "qualname": "make_dir_if_not_exists", "kind": "function", "doc": "<p>Make a directory if it doesn't exist.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the directory.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>(str): The path to the created directory.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.path_to_ext", "modulename": "buteo.utils.core_utils", "qualname": "path_to_ext", "kind": "function", "doc": "<p>Get the extension of a file. If the file has no extension, raise an error.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n</ul>\n\n<h6 id=\"kwargs\">Kwargs:</h6>\n\n<blockquote>\n  <p>with_dot (bool = False): If True, return the extension with a dot.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The extension of the file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">with_dot</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.path_to_folder", "modulename": "buteo.utils.core_utils", "qualname": "path_to_folder", "kind": "function", "doc": "<p>Get the folder of a file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The folder of the file.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.change_path_ext", "modulename": "buteo.utils.core_utils", "qualname": "change_path_ext", "kind": "function", "doc": "<p>Change the extension of a file.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n<li><strong>target_ext (str):</strong>  The new extension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The path to the file with the new extension.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">target_ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_mem_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_mem_path", "kind": "function", "doc": "<p>Check if a path is a valid memory path that has an extension. vsizip also works.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to test.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if path is a valid memory path, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_non_memory_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_non_memory_path", "kind": "function", "doc": "<p>Check if a path is valid, not in memory, and has an extension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the path has an extension, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_file_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_file_path", "kind": "function", "doc": "<p>Check if a path is valid and has an extension. Path can be in memory.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the path has an extension, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_output_path", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_output_path", "kind": "function", "doc": "<p>Check if an output path is valid.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>overwrite (bool = True): True if the file should be overwritten, False otherwise.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the output path is valid, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_valid_output_path_list", "modulename": "buteo.utils.core_utils", "qualname": "is_valid_output_path_list", "kind": "function", "doc": "<p>Check if a list of output paths are valid.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>output_list (list):</strong>  The list of paths to the files.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>overwrite (bool = True): True if the file should be overwritten, False otherwise.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the list of output paths are valid, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">output_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.remove_if_required", "modulename": "buteo.utils.core_utils", "qualname": "remove_if_required", "kind": "function", "doc": "<p>Remove a file if overwrite is True.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the file.</li>\n<li><strong>overwrite (bool = True):</strong>  If True, overwrite the file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the file was removed, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.remove_if_required_list", "modulename": "buteo.utils.core_utils", "qualname": "remove_if_required_list", "kind": "function", "doc": "<p>Remove a list of files if overwrite is True.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>output_list (list):</strong>  The list of paths to the files.</li>\n<li><strong>overwrite (bool):</strong>  If True, overwrite the files.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the files were removed, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">output_list</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">overwrite</span><span class=\"p\">:</span> <span class=\"nb\">bool</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.get_augmented_path", "modulename": "buteo.utils.core_utils", "qualname": "get_augmented_path", "kind": "function", "doc": "<p>Gets a basename from a string in the format:\n<code>dir/prefix_basename_time_uuid_suffix.ext</code></p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>path (str):</strong>  The path to the original file.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>prefix (str = \"\"): The prefix to add to the memory path.\n  suffix (str = \"\"): The suffix to add to the memory path.\n  add_uuid (bool = True): If True, add a uuid to the memory path.\n  folder (str = None): The folder to save the file in.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: A string of the current UNIX time in seconds.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path</span><span class=\"p\">:</span> <span class=\"nb\">str</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">folder</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.get_size", "modulename": "buteo.utils.core_utils", "qualname": "get_size", "kind": "function", "doc": "<p>Get the size of a folder.</p>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>start_path (str = \".\"): The path to the folder.\n  rough (bool = True): If True, return a rough estimate.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: The size of the folder.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start_path</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;.&#39;</span>, </span><span class=\"param\"><span class=\"n\">rough</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.divide_into_steps", "modulename": "buteo.utils.core_utils", "qualname": "divide_into_steps", "kind": "function", "doc": "<p>Divide a number into steps.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>total int:</strong>  The total number.</li>\n<li><strong>step int:</strong>  The step size.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: The list of steps.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">step</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.divide_arr_into_steps", "modulename": "buteo.utils.core_utils", "qualname": "divide_arr_into_steps", "kind": "function", "doc": "<p>Divide an array into steps.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (list):</strong>  The array.</li>\n<li><strong>steps_length (int):</strong>  The length of each step.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: An array divided into steps.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">steps_length</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.step_ranges", "modulename": "buteo.utils.core_utils", "qualname": "step_ranges", "kind": "function", "doc": "<p>Get the ranges of each step.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr_with_steps (list):</strong>  The array with steps.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: A list of dictionaries of type: { \"id\": int, \"start\": int, \"stop\": int}.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr_with_steps</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.recursive_check_type_list_none_or_tuple", "modulename": "buteo.utils.core_utils", "qualname": "recursive_check_type_list_none_or_tuple", "kind": "function", "doc": "<p>Recursively check if a type, list or tuple.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>potential_type (any):</strong>  The variable to test.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if a type, list, or tuple, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_type</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.type_check", "modulename": "buteo.utils.core_utils", "qualname": "type_check", "kind": "function", "doc": "<p>Utility function to type check the inputs of a function. Check two levels down.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>variable (any):</strong>  The variable to check.</li>\n<li><strong>types (tuple):</strong>  The types to check against. (float, int, ...)</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>name (str = \"\"): The name printed in the error string if an error is thrown.\n  throw_error (bool = True): If True, raise an error if the type is not correct.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: A boolean indicating if the type is valid. If throw_error an error is raised if the input is not a valid type.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">variable</span><span class=\"p\">:</span> <span class=\"n\">Any</span>,</span><span class=\"param\">\t<span class=\"n\">types</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">type</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">throw_error</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_list_all_val", "modulename": "buteo.utils.core_utils", "qualname": "is_list_all_val", "kind": "function", "doc": "<p>Check if a list is all a value. This also considers type.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>arr (list):</strong>  The list to check.</li>\n<li><strong>val (any):</strong>  The value to check against.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if all elements are x, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">arr</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">val</span><span class=\"p\">:</span> <span class=\"n\">Any</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.progress", "modulename": "buteo.utils.core_utils", "qualname": "progress", "kind": "function", "doc": "<p>Print a progress bar.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>count (int):</strong>  The current count.</li>\n<li><strong>total (int):</strong>  The total count.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>name (str = \"Processing\"): The name to show in the progress bar. Default: \"Processing\".</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">count</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">total</span><span class=\"p\">:</span> <span class=\"nb\">int</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Processing&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.timing", "modulename": "buteo.utils.core_utils", "qualname": "timing", "kind": "function", "doc": "<p>Get the time elapsed since the given time.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>before (datetime):</strong>  The time to compare.</li>\n</ul>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>print_msg (bool = True): If True, print the time elapsed.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>None.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">before</span><span class=\"p\">:</span> <span class=\"n\">datetime</span><span class=\"o\">.</span><span class=\"n\">datetime</span>, </span><span class=\"param\"><span class=\"n\">print_msg</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"kc\">None</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.get_dynamic_memory_limit_bytes", "modulename": "buteo.utils.core_utils", "qualname": "get_dynamic_memory_limit_bytes", "kind": "function", "doc": "<p>Returns a dynamic memory limit taking into account total memory and CPU cores.</p>\n\n<h6 id=\"keyword-args\">Keyword Args:</h6>\n\n<blockquote>\n  <p>percentage (float = 80.0): The percentage of the total memory to use.\n  min_bytes (int = 1000000): The minimum number of bytes to be returned.\n  available (bool = True): If True, consider available memory instead of total memory.</p>\n</blockquote>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: The dynamic memory limit in bytes.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">percentage</span><span class=\"p\">:</span> <span class=\"nb\">float</span> <span class=\"o\">=</span> <span class=\"mf\">80.0</span>,</span><span class=\"param\">\t<span class=\"n\">min_bytes</span><span class=\"p\">:</span> <span class=\"nb\">int</span> <span class=\"o\">=</span> <span class=\"mi\">1000000</span>,</span><span class=\"param\">\t<span class=\"n\">available</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.is_str_a_glob", "modulename": "buteo.utils.core_utils", "qualname": "is_str_a_glob", "kind": "function", "doc": "<p>Check if a string is a glob.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>test_str (str):</strong>  The string to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the string is a glob, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">test_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.parse_glob_path", "modulename": "buteo.utils.core_utils", "qualname": "parse_glob_path", "kind": "function", "doc": "<p>Parses a string containing a glob path.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>test_str (str):</strong>  The string to parse the pattern from.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: A list of the matching paths.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">test_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.ensure_list", "modulename": "buteo.utils.core_utils", "qualname": "ensure_list", "kind": "function", "doc": "<p>Ensure that a variable is a list.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>variable_or_list (any):</strong>  The variable to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: The variable as a list.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">variable_or_list</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">List</span><span class=\"p\">,</span> <span class=\"n\">Any</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Any</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.core_utils.all_arrays_are_same_size", "modulename": "buteo.utils.core_utils", "qualname": "all_arrays_are_same_size", "kind": "function", "doc": "<p>Check if all arrays in a list are the same size.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>list_of_arrays (list):</strong>  The list of numpy arrays to check.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if all arrays are the same size, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_of_arrays</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums", "modulename": "buteo.utils.gdal_enums", "kind": "module", "doc": "<h3 id=\"gdal-enum-functions\">GDAL Enum Functions</h3>\n\n<p>Functions to translate between <strong>GDAL</strong> and <strong>NumPy</strong> datatypes.</p>\n"}, {"fullname": "buteo.utils.gdal_enums.get_available_drivers", "modulename": "buteo.utils.gdal_enums", "qualname": "get_available_drivers", "kind": "function", "doc": "<p>Returns a list of all available drivers.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>List[Dict[str, str]]: List of dicts containing available drivers. Each dict has the following keys:\n      - 'short_name' (str): Driver short name (e.g. GTiff).\n      - 'long_name' (str): Driver long name (e.g. GeoTiff).\n      - 'extension' (str): Driver file extension (e.g. tif). Note: Can be an empty string.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"n\">Dict</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_valid_raster_driver_extensions", "modulename": "buteo.utils.gdal_enums", "qualname": "get_valid_raster_driver_extensions", "kind": "function", "doc": "<p>Returns a list of valid raster driver extensions.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: List of valid raster driver extensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_valid_vector_driver_extensions", "modulename": "buteo.utils.gdal_enums", "qualname": "get_valid_vector_driver_extensions", "kind": "function", "doc": "<p>Returns a list of valid vector driver extensions.</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: List of valid vector driver extensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_valid_driver_extensions", "modulename": "buteo.utils.gdal_enums", "qualname": "get_valid_driver_extensions", "kind": "function", "doc": "<p>Returns a list of all valid driver extensions (<strong>GDAL</strong> + <strong>OGR</strong>).</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>list: List of all valid driver extensions.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">) -> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_valid_driver_extension", "modulename": "buteo.utils.gdal_enums", "qualname": "is_valid_driver_extension", "kind": "function", "doc": "<p>Checks if a file extension is a valid GDAL or OGR driver extension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ext (str):</strong>  The file extension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if valid, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_valid_raster_driver_extension", "modulename": "buteo.utils.gdal_enums", "qualname": "is_valid_raster_driver_extension", "kind": "function", "doc": "<p>Checks if a raster file extension is a valid GDAL driver extension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ext (str):</strong>  The file extension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if valid, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_valid_vector_driver_extension", "modulename": "buteo.utils.gdal_enums", "qualname": "is_valid_vector_driver_extension", "kind": "function", "doc": "<p>Checks if a vector file extension is a valid <strong>OGR</strong> driver extension.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ext (str):</strong>  The file extension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if valid, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.convert_raster_extension_to_driver_shortname", "modulename": "buteo.utils.gdal_enums", "qualname": "convert_raster_extension_to_driver_shortname", "kind": "function", "doc": "<p>Converts a raster file extension to a GDAL driver short name.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ext (str):</strong>  The file extension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The GDAL driver short name (e.g. \"GTiff\").</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.convert_extension_to_driver_shortname", "modulename": "buteo.utils.gdal_enums", "qualname": "convert_extension_to_driver_shortname", "kind": "function", "doc": "<p>Converts a file extension to a driver short name for either OGR or GDAL.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ext (str):</strong>  The file extension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The driver short name (e.g. GPKG or GTiff).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.convert_vector_extension_to_driver_shortname", "modulename": "buteo.utils.gdal_enums", "qualname": "convert_vector_extension_to_driver_shortname", "kind": "function", "doc": "<p>Converts a vector file extension to an <strong>OGR</strong> driver short_name name.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>ext (str):</strong>  The file extension.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The driver short_name (e.g. GPKG).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ext</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.translate_resample_method", "modulename": "buteo.utils.gdal_enums", "qualname": "translate_resample_method", "kind": "function", "doc": "<p>Translate a string of a resampling method to a GDAL integer (e.g. gdal.GRA_NearestNeighbour).</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>method (str):</strong>  The resampling method.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>int: The GDAL resampling integer (e.g. \"nearest\"=1).</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">method</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.translate_gdal_dtype_to_str", "modulename": "buteo.utils.gdal_enums", "qualname": "translate_gdal_dtype_to_str", "kind": "function", "doc": "<p>Translates the <strong>GDAL</strong> datatype integer into a string. Can be used by <strong>NumPy</strong>.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>gdal_datatype_int (int):</strong>  The <strong>GDAL</strong> datatype integer.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>str: The translated string (e.g. <code>0=\"uint8\"</code>)</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gdal_datatype_int</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">str</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.translate_str_to_gdal_dtype", "modulename": "buteo.utils.gdal_enums", "qualname": "translate_str_to_gdal_dtype", "kind": "function", "doc": "<p>Translates the datatype string into a <strong>GDAL</strong> datatype integer. Can be used by <strong>GDAL</strong>.</p>\n\n<p>Args:</p>\n\n<ul>\n<li>dtype_str (str): The datatype string (e.g. \"float32\").</li>\n</ul>\n\n<p>Returns:</p>\n\n<ul>\n<li>int: The <strong>GDAL</strong> datatype integer corresponding to the input datatype string (e.g. <code>\"uint8\"=1</code>).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype_str</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">int</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_default_nodata_value", "modulename": "buteo.utils.gdal_enums", "qualname": "get_default_nodata_value", "kind": "function", "doc": "<p>Returns the default fill value for masked numpy arrays.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>dtype:</strong>  The data type of the array, can be either a numpy dtype object, a string representing a\ndata type (e.g. 'float32') or an integer representing a numpy data type (e.g. 5 for 'float32').</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>The default fill value for the given data type.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.get_range_for_numpy_datatype", "modulename": "buteo.utils.gdal_enums", "qualname": "get_range_for_numpy_datatype", "kind": "function", "doc": "<p>Returns the range of values that can be represented by a given numpy dtype.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>numpy_dtype (str/np.dtype):</strong>  The numpy dtype.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>tuple: (min_value, max_value) that can be represented by the numpy dtype.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">numpy_dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]]</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.value_is_within_datatype_range", "modulename": "buteo.utils.gdal_enums", "qualname": "value_is_within_datatype_range", "kind": "function", "doc": "<p>Checks if a value is within the range of a numpy datatype.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>value (int/float):</strong>  The value to check.</li>\n<li><strong>numpy_dtype (str/np.dtype):</strong>  The numpy dtype.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the value is within the range of the numpy dtype, False otherwise.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>, </span><span class=\"param\"><span class=\"n\">numpy_dtype</span><span class=\"p\">:</span> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">dtype</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_enums.is_gdal_datatype_a_float", "modulename": "buteo.utils.gdal_enums", "qualname": "is_gdal_datatype_a_float", "kind": "function", "doc": "<p>Checks if a GDAL datatype integer is a floating-point datatype:\n(Float32, Float64, cFloat32, cFloat64)</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>gdal_dtype (int):</strong>  The GDAL datatype integer.</li>\n</ul>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>bool: True if the datatype is a float, otherwise False.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gdal_dtype</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">bool</span>:</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils", "modulename": "buteo.utils.gdal_utils", "kind": "module", "doc": "<h3 id=\"utility-functions-to-work-with-gdal\">Utility functions to work with GDAL</h3>\n\n<p>These functions are used to interact with basic GDAL objects.</p>\n\n<h6 id=\"todo\">TODO:</h6>\n\n<blockquote>\n  <ul>\n  <li>Should file_path_lists be able to handle mixed inputs?</li>\n  <li>Make delete_raster_or_vector and the like accept a list of file paths?</li>\n  </ul>\n</blockquote>\n"}, {"fullname": "buteo.utils.gdal_utils.default_creation_options", "modulename": "buteo.utils.gdal_utils", "qualname": "default_creation_options", "kind": "function", "doc": "<p>Takes a list of GDAL creation options and adds the following defaults to it if their not specified: </br></p>\n\n<ul>\n<li><code>\"TILED=YES\"</code></li>\n<li><code>\"NUM_THREADS=ALL_CPUS\"</code></li>\n<li><code>\"BIGG_TIF=YES\"</code></li>\n<li><code>\"COMPRESS=LZW\"</code></li>\n</ul>\n\n<p>If any of the options are already specified, they are not added.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>options</code> (_list_/None): The GDAL creation options to add to. (Default: <strong>None</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A list containing the default values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">options</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_default_projection", "modulename": "buteo.utils.gdal_utils", "qualname": "get_default_projection", "kind": "function", "doc": "<p>Get the default projection for a new raster.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The default projection.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_valid_datatype", "modulename": "buteo.utils.gdal_utils", "qualname": "is_valid_datatype", "kind": "function", "doc": "<p>Check if a file path has a valid GDAL or OGR driver.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file path is a valid GDAL or OGR driver, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_valid_raster_datatype", "modulename": "buteo.utils.gdal_utils", "qualname": "is_valid_raster_datatype", "kind": "function", "doc": "<p>Check if a file path has a valid GDAL driver.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file path is a valid GDAL Raster driver, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_valid_vector_datatype", "modulename": "buteo.utils.gdal_utils", "qualname": "is_valid_vector_datatype", "kind": "function", "doc": "<p>Check if a file path has a valid OGR driver.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file path is a valid OGR Vector driver, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.path_to_driver", "modulename": "buteo.utils.gdal_utils", "qualname": "path_to_driver", "kind": "function", "doc": "<p>Convert a file path to a GDAL or OGR driver ShortName (e.g. \"GTiff\" for \"new_york.tif\")</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to convert.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The GDAL or OGR driver ShortName.</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p><code>ValueError</code>: If the file path is not a valid GDAL or OGR driver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.path_to_driver_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "path_to_driver_vector", "kind": "function", "doc": "<p>Convert a file path to an OGR driver ShortName (e.g. \"FlatGeoBuf\" for \"new_york.fgb\")</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to convert.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The OGR driver ShortName.</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p><code>ValueError</code>: If the file path is not a valid OGR driver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.path_to_driver_raster", "modulename": "buteo.utils.gdal_utils", "qualname": "path_to_driver_raster", "kind": "function", "doc": "<p>Convert a file path to a GDAL driver ShortName (e.g. \"GTiff\" for \"new_york.tif\")</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>file_path</code> (_str_): The file path to convert.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): The GDAL driver ShortName.</p>\n\n<h2 id=\"raises\">Raises:</h2>\n\n<p><code>ValueError</code>: If the file path is not a valid GDAL driver.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_path</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_gdal_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "get_gdal_memory", "kind": "function", "doc": "<p>Get at list of all active memory layers in GDAL.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_in_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "is_in_memory", "kind": "function", "doc": "<p>Check if vector is in memory</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_or_vector</code> (_str_/_gdal.Dataset_/ogr.DataSource): The vector or raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the vector is in memory, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_or_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.delete_if_in_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "delete_if_in_memory", "kind": "function", "doc": "<p>Delete raster or vector if it is in memory</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_or_vector</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The vector or raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the vector is deleted, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_or_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.delete_if_in_memory_list", "modulename": "buteo.utils.gdal_utils", "qualname": "delete_if_in_memory_list", "kind": "function", "doc": "<p>Deletes a list of raster or vector if they are in memory</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>list_of_raster_or_vectors</code> (_list_): The vector(s) or raster(s) to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if they were all deleted, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_of_raster_or_vectors</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.delete_raster_or_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "delete_raster_or_vector", "kind": "function", "doc": "<p>Delete raster or vector. Can be used on both in memory and on disk.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster_or_vector</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The vector or raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the file is deleted, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster_or_vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_empty", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_empty", "kind": "function", "doc": "<p>Check if a raster has bands or zero width and zero height.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>raster</code> (_gdal.Dataset_): The raster to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the raster has bands, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">raster</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_vector_empty", "modulename": "buteo.utils.gdal_utils", "qualname": "is_vector_empty", "kind": "function", "doc": "<p>Check if a vector has features with geometries</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_ogr.DataSource_): The vector to check.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the vector has features, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster", "kind": "function", "doc": "<p>Checks if a variable is a valid raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster is considered invalid. (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the variable is a valid raster, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of rasters.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster_list</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster_list</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_path_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_path_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_path_list</span>, </span><span class=\"param\"><span class=\"n\">allow_none</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "is_vector", "kind": "function", "doc": "<p>Checks if a variable is a valid vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_vector</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty vector is considered invalid. (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the variable is a valid vector, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_vector</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_vector_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_vector_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of vectors.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_vector_list</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty vector is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_vector_list</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_or_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_or_vector", "kind": "function", "doc": "<p>Checks if a variable is a valid raster or vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster_or_vector</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster or vector is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster_or_vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.is_raster_or_vector_list", "modulename": "buteo.utils.gdal_utils", "qualname": "is_raster_or_vector_list", "kind": "function", "doc": "<p>Checks if a variable is a valid list of rasters or vectors.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>potential_raster_or_vector_list</code> (_any_): The variable to check.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>empty_is_invalid</code> (_bool_): If <strong>True</strong>, an empty raster or vector is considered invalid. (Default: <strong>True</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">potential_raster_or_vector_list</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">empty_is_invalid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.clear_gdal_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "clear_gdal_memory", "kind": "function", "doc": "<p>Clears all gdal memory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.gdal_print_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "gdal_print_memory", "kind": "function", "doc": "<p>Prints all gdal memory.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.create_memory_path", "modulename": "buteo.utils.gdal_utils", "qualname": "create_memory_path", "kind": "function", "doc": "<p>Gets a memory path from a string in the format: </br>\n<code>/vsimem/prefix_basename_time_uuid_suffix.ext</code></p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>path</code> (_str_): The path to the original file. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>prefix</code> (_str_): The prefix to add to the memory path. (<strong>Default</strong>: <code>\"\"</code>) </br>\n<code>suffix</code> (_str_): The suffix to add to the memory path. (<strong>Default</strong>: <code>\"\"</code>) </br>\n<code>add_uuid</code> (_bool_): If True, add a uuid to the memory path. (<strong>Default</strong>: <code>True</code>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): A string to the memory path. <code>/vsimem/prefix_basename_time_uuid_suffix.ext</code></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_path_from_dataset", "modulename": "buteo.utils.gdal_utils", "qualname": "get_path_from_dataset", "kind": "function", "doc": "<p>Gets the path from a datasets. Can be vector or raster, string or opened.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource_): The dataset.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>dataset_type</code> (_str_): The type of dataset. If not specified, it is guessed. (<strong>Default</strong>: <code>None</code>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The path to the dataset.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">dataset</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">dataset_type</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_path_from_dataset_list", "modulename": "buteo.utils.gdal_utils", "qualname": "get_path_from_dataset_list", "kind": "function", "doc": "<p>Gets the paths from a list of datasets.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>datasets</code> (_list_): The list of datasets.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>allow_mixed</code> (_bool_): If True, allow mixed raster/vector datasets. (<strong>Default</strong>: <code>False</code>) </br>\n<code>dataset_type</code> (_str_/_None_): The type of dataset. If not specified, it is guessed. (<strong>Default</strong>: <code>None</code>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): A list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">datasets</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">allow_mixed</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">dataset_type</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.convert_geom_to_vector", "modulename": "buteo.utils.gdal_utils", "qualname": "convert_geom_to_vector", "kind": "function", "doc": "<p>Converts a geometry to a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>geom</code> (_ogr.Geometry_): The geometry to convert.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>layer_name</code> (_str_): The name of the layer. (Default: <strong>\"geom\"</strong>)\n<code>add_uuid</code> (_bool_): If <strong>True</strong>, a UUID will be added to the layer. (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.DataSource_): The vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">geom</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.import_esri_projection", "modulename": "buteo.utils.gdal_utils", "qualname": "import_esri_projection", "kind": "function", "doc": "<p>Imports a projection from an ESRI code.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">esri_code</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.parse_projection", "modulename": "buteo.utils.gdal_utils", "qualname": "parse_projection", "kind": "function", "doc": "<p>Parses a gdal, ogr og osr data source and extraction the projection. If\na string or int is passed, it attempts to open it and return the projection as\nan osr.SpatialReference.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>projection</code> (_str_/_int_/_gdal.Dataset_/_ogr.DataSource_/_osr.SpatialReference_): The projection to parse.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>return_wkt</code> (_bool_): If <strong>True</strong> the projection will be returned as a WKT string, otherwise an osr.SpatialReference is returned. (Default: <strong>False</strong>)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">projection</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">return_wkt</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.projections_match", "modulename": "buteo.utils.gdal_utils", "qualname": "projections_match", "kind": "function", "doc": "<p>Tests if two projection sources have the same projection.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>source1</code> (_str_/_int_/_gdal.Dataset_/_ogr.DataSource_/_osr.SpatialReference_): The first projection to parse.\n<code>source1</code> (_str_/_int_/_gdal.Dataset_/_ogr.DataSource_/_osr.SpatialReference_): The second projection to parse.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the projections match, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source1</span>, </span><span class=\"param\"><span class=\"n\">source2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.projections_match_list", "modulename": "buteo.utils.gdal_utils", "qualname": "projections_match_list", "kind": "function", "doc": "<p>Tests if a list of projection sources all have the same projection.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>list_of_projection_sources</code> (_list_): A list of projections to test.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_bool_): <strong>True</strong> if the projections match, <strong>False</strong> otherwise.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">list_of_projection_sources</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.parse_raster_size", "modulename": "buteo.utils.gdal_utils", "qualname": "parse_raster_size", "kind": "function", "doc": "<p>Parses the raster size from either a list of numbers or a GDAL raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>target_size</code> (_any_): The target to parse raster_size from.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>target_in_pixels</code> (_bool_): If <strong>True</strong>, the target size is in pixels, otherwise it is in the rasters_units. (Default: <strong>False</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_tuple_): The raster size in the form of: <code>(x_res, y_res, x_size, y_size)</code>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">target_in_pixels</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.get_gdalwarp_ram_limit", "modulename": "buteo.utils.gdal_utils", "qualname": "get_gdalwarp_ram_limit", "kind": "function", "doc": "<p>Converts a RAM limit to a GDALWarp RAM limit.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>limit</code> (_str_/_int_): The RAM limit to convert. Can be auto, a percentage \"80%\" or a number in MB.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_int_): The GDALWarp RAM limit in bytes.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">limit_in_mb</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.to_array_list", "modulename": "buteo.utils.gdal_utils", "qualname": "to_array_list", "kind": "function", "doc": "<p>Converts a numpy array or list of numpy arrays to a list of arrays.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>array_or_list_of_array</code> (_numpy.ndarray_/_list_/_str_): The numpy array or list of numpy arrays to convert to a list of arrays.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The list of arrays.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">array_or_list_of_array</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.to_band_list", "modulename": "buteo.utils.gdal_utils", "qualname": "to_band_list", "kind": "function", "doc": "<p>Converts a band number or list of band numbers to a list of band numbers.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>band_number</code> (_int_/_float_/_list_): The band number or list of band numbers to convert to a list of band numbers. </br>\n<code>band_count</code> (_int_): The number of bands in the raster. </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_list_): The list of band numbers.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">band_number</span>, </span><span class=\"param\"><span class=\"n\">band_count</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.create_output_path", "modulename": "buteo.utils.gdal_utils", "qualname": "create_output_path", "kind": "function", "doc": "<p>Prepares a raster/vector for writing. Generates an output path. If no output path is\nspecified, the raster is written to memory. If a folder is given, that output directory is used\nalong with the input filename.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset_path</code> (_gdal.Dataset_/_ogr.DataSource_/_str_): A <strong>GDAL</strong> or <strong>OGR</strong> dataframe, a name (with extension) of a raster </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): A path to a directory to write the raster to. (Default: <strong>None</strong>). </br>\n<code>overwrite</code> (_bool_): If True, the output raster will be overwritten if it already exists. (Default: <strong>True</strong>). </br>\n<code>prefix</code> (_str_): A string to prepend to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>suffix</code> (_str_): A string to append to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>add_uuid</code> (_bool_): If True, a UUID will be added to the output filename. (Default: <strong>False</strong>). </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): A path to the output raster or a list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset_path</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ext</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.create_output_path_list", "modulename": "buteo.utils.gdal_utils", "qualname": "create_output_path_list", "kind": "function", "doc": "<p>Prepares a raster/vector or a list of rasters/vectors for writing. Generates output paths. If no output paths are\nspecified, the rasters are written to memory. If a folder is given, the output directory is chosen,\nthe input filenames remain the same. If a specific path is used it must be the same length as the\ninput.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset_path</code> (_gdal.Dataset_/_ogr.DataSource_/_str_/_list__): A <strong>GDAL</strong> or <strong>OGR</strong> dataframe, a path to a raster or a list of same. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): A path to a directory to write the raster to. (Default: <strong>None</strong>). </br>\n<code>overwrite</code> (_bool_): If True, the output raster will be overwritten if it already exists. (Default: <strong>True</strong>). </br>\n<code>prefix</code> (_str_): A string to prepend to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>suffix</code> (_str_): A string to append to the output filename. (Default: <strong>\"\"</strong>). </br>\n<code>add_uuid</code> (_bool_): If True, a UUID will be added to the output filename. (Default: <strong>False</strong>). </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): A path to the output raster or a list of paths.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset_path</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">ext</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.save_dataset_to_disk", "modulename": "buteo.utils.gdal_utils", "qualname": "save_dataset_to_disk", "kind": "function", "doc": "<p>Writes a dataset to disk. Can be a raster or a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource_/_list_): The dataset(s) to save. </br>\n<code>out_path</code> (_str_/_list_): The path(s) to save the dataset(s) to. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>overwrite</code> (_bool_): Whether to overwrite the file if it already exists. (Default: <strong>True</strong>) </br>\n<code>creation_options</code> (_list_/_None_): A list of creation options to pass to GDAL if saving as raster. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Whether to add a UUID to the file name. (Default: <strong>False</strong>) </br></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.utils.gdal_utils.save_dataset_to_memory", "modulename": "buteo.utils.gdal_utils", "qualname": "save_dataset_to_memory", "kind": "function", "doc": "<p>Writes a dataset to memory. Can be a raster or a vector.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>dataset</code> (_str_/_gdal.Dataset_/_ogr.DataSource_/_list_): The dataset(s) to save. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>overwrite</code> (_bool_): Whether to overwrite the file if it already exists. (Default: <strong>True</strong>) </br>\n<code>creation_options</code> (_list_/_None_): A list of creation options to pass to GDAL if saving as raster. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the file name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Whether to add a UUID to the file name. (Default: <strong>True</strong>) </br></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">dataset</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">creation_options</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector", "modulename": "buteo.vector", "kind": "module", "doc": "<p>Work with vector data and attributes with ease.</p>\n"}, {"fullname": "buteo.vector.buffer", "modulename": "buteo.vector.buffer", "kind": "module", "doc": "<h3 id=\"clip-vectors-to-other-geometries\">Clip vectors to other geometries</h3>\n\n<p>Clip vector files with other geometries. Can come from rasters or vectors.</p>\n"}, {"fullname": "buteo.vector.buffer.buffer_vector", "modulename": "buteo.vector.buffer", "qualname": "buffer_vector", "kind": "function", "doc": "<p>Buffers a vector with a fixed distance or an attribute.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): Vector(s) to buffer. </br>\n<code>distance</code> (_int_/_float_/_str_): The distance to buffer with. If string, uses the attribute of that name. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): Output path. If None, memory vectors are created. (Default: <strong>None</strong>) </br>\n<code>prefix</code> (_str_): Prefix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): Suffix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add UUID to the output path. (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow lists of vectors as input. (Default: <strong>True</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite output if it already exists. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Output path(s) of clipped vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">distance</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.clip", "modulename": "buteo.vector.clip", "kind": "module", "doc": "<h3 id=\"clip-vectors-to-other-geometries\">Clip vectors to other geometries</h3>\n\n<p>Clip vector files with other geometries. Can come from rasters or vectors.</p>\n"}, {"fullname": "buteo.vector.clip.clip_vector", "modulename": "buteo.vector.clip", "qualname": "clip_vector", "kind": "function", "doc": "<p>Clips a vector to a geometry.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): Vector(s) to clip. </br>\n<code>clip_geom</code> (_str_/_ogr.Geometry_): Vector to clip with. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): Output path. If None, memory vectors are created. (Default: <strong>None</strong>) </br>\n<code>to_extent</code> (_bool_): Clip to extent. (Default: <strong>False</strong>) </br>\n<code>target_projection</code> (_str_/_ogr.DataSource_/_gdal.Dataset_/_osr.SpatialReference_/_int_/_None_): Target projection. (Default: <strong>None</strong>) </br>\n<code>preserve_fid</code> (_bool_): Preserve fid. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): Prefix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): Suffix to add to the output path. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add UUID to the output path. (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow lists of vectors as input. (Default: <strong>True</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite output if it already exists. (Default: <strong>True</strong>) </br>\n<code>promote_to_multi</code> (_bool_): Should POLYGON by promoted to MULTIPOLYGON.. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Output path(s) of clipped vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">to_extent</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">target_projection</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">preserve_fid</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">promote_to_multi</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.convert_parts", "modulename": "buteo.vector.convert_parts", "kind": "module", "doc": "<h3 id=\"convert-geometry-composition\">Convert geometry composition.</h3>\n\n<p>Convert geometries from multiparts and singleparts and vice versa.</p>\n"}, {"fullname": "buteo.vector.convert_parts.singlepart_to_multipart", "modulename": "buteo.vector.convert_parts", "qualname": "singlepart_to_multipart", "kind": "function", "doc": "<p>Converts a singlepart vector to multipart.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): The vector(s) to convert. </br></p>\n\n<h2 id=\"kvargs\">Kvargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): The path(s) to the output vector. If None a memory output is produced. (Default: <strong>None</strong>) </br>\n<code>add_index</code> (_bool_): Add an geospatial index to the output vector. (Default: <strong>True</strong>) </br>\n<code>process_layer</code> (_int_): The layer index to process. (Default: <strong>-1</strong>) </br>\n<code>prefix</code> (_str_): The prefix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add a UUID field to the output vector. (Default: <strong>False</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite the output vector if it already exists. (Default: <strong>True</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow the input to be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the output vector.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.convert_parts.multipart_to_singlepart", "modulename": "buteo.vector.convert_parts", "qualname": "multipart_to_singlepart", "kind": "function", "doc": "<p>Converts a multipart vector to singlepart.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): The vector(s) to convert. </br></p>\n\n<h2 id=\"kvargs\">Kvargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): The path(s) to the output vector. If None a memory output is produced. (Default: <strong>None</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite the output vector if it already exists. (Default: <strong>True</strong>) </br>\n<code>add_index</code> (_bool_): Add an geospatial index to the output vector. (Default: <strong>True</strong>) </br>\n<code>process_layer</code> (_int_): The layer index to process. (Default: <strong>-1</strong>) </br>\n<code>verbose</code> (_bool_): Print progress. (Default: <strong>False</strong>) </br>\n<code>prefix</code> (_str_): The prefix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): The suffix to add to the layer name. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add a UUID field to the output vector. (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow the input to be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the output vector.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector", "modulename": "buteo.vector.core_vector", "kind": "module", "doc": "<h3 id=\"basic-io-functions-for-working-with-vectprs\">Basic IO functions for working with Vectprs</h3>\n\n<p>The basic module for interacting with vector data</p>\n"}, {"fullname": "buteo.vector.core_vector.open_vector", "modulename": "buteo.vector.core_vector", "qualname": "open_vector", "kind": "function", "doc": "<p>Opens a vector to an ogr.Datasource class.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_gdal.Dataset_): The vector to open. If a\nraster is supplied the bounding box is opened as a vector. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>writeable</code> (_bool_): If True, the vector is opened in write mode. (Default: <strong>True</strong>) </br>\n<code>allow_raster</code> (_bool_): If True, a raster will be opened as a vector bounding box. (Default: <strong>True</strong>) </br>\n<code>allow_lists</code> (_bool_): If True, the input can be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_ogr.DataSource_/_list_): The opened vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">writeable</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">allow_raster</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_to_metadata", "modulename": "buteo.vector.core_vector", "qualname": "vector_to_metadata", "kind": "function", "doc": "<p>Creates a dictionary with metadata about the vector layer.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_ogr.DataSource_/_str_/_list_): A vector layer(s) or path(s) to a vector file.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>allow_lists</code> (_bool_): If <strong>True</strong>, vector can be a list of vector layers or paths. If <code>False</code>, <code>vector</code> must be a single vector layer or path. (default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_dict_/_list_) A dictionary with metadata about the vector layer(s) or a list of dictionaries with metadata about the vector layer(s).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.filter_vector", "modulename": "buteo.vector.core_vector", "qualname": "filter_vector", "kind": "function", "doc": "<p>Filters a vector using its attribute table and a function.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_ogr.DataSource_/_str_/_list_): A vector layer(s) or path(s) to a vector file.\n<code>filter_function</code> (_function_): A function that takes a dictionary of attributes and returns a boolean.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_): Path to the output vector file. If <code>None</code>, a memory vector will be created. (Default: <strong>None</strong>) </br>\n<code>process_layer</code> (_int_): The index of the layer to process. If <code>-1</code>, all layers will be processed. (Default: <strong>-1</strong>) </br>\n<code>allow_lists</code> (_bool_): If <strong>True</strong>, vector can be a list of vector layers or paths. If <code>False</code>, <code>vector</code> must be a single vector layer or path. (default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the output vector file. (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the output vector file. (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): If <strong>True</strong>, a UUID will be added to the output vector file. (Default: <strong>False</strong>) </br>\n<code>overwrite</code> (_bool_): If <strong>True</strong>, the output vector file will be overwritten if it already exists. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Path(s) to the output vector file(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">filter_function</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_add_index", "modulename": "buteo.vector.core_vector", "qualname": "vector_add_index", "kind": "function", "doc": "<p>Adds a spatial index to the vector in place, if it doesn't have one.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p>(_ogr.DataSource_/_str_/_list_): A vector layer(s) or path(s) to add indices to.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>allow_lists</code> (_bool_): If <strong>True</strong>, vector can be a list of vector layers or paths. If <code>False</code>, <code>vector</code> must be a single vector layer or path. (default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Path(s) to the input rasters.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_add_shapes_in_place", "modulename": "buteo.vector.core_vector", "qualname": "vector_add_shapes_in_place", "kind": "function", "doc": "<p>Adds shape calculations to a vector such as area and perimeter.\nCan also add compactness measurements.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): Vector layer(s) or path(s) to vector layer(s).</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>shapes</code> (_list_/_None_): The shapes to calculate. The following a possible: </br>\n    * Area          (In same unit as projection)\n    * Perimeter     (In same unit as projection)\n    * IPQ           (0-1) given as (4<em>Pi</em>Area)/(Perimeter ** 2)\n    * Hull Area     (The area of the convex hull. Same unit as projection)\n    * Compactness   (0-1) given as sqrt((area / hull_area) * ipq)\n    * Centroid      (Coordinate of X and Y)\nThe default is all shapes. </br>\n<code>prefix</code> (_str_): Prefix to add to the field names.\n<code>allow_lists</code> (_bool_): If True, will accept a list of vectors. If False, will raise an error if a list is passed.\n<code>verbose</code> (_bool_): If True, will print progress.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): Path(s) to the original rasters that have been augmented in place.</p>\n\n<h6 id=\"returns-2\">Returns:</h6>\n\n<blockquote>\n  <p>Either the path to the updated vector or a list of the input vectors.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vector</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">shapes</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>, </span><span class=\"param\"><span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">verbose</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_get_attribute_table", "modulename": "buteo.vector.core_vector", "qualname": "vector_get_attribute_table", "kind": "function", "doc": "<p>Get the attribute table(s) of a vector.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">include_fids</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">include_geometry</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">include_attributes</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.core_vector.vector_filter_layer", "modulename": "buteo.vector.core_vector", "qualname": "vector_filter_layer", "kind": "function", "doc": "<p>Filters a multi-layer vector source to a single layer.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">layer_name_or_idx</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;_layer&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.dissolve", "modulename": "buteo.vector.dissolve", "kind": "module", "doc": "<h3 id=\"dissolve-vector-geometries\">Dissolve vector geometries.</h3>\n\n<p>Dissolve vectors by attributes or geometry.</p>\n"}, {"fullname": "buteo.vector.dissolve.dissolve_vector", "modulename": "buteo.vector.dissolve", "qualname": "dissolve_vector", "kind": "function", "doc": "<p>Clips a vector to a geometry.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vector (list of vectors/path/vector):</strong>  The vectors(s) to clip.</li>\n<li><strong>clip_geom (list of geom/path/vector/rasters):</strong>  The geometry to use</li>\n<li>for the clipping</li>\n</ul>\n\n<p>**kwargs:</p>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>A clipped ogr.Datasource or the path to one.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">attribute</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=-</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.grid", "modulename": "buteo.vector.grid", "kind": "module", "doc": "<p>Create vector grids from references or hardcode</p>\n"}, {"fullname": "buteo.vector.grid.create_grid", "modulename": "buteo.vector.grid", "qualname": "create_grid", "kind": "function", "doc": "<p>Not implemented.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.intersect", "modulename": "buteo.vector.intersect", "kind": "module", "doc": "<h3 id=\"calculate-intersections\">Calculate intersections</h3>\n\n<p>Calculate and tests the intersections between geometries.</p>\n"}, {"fullname": "buteo.vector.intersect.intersect_vector", "modulename": "buteo.vector.intersect", "qualname": "intersect_vector", "kind": "function", "doc": "<p>Clips a vector to a geometry.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource_/_list_): The vector(s) to intersect. </br>\n<code>clip_geom</code> (_str_/_ogr.Geometry_): The geometry to intersect the vector(s) with. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_list_/_None_): The path(s) to save the clipped vector(s) to. (Default: <strong>None</strong>) </br>\n<code>process_layer</code> (_int_): The layer to process in the vector(s). (Default: <strong>0</strong>) </br>\n<code>process_layer_clip</code> (_int_): The layer to process in the clip geometry. (Default: <strong>0</strong>) </br>\n<code>add_index</code> (_bool_): Add a geospatial index to the vector(s). (Default: <strong>True</strong>) </br>\n<code>overwrite</code> (_bool_): Overwrite the output vector(s) if they already exist. (Default: <strong>True</strong>) </br>\n<code>prefix</code> (_str_): A prefix to add to the output vector(s). (Default: <strong>\"\"</strong>) </br>\n<code>suffix</code> (_str_): A suffix to add to the output vector(s). (Default: <strong>\"\"</strong>) </br>\n<code>add_uuid</code> (_bool_): Add a UUID to the output vector(s). (Default: <strong>False</strong>) </br>\n<code>allow_lists</code> (_bool_): Allow the input to be a list of vectors. (Default: <strong>True</strong>) </br></p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_/_list_): The path(s) to the clipped vector(s).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">clip_geom</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">process_layer_clip</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">add_index</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.merge", "modulename": "buteo.vector.merge", "kind": "module", "doc": "<h3 id=\"merge-vectors\">Merge vectors.</h3>\n\n<p>Merges vectors into a single vector file.</p>\n"}, {"fullname": "buteo.vector.merge.merge_vectors", "modulename": "buteo.vector.merge", "qualname": "merge_vectors", "kind": "function", "doc": "<p>Merge vectors to a single geopackage.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vectors</code> (_list_): List of vectors to merge.</p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_): Path to output vector. (Default: <strong>None</strong>) </br>\n<code>preserve_fid</code> (_bool_): Preserve FIDs? (Default: <strong>True</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): Path to output vector.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">vectors</span>, </span><span class=\"param\"><span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"o\">*</span>, </span><span class=\"param\"><span class=\"n\">preserve_fid</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.rasterize", "modulename": "buteo.vector.rasterize", "kind": "module", "doc": "<h3 id=\"rasterize-vectors\">Rasterize vectors.</h3>\n\n<p>Functions to rasterize vectors to rasters.</p>\n\n<h6 id=\"todo\">TODO:</h6>\n\n<blockquote>\n  <ul>\n  <li>Add support for projections</li>\n  </ul>\n</blockquote>\n"}, {"fullname": "buteo.vector.rasterize.rasterize_vector", "modulename": "buteo.vector.rasterize", "qualname": "rasterize_vector", "kind": "function", "doc": "<p>Rasterize a vector to a raster.</p>\n\n<h2 id=\"args\">Args:</h2>\n\n<p><code>vector</code> (_str_/_ogr.DataSource): The vector to rasterize. </br>\n<code>pixel_size</code> (_float_/_int_): The pixel size of the raster. </br></p>\n\n<h2 id=\"kwargs\">Kwargs:</h2>\n\n<p><code>out_path</code> (_str_/_None_): Path to output raster. (Default: <strong>None</strong>) </br>\n<code>extent</code> (_list_/_None_): Extent of raster. (Default: <strong>None</strong>) </br>\n<code>all_touch</code> (_bool_): All touch? (Default: <strong>False</strong>) </br>\n<code>dtype</code> (_str_): Data type of raster. (Default: <strong>\"uint8\"</strong>) </br>\n<code>optim</code> (_str_): Optimization for raster or vector? (Default: <strong>\"raster\"</strong>) </br>\n<code>band</code> (_int_): Band to rasterize. (Default: <strong>1</strong>) </br>\n<code>fill_value</code> (_int_/_float_): Fill value. (Default: <strong>0</strong>) </br>\n<code>nodata_value</code> (_int_/_float_/_None_): Nodata value. (Default: <strong>None</strong>) </br>\n<code>check_memory</code> (_bool_): Check memory? (Default: <strong>True</strong>) </br>\n<code>burn_value</code> (_int_/_float_): Value to burn. (Default: <strong>1</strong>) </br>\n<code>attribute</code> (_str_/_None_): Attribute to burn. (Default: <strong>None</strong>)</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>(_str_): Path to output raster.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">pixel_size</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">extent</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">all_touch</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">dtype</span><span class=\"o\">=</span><span class=\"s1\">&#39;uint8&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">optim</span><span class=\"o\">=</span><span class=\"s1\">&#39;raster&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">band</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">fill_value</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">nodata_value</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">check_memory</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">burn_value</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">attribute</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.reproject", "modulename": "buteo.vector.reproject", "kind": "module", "doc": "<h3 id=\"reproject-vectors\">Reproject vectors.</h3>\n\n<p>Functions to reproject vectors. References can be both vector and raster.</p>\n"}, {"fullname": "buteo.vector.reproject.reproject_vector", "modulename": "buteo.vector.reproject", "qualname": "reproject_vector", "kind": "function", "doc": "<p>Reprojects a vector given a target projection.</p>\n\n<h6 id=\"arguments\">Arguments:</h6>\n\n<ul>\n<li><strong>vector (_path_/_vector_):</strong>  The vector to reproject.</li>\n<li><strong>projection (_str_/_int_/_vector_/_raster_):</strong>  The projection is infered from</li>\n<li><strong>the input. The input can be:</strong>  WKT proj, EPSG proj, Proj, or read from a</li>\n<li>vector or raster datasource either from path or in-memory.</li>\n</ul>\n\n<p>**kwargs:\n    out_path (_path_/_None_): The destination to save to. If None then\n    the output is an in-memory raster.</p>\n\n<pre><code>copy_if_same (_bool_): Create a copy, even if the projections are the same.\n\noverwite (_bool_): Is it possible to overwrite the out_path if it exists.\n</code></pre>\n\n<h6 id=\"returns\">Returns:</h6>\n\n<blockquote>\n  <p>An in-memory vector. If an out_path is given, the output is a string containing\n  the path to the newly created vecotr.</p>\n</blockquote>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">vector</span>,</span><span class=\"param\">\t<span class=\"n\">projection</span>,</span><span class=\"param\">\t<span class=\"n\">out_path</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">copy_if_same</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">prefix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">suffix</span><span class=\"o\">=</span><span class=\"s1\">&#39;&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">add_uuid</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">allow_lists</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "buteo.vector.zonal_statistics", "modulename": "buteo.vector.zonal_statistics", "kind": "module", "doc": "<p></p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();