<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>buteo.utils.aux_utils API documentation</title>
<meta name="description" content="Generic utility functions ### â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buteo.utils.aux_utils</code></h1>
</header>
<section id="section-intro">
<h3 id="generic-utility-functions">Generic utility functions</h3>
<p>Functions that make interacting with the toolbox easier.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
### Generic utility functions ###

Functions that make interacting with the toolbox easier.
&#34;&#34;&#34;
# Internal
from typing import Tuple

# External
import numpy as np
from numba import jit, prange



@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_latitude(lat):
    &#34;&#34;&#34; Latitude goes from -90 to 90 &#34;&#34;&#34;
    lat_adj = lat + 90.0
    lat_max = 180

    encoded_sin = ((np.sin(2 * np.pi * (lat_adj / lat_max)) + 1)) / 2.0
    encoded_cos = ((np.cos(2 * np.pi * (lat_adj / lat_max)) + 1)) / 2.0

    return np.array([encoded_sin, encoded_cos], dtype=np.float32)

@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_longitude(lng):
    &#34;&#34;&#34; Longitude goes from -180 to 180 &#34;&#34;&#34;
    lng_adj = lng + 180.0
    lng_max = 360

    encoded_sin = ((np.sin(2 * np.pi * (lng_adj / lng_max)) + 1)) / 2.0
    encoded_cos = ((np.cos(2 * np.pi * (lng_adj / lng_max)) + 1)) / 2.0

    return np.array([encoded_sin, encoded_cos], dtype=np.float32)

@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_latlng(latlng):
    &#34;&#34;&#34;
    Encode latitude and longitude values to be used as input to the model.
    &#34;&#34;&#34;
    lat = latlng[0]
    lng = latlng[1]

    encoded_lat = encode_latitude(lat)
    encoded_lng = encode_longitude(lng)

    return np.concatenate((encoded_lat, encoded_lng)).astype(np.float32)

@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_latlngs(latlngs):
    &#34;&#34;&#34; Encode multiple latitude and longitude values. &#34;&#34;&#34;
    if latlngs.ndim == 1:
        encoded_latlngs = np.apply_along_axis(encode_latlng, 0, latlngs)
    elif latlngs.ndim == 2:
        encoded_latlngs = np.apply_along_axis(encode_latlng, 1, latlngs)
    elif latlngs.ndim == 3:
        rows = latlngs.shape[0]
        cols = latlngs.shape[1]

        output_shape = (rows, cols, 4)
        encoded_latlngs = np.zeros(output_shape, dtype=np.float32)

        for i in prange(rows):
            for j in range(cols):
                latlng = latlngs[i, j]
                encoded_latlngs[i, j] = encode_latlng(latlng)
    else:
        raise ValueError(
            f&#34;The input array must have 1, 2 or 3 dimensions, not {latlngs.ndim}&#34;
        )

    return encoded_latlngs


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_latitude(encoded_sin, encoded_cos):
    &#34;&#34;&#34;
    Decode encoded latitude values to the original latitude value.
    &#34;&#34;&#34;
    lat_max = 180
    lat_max_half = lat_max / 2.0

    # Calculate the sin and cos values from the encoded values
    sin_val = (2 * encoded_sin) - 1
    cos_val = (2 * encoded_cos) - 1

    # Calculate the latitude adjustment
    lat_adj = np.arctan2(sin_val, cos_val)

    # Convert the adjusted latitude to the original latitude value
    sign = np.sign(lat_adj)
    sign_adj = np.where(sign == 0, 1, sign) * lat_max_half

    lat = ((lat_adj / (2 * np.pi)) * lat_max) - sign_adj
    lat = np.where(lat == -lat_max_half, lat_max_half, lat)

    return lat

@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_longitude(encoded_sin, encoded_cos):
    &#34;&#34;&#34;
    Decode encoded longitude values to the original longitude value.
    &#34;&#34;&#34;
    lng_max = 360
    lng_max_half = lng_max / 2.0

    # Calculate the sin and cos values from the encoded values
    sin_val = (2 * encoded_sin) - 1
    cos_val = (2 * encoded_cos) - 1

    # Calculate the longitude adjustment
    lng_adj = np.arctan2(sin_val, cos_val)

    # Convert the adjusted longitude to the original longitude value
    sign = np.sign(lng_adj)
    sign_adj = np.where(sign == 0, 1, sign) * lng_max_half

    lng = ((lng_adj / (2 * np.pi)) * lng_max) - sign_adj

    lng = np.where(lng == -lng_max_half, lng_max_half, lng)

    return lng


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_latlng(encoded_latlng):
    &#34;&#34;&#34;
    Decode encoded latitude and longitude values to the original values.
    &#34;&#34;&#34;
    lat = decode_latitude(encoded_latlng[0], encoded_latlng[1])
    lng = decode_longitude(encoded_latlng[2], encoded_latlng[3])

    return np.array([lat, lng], dtype=np.float32)

@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_latlngs(encoded_latlngs):
    &#34;&#34;&#34; Decode multiple latitude and longitude values. &#34;&#34;&#34;
    latlngs = np.apply_along_axis(decode_latlng, 1, encoded_latlngs)
    return latlngs


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_width(lng, lng_max):
    &#34;&#34;&#34; Longitude goes from -180 to 180 &#34;&#34;&#34;

    encoded_sin = ((np.sin(2 * np.pi * (lng / lng_max)) + 1)) / 2.0
    encoded_cos = ((np.cos(2 * np.pi * (lng / lng_max)) + 1)) / 2.0

    return np.array([encoded_sin, encoded_cos], dtype=np.float32)


@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_arr_position(arr):
    &#34;&#34;&#34; Fast encoding of coordinates where the width is cyclical. &#34;&#34;&#34;
    result = np.zeros((arr.shape[0], arr.shape[1], 3), dtype=np.float32)

    col_end = arr.shape[0] - 1
    row_end = arr.shape[1] - 1

    col_range = np.arange(0, arr.shape[0]).astype(np.float32)
    row_range = np.arange(0, arr.shape[1]).astype(np.float32)

    col_encoded = np.zeros((col_range.shape[0], 1), dtype=np.float32)
    row_encoded = np.zeros((row_range.shape[0], 2), dtype=np.float32)

    for col in prange(col_range.shape[0]):
        col_encoded[col, :] = col_range[col] / col_end

    for row in prange(row_range.shape[0]):
        row_encoded[row, :] = encode_width(row_range[row], row_end)

    for col in prange(arr.shape[0]):
        for row in range(arr.shape[1]):
            result[col, row, 0] = row_encoded[row, 0]
            result[col, row, 1] = row_encoded[row, 1]
            result[col, row, 2] = col_encoded[col, 0]

    return result

def channel_first_to_last(arr):
    &#34;&#34;&#34; Converts a numpy array from channel first to channel last format. &#34;&#34;&#34;
    if arr.ndim != 3:
        raise ValueError(&#34;Input array should be 3-dimensional with shape (channels, height, width)&#34;)

    # Swap the axes to change from channel first to channel last format
    arr = np.transpose(arr, (1, 2, 0))

    return arr

def channel_last_to_first(arr):
    &#34;&#34;&#34; Converts a numpy array from channel last to channel first format. &#34;&#34;&#34;
    if arr.ndim != 3:
        raise ValueError(&#34;Input array should be 3-dimensional with shape (height, width, channels)&#34;)

    # Swap the axes to change from channel last to channel first format
    arr = np.transpose(arr, (2, 0, 1))

    return arr

def scale_to_range(arr, min_val, max_val):
    &#34;&#34;&#34; Scales the values in the input array to the specified range. &#34;&#34;&#34;

    # Scale the values in the array to the specified range
    arr = (arr - arr.min()) / (arr.max() - arr.min())
    arr = (max_val - min_val) * arr + min_val

    return arr

@jit(nopython=True)
def create_grid(range_rows, range_cols):
    &#34;&#34;&#34; Create a grid of rows and columns &#34;&#34;&#34;
    rows_grid = np.zeros((len(range_rows), len(range_cols)), dtype=np.int64)
    cols_grid = np.zeros((len(range_rows), len(range_cols)), dtype=np.int64)

    for i in range(len(range_rows)):
        for j in range(len(range_cols)):
            cols_grid[i, j] = range_rows[j]
            rows_grid[i, j] = range_cols[i]

    return rows_grid, cols_grid


def split_into_offsets(shape, offsets_x=2, offsets_y=2, overlap_x=0, overlap_y=0):
    &#34;&#34;&#34; Split a shape into offsets. Usually used for splitting an image into offsets to reduce RAM needed. &#34;&#34;&#34;
    height = shape[0]
    width = shape[1]

    x_remainder = width % offsets_x
    y_remainder = height % offsets_y

    x_offsets = [0]
    x_sizes = []
    for _ in range(offsets_x - 1):
        x_offsets.append(x_offsets[-1] + (width // offsets_x) - overlap_x)
    x_offsets[-1] -= x_remainder

    for idx, _ in enumerate(x_offsets):
        if idx == len(x_offsets) - 1:
            x_sizes.append(width - x_offsets[idx])
        elif idx == 0:
            x_sizes.append(x_offsets[1] + overlap_x)
        else:
            x_sizes.append(x_offsets[idx + 1] - x_offsets[idx] + overlap_x)

    y_offsets = [0]
    y_sizes = []
    for _ in range(offsets_y - 1):
        y_offsets.append(y_offsets[-1] + (height // offsets_y) - overlap_y)
    y_offsets[-1] -= y_remainder

    for idx, _ in enumerate(y_offsets):
        if idx == len(y_offsets) - 1:
            y_sizes.append(height - y_offsets[idx])
        elif idx == 0:
            y_sizes.append(y_offsets[1] + overlap_y)
        else:
            y_sizes.append(y_offsets[idx + 1] - y_offsets[idx] + overlap_y)

    offsets = []

    for idx_col, _ in enumerate(y_offsets):
        for idx_row, _ in enumerate(x_offsets):
            offsets.append([
                x_offsets[idx_row],
                y_offsets[idx_col],
                x_sizes[idx_row],
                y_sizes[idx_col],
            ])

    return offsets


@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def calculate_pixel_distances(array, target=1, maximum_distance=None, pixel_width=1, pixel_height=1):
    &#34;&#34;&#34; Calculate the distance from each pixel to the nearest target pixel. &#34;&#34;&#34;
    binary_array = np.sum(array == target, axis=2, dtype=np.uint8)

    if maximum_distance is None:
        maximum_distance = np.sqrt(binary_array.shape[0] ** 2 + binary_array.shape[1] ** 2)

    radius_cols = int(np.ceil(maximum_distance / pixel_height))
    radius_rows = int(np.ceil(maximum_distance / pixel_width))

    kernel_cols = radius_cols * 2
    kernel_rows = radius_rows * 2

    if kernel_cols % 2 == 0:
        kernel_cols += 1

    if kernel_rows % 2 == 0:
        kernel_rows += 1

    middle_cols = int(np.floor(kernel_cols / 2))
    middle_rows = int(np.floor(kernel_rows / 2))

    range_cols = np.arange(-middle_cols, middle_cols + 1)
    range_rows = np.arange(-middle_rows, middle_rows + 1)

    cols_grid, rows_grid = create_grid(range_rows, range_cols)
    coord_grid = np.empty((cols_grid.size, 2), dtype=np.int64)
    coord_grid[:, 0] = cols_grid.flatten()
    coord_grid[:, 1] = rows_grid.flatten()

    coord_grid_projected = np.empty_like(coord_grid, dtype=np.float32)
    coord_grid_projected[:, 0] = coord_grid[:, 0] * pixel_height
    coord_grid_projected[:, 1] = coord_grid[:, 1] * pixel_width

    coord_grid_values = np.sqrt((coord_grid_projected[:, 0] ** 2) + (coord_grid_projected[:, 1] ** 2))

    selected_range = np.arange(coord_grid.shape[0])
    selected_range = selected_range[np.argsort(coord_grid_values)][1:]
    selected_range = selected_range[coord_grid_values[selected_range] &lt;= maximum_distance]

    coord_grid = coord_grid[selected_range]
    coord_grid_values = coord_grid_values[selected_range]

    distances = np.full_like(binary_array, maximum_distance, dtype=np.float32)
    for col in prange(binary_array.shape[0]):
        for row in range(binary_array.shape[1]):
            if binary_array[col, row] == target:
                distances[col, row] = 0
            else:
                for idx, (col_adj, row_adj) in enumerate(coord_grid):
                    if (col + col_adj) &gt;= 0 and (col + col_adj) &lt; binary_array.shape[0] and \
                        (row + row_adj) &gt;= 0 and (row + row_adj) &lt; binary_array.shape[1] and \
                        binary_array[col + col_adj, row + row_adj] == target:

                        distances[col, row] = coord_grid_values[idx]
                        break

    return np.expand_dims(distances, axis=2)

@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def fill_nodata_with_nearest_average(array, nodata_value, mask=None, max_iterations=None, channel=0):
    &#34;&#34;&#34; Calculate the distance from each pixel to the nearest target pixel. &#34;&#34;&#34;
    kernel_size = 3

    range_rows = np.arange(-(kernel_size // 2), (kernel_size // 2) + 1)
    range_cols = np.arange(-(kernel_size // 2), (kernel_size // 2) + 1)

    cols_grid, rows_grid = create_grid(range_rows, range_cols)
    coord_grid = np.empty((cols_grid.size, 2), dtype=np.int64)
    coord_grid[:, 0] = cols_grid.flatten()
    coord_grid[:, 1] = rows_grid.flatten()

    coord_grid_values = np.sqrt((coord_grid[:, 0] ** 2) + (coord_grid[:, 1] ** 2))
    coord_grid_values_sort = np.argsort(coord_grid_values)[1:]
    coord_grid_values = coord_grid_values[coord_grid_values_sort]

    coord_grid = coord_grid[coord_grid_values_sort]

    weights = 1 / coord_grid_values
    weights = weights / np.sum(weights)
    weights = weights.astype(np.float32)

    main_filled = np.copy(array)

    if mask is None:
        mask = np.ones_like(main_filled, dtype=np.uint8)
    else:
        mask = (mask == 1).astype(np.uint8)

    main_filled = main_filled[:, :, channel]
    mask = mask[:, :, channel]

    nodata_value = np.array(nodata_value, dtype=array.dtype)
    uint8_1 = np.array(1, dtype=np.uint8)

    iterations = 0
    while True:
        local_filled = np.copy(main_filled)
        for row in prange(main_filled.shape[0]):
            for col in prange(main_filled.shape[1]):
                if main_filled[row, col] != nodata_value:
                    continue
                if mask[row, col] != uint8_1:
                    continue

                count = 0
                weights_sum = 0.0
                value_sum = 0.0

                for idx, (col_adj, row_adj) in enumerate(coord_grid):
                    if (row + row_adj) &gt;= 0 and (row + row_adj) &lt; main_filled.shape[0] and \
                        (col + col_adj) &gt;= 0 and (col + col_adj) &lt; main_filled.shape[1] and \
                        main_filled[row + row_adj, col + col_adj] != nodata_value and \
                        mask[row + row_adj, col + col_adj] == uint8_1:

                        weight = weights[idx]
                        value = main_filled[row + row_adj, col + col_adj]

                        value_sum += value * weight
                        weights_sum += weight
                        count += 1

                if count == 0:
                    local_filled[row, col] = nodata_value
                else:
                    local_filled[row, col] = value_sum * (1.0 / weights_sum)

        main_filled = local_filled
        iterations += 1

        if max_iterations is not None and iterations &gt;= max_iterations:
            break

        if np.sum((main_filled == nodata_value) &amp; (mask == uint8_1)) == 0:
            break

    return np.expand_dims(main_filled, axis=2)

@jit(nopython=True, fastmath=True, cache=True, nogil=True, inline=&#39;always&#39;)
def single_hue_to_rgb(
    p: float,
    q: float,
    t: float,
) -&gt; float:
    &#34;&#34;&#34;
    Helper function to convert hue to RGB.

    Args:
        p (float): Intermediate value used for hue to RGB conversion.
        q (float): Intermediate value used for hue to RGB conversion.
        t (float): Hue value.

    Returns:
        float: RGB value.
    &#34;&#34;&#34;
    if t &lt; 0:
        t += 1
    if t &gt; 1:
        t -= 1
    if t &lt; 1/6:
        return p + (q - p) * 6 * t
    if t &lt; 1/2:
        return q
    if t &lt; 2/3:
        return p + (q - p) * (2/3 - t) * 6
    return p


@jit(nopython=True, fastmath=True, cache=True, nogil=True, inline=&#39;always&#39;)
def single_hsl_to_rgb(
    h: float,
    s: float,
    l: float,
) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    Convert a single HSL color to RGB.

    Args:
        h (float): Hue component.
        s (float): Saturation component.
        l (float): Lightness component.

    Returns:
        Tuple[float, float, float]: Tuple of RGB values (r, g, b).
    &#34;&#34;&#34;
    if s == 0:
        return l, l, l

    q = l * (1 + s) if l &lt; 0.5 else l + s - l * s
    p = 2 * l - q

    r = single_hue_to_rgb(p, q, h + 1/3)
    g = single_hue_to_rgb(p, q, h)
    b = single_hue_to_rgb(p, q, h - 1/3)

    return r, g, b


@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def hsl_to_rgb(hsl_array: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Convert an HSL array to an RGB array.

    Args:
        hsl_array (np.ndarray): Input HSL array with shape (height, width, 3).

    Returns:
        np.ndarray: Output RGB array with shape (height, width, 3).
    &#34;&#34;&#34;
    assert hsl_array.ndim == 3, &#34;Input array must have 3 dimensions&#34;
    assert hsl_array.shape[-1] == 3, &#34;Input array must have 3 channels&#34;
    assert hsl_array.min() &gt;= 0 and hsl_array.max() &lt;= 1, &#34;Input array must be normalized&#34;

    shape = hsl_array.shape

    rgb_array = np.empty(shape, dtype=np.float32)
    for i in prange(shape[0]):
        for j in range(shape[1]):
            h, s, l = hsl_array[i, j]

            r, g, b = single_hsl_to_rgb(h, s, l)

            if hsl_array.ndim == 3:
                rgb_array[i, j, 0] = r
                rgb_array[i, j, 1] = g
                rgb_array[i, j, 2] = b
            else:
                rgb_array[i, j] = [r, g, b]

    return rgb_array


@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def rgb_to_hsl(rgb_array: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34; Convert an RGB array to an HSL array.
    
    Args:
        rgb_array (np.ndarray): Input RGB array with shape (height, width, 3).
    
    Returns:
        np.ndarray: Output HSL array with shape (height, width, 3).
    &#34;&#34;&#34;
    assert rgb_array.ndim == 3, &#34;Input array must have 3 dimensions&#34;
    assert rgb_array.shape[-1] == 3, &#34;Input array must have 3 channels&#34;
    assert rgb_array.min() &gt;= 0 and rgb_array.max() &lt;= 1, &#34;Input array must be normalized&#34;

    # Get the shape of the input array
    shape = rgb_array.shape

    # Initialize the minimum and maximum arrays
    cmin = np.zeros((shape[0], shape[1]))
    cmax = np.zeros((shape[0], shape[1]))

    # Calculate the minimum and maximum of the RGB values for each pixel
    for i in prange(shape[0]):
        for j in prange(shape[1]):
            cmin[i, j] = np.min(rgb_array[i, j, :])
            cmax[i, j] = np.max(rgb_array[i, j, :])

    # Calculate the difference of the RGB values
    delta = cmax - cmin

    # Initialize the HSL arrays
    hue = np.zeros((shape[0], shape[1]))
    saturation = np.zeros((shape[0], shape[1]))
    luminosity = (cmax + cmin) / 2

    # Initialize the HSL array
    hsl_array = np.zeros((shape[0], shape[1], 3))

    red, green, blue = rgb_array[..., 0], rgb_array[..., 1], rgb_array[..., 2]

    for i in prange(shape[0]):
        for j in prange(shape[1]):
            if delta[i, j] != 0:
                saturation[i, j] = delta[i, j] / (1 - np.abs(2 * luminosity[i, j] - 1))

                if cmax[i, j] == red[i, j]:
                    hue[i, j] = (green[i, j] - blue[i, j]) / delta[i, j] % 6
                elif cmax[i, j] == green[i, j]:
                    hue[i, j] = (blue[i, j] - red[i, j]) / delta[i, j] + 2
                elif cmax[i, j] == blue[i, j]:
                    hue[i, j] = (red[i, j] - green[i, j]) / delta[i, j] + 4

                hue[i, j] = (hue[i, j] * 60) % 360
                if hue[i, j] &lt; 0:
                    hue[i, j] += 360

    # Normalize the hue value to [0, 1]
    hue /= 360

    # Assign the h, s, and l values to the HSL array
    hsl_array[..., 0] = hue
    hsl_array[..., 1] = saturation
    hsl_array[..., 2] = luminosity

    hsl_array = np.clip(hsl_array, 0.0, 1.0)

    return hsl_array</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="buteo.utils.aux_utils.calculate_pixel_distances"><code class="name flex">
<span>def <span class="ident">calculate_pixel_distances</span></span>(<span>array, target=1, maximum_distance=None, pixel_width=1, pixel_height=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distance from each pixel to the nearest target pixel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def calculate_pixel_distances(array, target=1, maximum_distance=None, pixel_width=1, pixel_height=1):
    &#34;&#34;&#34; Calculate the distance from each pixel to the nearest target pixel. &#34;&#34;&#34;
    binary_array = np.sum(array == target, axis=2, dtype=np.uint8)

    if maximum_distance is None:
        maximum_distance = np.sqrt(binary_array.shape[0] ** 2 + binary_array.shape[1] ** 2)

    radius_cols = int(np.ceil(maximum_distance / pixel_height))
    radius_rows = int(np.ceil(maximum_distance / pixel_width))

    kernel_cols = radius_cols * 2
    kernel_rows = radius_rows * 2

    if kernel_cols % 2 == 0:
        kernel_cols += 1

    if kernel_rows % 2 == 0:
        kernel_rows += 1

    middle_cols = int(np.floor(kernel_cols / 2))
    middle_rows = int(np.floor(kernel_rows / 2))

    range_cols = np.arange(-middle_cols, middle_cols + 1)
    range_rows = np.arange(-middle_rows, middle_rows + 1)

    cols_grid, rows_grid = create_grid(range_rows, range_cols)
    coord_grid = np.empty((cols_grid.size, 2), dtype=np.int64)
    coord_grid[:, 0] = cols_grid.flatten()
    coord_grid[:, 1] = rows_grid.flatten()

    coord_grid_projected = np.empty_like(coord_grid, dtype=np.float32)
    coord_grid_projected[:, 0] = coord_grid[:, 0] * pixel_height
    coord_grid_projected[:, 1] = coord_grid[:, 1] * pixel_width

    coord_grid_values = np.sqrt((coord_grid_projected[:, 0] ** 2) + (coord_grid_projected[:, 1] ** 2))

    selected_range = np.arange(coord_grid.shape[0])
    selected_range = selected_range[np.argsort(coord_grid_values)][1:]
    selected_range = selected_range[coord_grid_values[selected_range] &lt;= maximum_distance]

    coord_grid = coord_grid[selected_range]
    coord_grid_values = coord_grid_values[selected_range]

    distances = np.full_like(binary_array, maximum_distance, dtype=np.float32)
    for col in prange(binary_array.shape[0]):
        for row in range(binary_array.shape[1]):
            if binary_array[col, row] == target:
                distances[col, row] = 0
            else:
                for idx, (col_adj, row_adj) in enumerate(coord_grid):
                    if (col + col_adj) &gt;= 0 and (col + col_adj) &lt; binary_array.shape[0] and \
                        (row + row_adj) &gt;= 0 and (row + row_adj) &lt; binary_array.shape[1] and \
                        binary_array[col + col_adj, row + row_adj] == target:

                        distances[col, row] = coord_grid_values[idx]
                        break

    return np.expand_dims(distances, axis=2)</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.channel_first_to_last"><code class="name flex">
<span>def <span class="ident">channel_first_to_last</span></span>(<span>arr)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a numpy array from channel first to channel last format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channel_first_to_last(arr):
    &#34;&#34;&#34; Converts a numpy array from channel first to channel last format. &#34;&#34;&#34;
    if arr.ndim != 3:
        raise ValueError(&#34;Input array should be 3-dimensional with shape (channels, height, width)&#34;)

    # Swap the axes to change from channel first to channel last format
    arr = np.transpose(arr, (1, 2, 0))

    return arr</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.channel_last_to_first"><code class="name flex">
<span>def <span class="ident">channel_last_to_first</span></span>(<span>arr)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a numpy array from channel last to channel first format.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def channel_last_to_first(arr):
    &#34;&#34;&#34; Converts a numpy array from channel last to channel first format. &#34;&#34;&#34;
    if arr.ndim != 3:
        raise ValueError(&#34;Input array should be 3-dimensional with shape (height, width, channels)&#34;)

    # Swap the axes to change from channel last to channel first format
    arr = np.transpose(arr, (2, 0, 1))

    return arr</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.create_grid"><code class="name flex">
<span>def <span class="ident">create_grid</span></span>(<span>range_rows, range_cols)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a grid of rows and columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True)
def create_grid(range_rows, range_cols):
    &#34;&#34;&#34; Create a grid of rows and columns &#34;&#34;&#34;
    rows_grid = np.zeros((len(range_rows), len(range_cols)), dtype=np.int64)
    cols_grid = np.zeros((len(range_rows), len(range_cols)), dtype=np.int64)

    for i in range(len(range_rows)):
        for j in range(len(range_cols)):
            cols_grid[i, j] = range_rows[j]
            rows_grid[i, j] = range_cols[i]

    return rows_grid, cols_grid</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.decode_latitude"><code class="name flex">
<span>def <span class="ident">decode_latitude</span></span>(<span>encoded_sin, encoded_cos)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode encoded latitude values to the original latitude value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_latitude(encoded_sin, encoded_cos):
    &#34;&#34;&#34;
    Decode encoded latitude values to the original latitude value.
    &#34;&#34;&#34;
    lat_max = 180
    lat_max_half = lat_max / 2.0

    # Calculate the sin and cos values from the encoded values
    sin_val = (2 * encoded_sin) - 1
    cos_val = (2 * encoded_cos) - 1

    # Calculate the latitude adjustment
    lat_adj = np.arctan2(sin_val, cos_val)

    # Convert the adjusted latitude to the original latitude value
    sign = np.sign(lat_adj)
    sign_adj = np.where(sign == 0, 1, sign) * lat_max_half

    lat = ((lat_adj / (2 * np.pi)) * lat_max) - sign_adj
    lat = np.where(lat == -lat_max_half, lat_max_half, lat)

    return lat</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.decode_latlng"><code class="name flex">
<span>def <span class="ident">decode_latlng</span></span>(<span>encoded_latlng)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode encoded latitude and longitude values to the original values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_latlng(encoded_latlng):
    &#34;&#34;&#34;
    Decode encoded latitude and longitude values to the original values.
    &#34;&#34;&#34;
    lat = decode_latitude(encoded_latlng[0], encoded_latlng[1])
    lng = decode_longitude(encoded_latlng[2], encoded_latlng[3])

    return np.array([lat, lng], dtype=np.float32)</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.decode_latlngs"><code class="name flex">
<span>def <span class="ident">decode_latlngs</span></span>(<span>encoded_latlngs)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode multiple latitude and longitude values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_latlngs(encoded_latlngs):
    &#34;&#34;&#34; Decode multiple latitude and longitude values. &#34;&#34;&#34;
    latlngs = np.apply_along_axis(decode_latlng, 1, encoded_latlngs)
    return latlngs</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.decode_longitude"><code class="name flex">
<span>def <span class="ident">decode_longitude</span></span>(<span>encoded_sin, encoded_cos)</span>
</code></dt>
<dd>
<div class="desc"><p>Decode encoded longitude values to the original longitude value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def decode_longitude(encoded_sin, encoded_cos):
    &#34;&#34;&#34;
    Decode encoded longitude values to the original longitude value.
    &#34;&#34;&#34;
    lng_max = 360
    lng_max_half = lng_max / 2.0

    # Calculate the sin and cos values from the encoded values
    sin_val = (2 * encoded_sin) - 1
    cos_val = (2 * encoded_cos) - 1

    # Calculate the longitude adjustment
    lng_adj = np.arctan2(sin_val, cos_val)

    # Convert the adjusted longitude to the original longitude value
    sign = np.sign(lng_adj)
    sign_adj = np.where(sign == 0, 1, sign) * lng_max_half

    lng = ((lng_adj / (2 * np.pi)) * lng_max) - sign_adj

    lng = np.where(lng == -lng_max_half, lng_max_half, lng)

    return lng</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.encode_arr_position"><code class="name flex">
<span>def <span class="ident">encode_arr_position</span></span>(<span>arr)</span>
</code></dt>
<dd>
<div class="desc"><p>Fast encoding of coordinates where the width is cyclical.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_arr_position(arr):
    &#34;&#34;&#34; Fast encoding of coordinates where the width is cyclical. &#34;&#34;&#34;
    result = np.zeros((arr.shape[0], arr.shape[1], 3), dtype=np.float32)

    col_end = arr.shape[0] - 1
    row_end = arr.shape[1] - 1

    col_range = np.arange(0, arr.shape[0]).astype(np.float32)
    row_range = np.arange(0, arr.shape[1]).astype(np.float32)

    col_encoded = np.zeros((col_range.shape[0], 1), dtype=np.float32)
    row_encoded = np.zeros((row_range.shape[0], 2), dtype=np.float32)

    for col in prange(col_range.shape[0]):
        col_encoded[col, :] = col_range[col] / col_end

    for row in prange(row_range.shape[0]):
        row_encoded[row, :] = encode_width(row_range[row], row_end)

    for col in prange(arr.shape[0]):
        for row in range(arr.shape[1]):
            result[col, row, 0] = row_encoded[row, 0]
            result[col, row, 1] = row_encoded[row, 1]
            result[col, row, 2] = col_encoded[col, 0]

    return result</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.encode_latitude"><code class="name flex">
<span>def <span class="ident">encode_latitude</span></span>(<span>lat)</span>
</code></dt>
<dd>
<div class="desc"><p>Latitude goes from -90 to 90</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_latitude(lat):
    &#34;&#34;&#34; Latitude goes from -90 to 90 &#34;&#34;&#34;
    lat_adj = lat + 90.0
    lat_max = 180

    encoded_sin = ((np.sin(2 * np.pi * (lat_adj / lat_max)) + 1)) / 2.0
    encoded_cos = ((np.cos(2 * np.pi * (lat_adj / lat_max)) + 1)) / 2.0

    return np.array([encoded_sin, encoded_cos], dtype=np.float32)</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.encode_latlng"><code class="name flex">
<span>def <span class="ident">encode_latlng</span></span>(<span>latlng)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode latitude and longitude values to be used as input to the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_latlng(latlng):
    &#34;&#34;&#34;
    Encode latitude and longitude values to be used as input to the model.
    &#34;&#34;&#34;
    lat = latlng[0]
    lng = latlng[1]

    encoded_lat = encode_latitude(lat)
    encoded_lng = encode_longitude(lng)

    return np.concatenate((encoded_lat, encoded_lng)).astype(np.float32)</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.encode_latlngs"><code class="name flex">
<span>def <span class="ident">encode_latlngs</span></span>(<span>latlngs)</span>
</code></dt>
<dd>
<div class="desc"><p>Encode multiple latitude and longitude values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_latlngs(latlngs):
    &#34;&#34;&#34; Encode multiple latitude and longitude values. &#34;&#34;&#34;
    if latlngs.ndim == 1:
        encoded_latlngs = np.apply_along_axis(encode_latlng, 0, latlngs)
    elif latlngs.ndim == 2:
        encoded_latlngs = np.apply_along_axis(encode_latlng, 1, latlngs)
    elif latlngs.ndim == 3:
        rows = latlngs.shape[0]
        cols = latlngs.shape[1]

        output_shape = (rows, cols, 4)
        encoded_latlngs = np.zeros(output_shape, dtype=np.float32)

        for i in prange(rows):
            for j in range(cols):
                latlng = latlngs[i, j]
                encoded_latlngs[i, j] = encode_latlng(latlng)
    else:
        raise ValueError(
            f&#34;The input array must have 1, 2 or 3 dimensions, not {latlngs.ndim}&#34;
        )

    return encoded_latlngs</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.encode_longitude"><code class="name flex">
<span>def <span class="ident">encode_longitude</span></span>(<span>lng)</span>
</code></dt>
<dd>
<div class="desc"><p>Longitude goes from -180 to 180</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_longitude(lng):
    &#34;&#34;&#34; Longitude goes from -180 to 180 &#34;&#34;&#34;
    lng_adj = lng + 180.0
    lng_max = 360

    encoded_sin = ((np.sin(2 * np.pi * (lng_adj / lng_max)) + 1)) / 2.0
    encoded_cos = ((np.cos(2 * np.pi * (lng_adj / lng_max)) + 1)) / 2.0

    return np.array([encoded_sin, encoded_cos], dtype=np.float32)</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.encode_width"><code class="name flex">
<span>def <span class="ident">encode_width</span></span>(<span>lng, lng_max)</span>
</code></dt>
<dd>
<div class="desc"><p>Longitude goes from -180 to 180</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
def encode_width(lng, lng_max):
    &#34;&#34;&#34; Longitude goes from -180 to 180 &#34;&#34;&#34;

    encoded_sin = ((np.sin(2 * np.pi * (lng / lng_max)) + 1)) / 2.0
    encoded_cos = ((np.cos(2 * np.pi * (lng / lng_max)) + 1)) / 2.0

    return np.array([encoded_sin, encoded_cos], dtype=np.float32)</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.fill_nodata_with_nearest_average"><code class="name flex">
<span>def <span class="ident">fill_nodata_with_nearest_average</span></span>(<span>array, nodata_value, mask=None, max_iterations=None, channel=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distance from each pixel to the nearest target pixel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def fill_nodata_with_nearest_average(array, nodata_value, mask=None, max_iterations=None, channel=0):
    &#34;&#34;&#34; Calculate the distance from each pixel to the nearest target pixel. &#34;&#34;&#34;
    kernel_size = 3

    range_rows = np.arange(-(kernel_size // 2), (kernel_size // 2) + 1)
    range_cols = np.arange(-(kernel_size // 2), (kernel_size // 2) + 1)

    cols_grid, rows_grid = create_grid(range_rows, range_cols)
    coord_grid = np.empty((cols_grid.size, 2), dtype=np.int64)
    coord_grid[:, 0] = cols_grid.flatten()
    coord_grid[:, 1] = rows_grid.flatten()

    coord_grid_values = np.sqrt((coord_grid[:, 0] ** 2) + (coord_grid[:, 1] ** 2))
    coord_grid_values_sort = np.argsort(coord_grid_values)[1:]
    coord_grid_values = coord_grid_values[coord_grid_values_sort]

    coord_grid = coord_grid[coord_grid_values_sort]

    weights = 1 / coord_grid_values
    weights = weights / np.sum(weights)
    weights = weights.astype(np.float32)

    main_filled = np.copy(array)

    if mask is None:
        mask = np.ones_like(main_filled, dtype=np.uint8)
    else:
        mask = (mask == 1).astype(np.uint8)

    main_filled = main_filled[:, :, channel]
    mask = mask[:, :, channel]

    nodata_value = np.array(nodata_value, dtype=array.dtype)
    uint8_1 = np.array(1, dtype=np.uint8)

    iterations = 0
    while True:
        local_filled = np.copy(main_filled)
        for row in prange(main_filled.shape[0]):
            for col in prange(main_filled.shape[1]):
                if main_filled[row, col] != nodata_value:
                    continue
                if mask[row, col] != uint8_1:
                    continue

                count = 0
                weights_sum = 0.0
                value_sum = 0.0

                for idx, (col_adj, row_adj) in enumerate(coord_grid):
                    if (row + row_adj) &gt;= 0 and (row + row_adj) &lt; main_filled.shape[0] and \
                        (col + col_adj) &gt;= 0 and (col + col_adj) &lt; main_filled.shape[1] and \
                        main_filled[row + row_adj, col + col_adj] != nodata_value and \
                        mask[row + row_adj, col + col_adj] == uint8_1:

                        weight = weights[idx]
                        value = main_filled[row + row_adj, col + col_adj]

                        value_sum += value * weight
                        weights_sum += weight
                        count += 1

                if count == 0:
                    local_filled[row, col] = nodata_value
                else:
                    local_filled[row, col] = value_sum * (1.0 / weights_sum)

        main_filled = local_filled
        iterations += 1

        if max_iterations is not None and iterations &gt;= max_iterations:
            break

        if np.sum((main_filled == nodata_value) &amp; (mask == uint8_1)) == 0:
            break

    return np.expand_dims(main_filled, axis=2)</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.hsl_to_rgb"><code class="name flex">
<span>def <span class="ident">hsl_to_rgb</span></span>(<span>hsl_array:Â numpy.ndarray) ->Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an HSL array to an RGB array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hsl_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Input HSL array with shape (height, width, 3).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Output RGB array with shape (height, width, 3).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def hsl_to_rgb(hsl_array: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Convert an HSL array to an RGB array.

    Args:
        hsl_array (np.ndarray): Input HSL array with shape (height, width, 3).

    Returns:
        np.ndarray: Output RGB array with shape (height, width, 3).
    &#34;&#34;&#34;
    assert hsl_array.ndim == 3, &#34;Input array must have 3 dimensions&#34;
    assert hsl_array.shape[-1] == 3, &#34;Input array must have 3 channels&#34;
    assert hsl_array.min() &gt;= 0 and hsl_array.max() &lt;= 1, &#34;Input array must be normalized&#34;

    shape = hsl_array.shape

    rgb_array = np.empty(shape, dtype=np.float32)
    for i in prange(shape[0]):
        for j in range(shape[1]):
            h, s, l = hsl_array[i, j]

            r, g, b = single_hsl_to_rgb(h, s, l)

            if hsl_array.ndim == 3:
                rgb_array[i, j, 0] = r
                rgb_array[i, j, 1] = g
                rgb_array[i, j, 2] = b
            else:
                rgb_array[i, j] = [r, g, b]

    return rgb_array</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.rgb_to_hsl"><code class="name flex">
<span>def <span class="ident">rgb_to_hsl</span></span>(<span>rgb_array:Â numpy.ndarray) ->Â numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an RGB array to an HSL array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rgb_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>Input RGB array with shape (height, width, 3).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Output HSL array with shape (height, width, 3).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, parallel=True, fastmath=True, cache=True, nogil=True)
def rgb_to_hsl(rgb_array: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34; Convert an RGB array to an HSL array.
    
    Args:
        rgb_array (np.ndarray): Input RGB array with shape (height, width, 3).
    
    Returns:
        np.ndarray: Output HSL array with shape (height, width, 3).
    &#34;&#34;&#34;
    assert rgb_array.ndim == 3, &#34;Input array must have 3 dimensions&#34;
    assert rgb_array.shape[-1] == 3, &#34;Input array must have 3 channels&#34;
    assert rgb_array.min() &gt;= 0 and rgb_array.max() &lt;= 1, &#34;Input array must be normalized&#34;

    # Get the shape of the input array
    shape = rgb_array.shape

    # Initialize the minimum and maximum arrays
    cmin = np.zeros((shape[0], shape[1]))
    cmax = np.zeros((shape[0], shape[1]))

    # Calculate the minimum and maximum of the RGB values for each pixel
    for i in prange(shape[0]):
        for j in prange(shape[1]):
            cmin[i, j] = np.min(rgb_array[i, j, :])
            cmax[i, j] = np.max(rgb_array[i, j, :])

    # Calculate the difference of the RGB values
    delta = cmax - cmin

    # Initialize the HSL arrays
    hue = np.zeros((shape[0], shape[1]))
    saturation = np.zeros((shape[0], shape[1]))
    luminosity = (cmax + cmin) / 2

    # Initialize the HSL array
    hsl_array = np.zeros((shape[0], shape[1], 3))

    red, green, blue = rgb_array[..., 0], rgb_array[..., 1], rgb_array[..., 2]

    for i in prange(shape[0]):
        for j in prange(shape[1]):
            if delta[i, j] != 0:
                saturation[i, j] = delta[i, j] / (1 - np.abs(2 * luminosity[i, j] - 1))

                if cmax[i, j] == red[i, j]:
                    hue[i, j] = (green[i, j] - blue[i, j]) / delta[i, j] % 6
                elif cmax[i, j] == green[i, j]:
                    hue[i, j] = (blue[i, j] - red[i, j]) / delta[i, j] + 2
                elif cmax[i, j] == blue[i, j]:
                    hue[i, j] = (red[i, j] - green[i, j]) / delta[i, j] + 4

                hue[i, j] = (hue[i, j] * 60) % 360
                if hue[i, j] &lt; 0:
                    hue[i, j] += 360

    # Normalize the hue value to [0, 1]
    hue /= 360

    # Assign the h, s, and l values to the HSL array
    hsl_array[..., 0] = hue
    hsl_array[..., 1] = saturation
    hsl_array[..., 2] = luminosity

    hsl_array = np.clip(hsl_array, 0.0, 1.0)

    return hsl_array</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.scale_to_range"><code class="name flex">
<span>def <span class="ident">scale_to_range</span></span>(<span>arr, min_val, max_val)</span>
</code></dt>
<dd>
<div class="desc"><p>Scales the values in the input array to the specified range.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scale_to_range(arr, min_val, max_val):
    &#34;&#34;&#34; Scales the values in the input array to the specified range. &#34;&#34;&#34;

    # Scale the values in the array to the specified range
    arr = (arr - arr.min()) / (arr.max() - arr.min())
    arr = (max_val - min_val) * arr + min_val

    return arr</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.single_hsl_to_rgb"><code class="name flex">
<span>def <span class="ident">single_hsl_to_rgb</span></span>(<span>h:Â float, s:Â float, l:Â float) ->Â Tuple[float,Â float,Â float]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a single HSL color to RGB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>h</code></strong> :&ensp;<code>float</code></dt>
<dd>Hue component.</dd>
<dt><strong><code>s</code></strong> :&ensp;<code>float</code></dt>
<dd>Saturation component.</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>float</code></dt>
<dd>Lightness component.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float, float]</code></dt>
<dd>Tuple of RGB values (r, g, b).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, fastmath=True, cache=True, nogil=True, inline=&#39;always&#39;)
def single_hsl_to_rgb(
    h: float,
    s: float,
    l: float,
) -&gt; Tuple[float, float, float]:
    &#34;&#34;&#34;
    Convert a single HSL color to RGB.

    Args:
        h (float): Hue component.
        s (float): Saturation component.
        l (float): Lightness component.

    Returns:
        Tuple[float, float, float]: Tuple of RGB values (r, g, b).
    &#34;&#34;&#34;
    if s == 0:
        return l, l, l

    q = l * (1 + s) if l &lt; 0.5 else l + s - l * s
    p = 2 * l - q

    r = single_hue_to_rgb(p, q, h + 1/3)
    g = single_hue_to_rgb(p, q, h)
    b = single_hue_to_rgb(p, q, h - 1/3)

    return r, g, b</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.single_hue_to_rgb"><code class="name flex">
<span>def <span class="ident">single_hue_to_rgb</span></span>(<span>p:Â float, q:Â float, t:Â float) ->Â float</span>
</code></dt>
<dd>
<div class="desc"><p>Helper function to convert hue to RGB.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>p</code></strong> :&ensp;<code>float</code></dt>
<dd>Intermediate value used for hue to RGB conversion.</dd>
<dt><strong><code>q</code></strong> :&ensp;<code>float</code></dt>
<dd>Intermediate value used for hue to RGB conversion.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>float</code></dt>
<dd>Hue value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>RGB value.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jit(nopython=True, fastmath=True, cache=True, nogil=True, inline=&#39;always&#39;)
def single_hue_to_rgb(
    p: float,
    q: float,
    t: float,
) -&gt; float:
    &#34;&#34;&#34;
    Helper function to convert hue to RGB.

    Args:
        p (float): Intermediate value used for hue to RGB conversion.
        q (float): Intermediate value used for hue to RGB conversion.
        t (float): Hue value.

    Returns:
        float: RGB value.
    &#34;&#34;&#34;
    if t &lt; 0:
        t += 1
    if t &gt; 1:
        t -= 1
    if t &lt; 1/6:
        return p + (q - p) * 6 * t
    if t &lt; 1/2:
        return q
    if t &lt; 2/3:
        return p + (q - p) * (2/3 - t) * 6
    return p</code></pre>
</details>
</dd>
<dt id="buteo.utils.aux_utils.split_into_offsets"><code class="name flex">
<span>def <span class="ident">split_into_offsets</span></span>(<span>shape, offsets_x=2, offsets_y=2, overlap_x=0, overlap_y=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Split a shape into offsets. Usually used for splitting an image into offsets to reduce RAM needed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_into_offsets(shape, offsets_x=2, offsets_y=2, overlap_x=0, overlap_y=0):
    &#34;&#34;&#34; Split a shape into offsets. Usually used for splitting an image into offsets to reduce RAM needed. &#34;&#34;&#34;
    height = shape[0]
    width = shape[1]

    x_remainder = width % offsets_x
    y_remainder = height % offsets_y

    x_offsets = [0]
    x_sizes = []
    for _ in range(offsets_x - 1):
        x_offsets.append(x_offsets[-1] + (width // offsets_x) - overlap_x)
    x_offsets[-1] -= x_remainder

    for idx, _ in enumerate(x_offsets):
        if idx == len(x_offsets) - 1:
            x_sizes.append(width - x_offsets[idx])
        elif idx == 0:
            x_sizes.append(x_offsets[1] + overlap_x)
        else:
            x_sizes.append(x_offsets[idx + 1] - x_offsets[idx] + overlap_x)

    y_offsets = [0]
    y_sizes = []
    for _ in range(offsets_y - 1):
        y_offsets.append(y_offsets[-1] + (height // offsets_y) - overlap_y)
    y_offsets[-1] -= y_remainder

    for idx, _ in enumerate(y_offsets):
        if idx == len(y_offsets) - 1:
            y_sizes.append(height - y_offsets[idx])
        elif idx == 0:
            y_sizes.append(y_offsets[1] + overlap_y)
        else:
            y_sizes.append(y_offsets[idx + 1] - y_offsets[idx] + overlap_y)

    offsets = []

    for idx_col, _ in enumerate(y_offsets):
        for idx_row, _ in enumerate(x_offsets):
            offsets.append([
                x_offsets[idx_row],
                y_offsets[idx_col],
                x_sizes[idx_row],
                y_sizes[idx_col],
            ])

    return offsets</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#generic-utility-functions">Generic utility functions</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buteo.utils" href="index.html">buteo.utils</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="buteo.utils.aux_utils.calculate_pixel_distances" href="#buteo.utils.aux_utils.calculate_pixel_distances">calculate_pixel_distances</a></code></li>
<li><code><a title="buteo.utils.aux_utils.channel_first_to_last" href="#buteo.utils.aux_utils.channel_first_to_last">channel_first_to_last</a></code></li>
<li><code><a title="buteo.utils.aux_utils.channel_last_to_first" href="#buteo.utils.aux_utils.channel_last_to_first">channel_last_to_first</a></code></li>
<li><code><a title="buteo.utils.aux_utils.create_grid" href="#buteo.utils.aux_utils.create_grid">create_grid</a></code></li>
<li><code><a title="buteo.utils.aux_utils.decode_latitude" href="#buteo.utils.aux_utils.decode_latitude">decode_latitude</a></code></li>
<li><code><a title="buteo.utils.aux_utils.decode_latlng" href="#buteo.utils.aux_utils.decode_latlng">decode_latlng</a></code></li>
<li><code><a title="buteo.utils.aux_utils.decode_latlngs" href="#buteo.utils.aux_utils.decode_latlngs">decode_latlngs</a></code></li>
<li><code><a title="buteo.utils.aux_utils.decode_longitude" href="#buteo.utils.aux_utils.decode_longitude">decode_longitude</a></code></li>
<li><code><a title="buteo.utils.aux_utils.encode_arr_position" href="#buteo.utils.aux_utils.encode_arr_position">encode_arr_position</a></code></li>
<li><code><a title="buteo.utils.aux_utils.encode_latitude" href="#buteo.utils.aux_utils.encode_latitude">encode_latitude</a></code></li>
<li><code><a title="buteo.utils.aux_utils.encode_latlng" href="#buteo.utils.aux_utils.encode_latlng">encode_latlng</a></code></li>
<li><code><a title="buteo.utils.aux_utils.encode_latlngs" href="#buteo.utils.aux_utils.encode_latlngs">encode_latlngs</a></code></li>
<li><code><a title="buteo.utils.aux_utils.encode_longitude" href="#buteo.utils.aux_utils.encode_longitude">encode_longitude</a></code></li>
<li><code><a title="buteo.utils.aux_utils.encode_width" href="#buteo.utils.aux_utils.encode_width">encode_width</a></code></li>
<li><code><a title="buteo.utils.aux_utils.fill_nodata_with_nearest_average" href="#buteo.utils.aux_utils.fill_nodata_with_nearest_average">fill_nodata_with_nearest_average</a></code></li>
<li><code><a title="buteo.utils.aux_utils.hsl_to_rgb" href="#buteo.utils.aux_utils.hsl_to_rgb">hsl_to_rgb</a></code></li>
<li><code><a title="buteo.utils.aux_utils.rgb_to_hsl" href="#buteo.utils.aux_utils.rgb_to_hsl">rgb_to_hsl</a></code></li>
<li><code><a title="buteo.utils.aux_utils.scale_to_range" href="#buteo.utils.aux_utils.scale_to_range">scale_to_range</a></code></li>
<li><code><a title="buteo.utils.aux_utils.single_hsl_to_rgb" href="#buteo.utils.aux_utils.single_hsl_to_rgb">single_hsl_to_rgb</a></code></li>
<li><code><a title="buteo.utils.aux_utils.single_hue_to_rgb" href="#buteo.utils.aux_utils.single_hue_to_rgb">single_hue_to_rgb</a></code></li>
<li><code><a title="buteo.utils.aux_utils.split_into_offsets" href="#buteo.utils.aux_utils.split_into_offsets">split_into_offsets</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>