<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>buteo.vector.zonal_statistics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buteo.vector.zonal_statistics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># &#34;&#34;&#34;
# Calculate zonal statistics from vector and raster files.

# BROKEN

# TODO: Fix zonal_statistics (implementation broken by 0.7)

# &#34;&#34;&#34;

# import sys; sys.path.append(&#34;../../&#34;) # Path: buteo/vector/zonal_statistics.py
# import numpy as np

# from numba import jit
# from osgeo import ogr

# from buteo.raster.core_raster import raster_to_array, raster_to_metadata
# from buteo.vector.rasterize import rasterize_vector
# from buteo.vector.reproject import reproject_vector
# from buteo.vector.core_vector import (
#     open_vector,
#     _vector_to_memory,
#     _vector_to_metadata,
# )
# from buteo.vector.zonal_statistics_stats import calculate_array_stats
# from buteo.utils.core_utils import progress



# import numpy as np
# from enum import Enum

# from numba import jit


# class stat(Enum):
#     count = 1
#     range = 2
#     min = 3
#     max = 4
#     sum = 5
#     mean = 6
#     avg = 6
#     average = 6
#     var = 7
#     variance = 7
#     std = 8
#     stdev = 8
#     standard_deviation = 8
#     skew = 9
#     kurtosis = 10
#     median = 11
#     med = 11
#     iqr = 12
#     q02 = 13
#     q98 = 14
#     q1 = 15
#     q3 = 16
#     mad = 17
#     median_absolute_deviation = 17
#     mode = 18
#     snr = 19
#     eff = 20
#     cv = 21


# @jit(nopython=True, parallel=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
# def calculate_array_stats(arr, stats):
#     stats_length = int(len(stats))
#     result = np.zeros((stats_length), dtype=&#34;float32&#34;)

#     for idx in range(stats_length):
#         if stat(stats[idx]) == 1:  # count
#             result[idx] = arr.size
#         elif stat(stats[idx]) == 2:  # range
#             result[idx] = np.ptp(arr)
#         elif stat(stats[idx]) == 3:  # min
#             result[idx] = np.min(arr)
#         elif stat(stats[idx]) == 4:  # max
#             result[idx] = np.max(arr)
#         elif stat(stats[idx]) == 5:  # sum
#             result[idx] = np.sum(arr)
#         elif stat(stats[idx]) == 6:  # mean
#             result[idx] = np.mean(arr)
#         elif stat(stats[idx]) == 7:  # var
#             result[idx] = np.var(arr)
#         elif stat(stats[idx]) == 8:  # std
#             result[idx] = np.std(arr)
#         elif stat(stats[idx]) == 9:  # skew
#             mean = np.mean(arr)
#             std = np.std(arr)
#             if std == 0:
#                 result[idx] = 0.0
#                 continue
#             deviations = np.sum(np.power(arr - mean, 3))
#             result[idx] = (deviations * (1 / arr.size)) / (np.power(std, 3))
#         elif stat(stats[idx]) == 10:  # kurt
#             mean = np.mean(arr)
#             std = np.std(arr)
#             if std == 0:
#                 result[idx] = 0.0
#                 continue
#             deviations = np.sum(np.power(arr - mean, 4))
#             result[idx] = (deviations * (1 / arr.size)) / (np.power(std, 4))
#         elif stat(stats[idx]) == 11:  # median
#             result[idx] = np.median(arr)
#         elif stat(stats[idx]) == 12:  # iqr
#             result[idx] = np.quantile(
#                 arr, np.array([0.25, 0.75], dtype=&#34;float32&#34;)
#             ).sum()
#         elif stat(stats[idx]) == 13:  # q02
#             result[idx] = np.quantile(arr, 0.02)
#         elif stat(stats[idx]) == 14:  # q92
#             result[idx] = np.quantile(arr, 0.98)
#         elif stat(stats[idx]) == 15:  # q1
#             result[idx] = np.quantile(arr, 0.25)
#         elif stat(stats[idx]) == 16:  # q3
#             result[idx] = np.quantile(arr, 0.75)
#         elif stat(stats[idx])== 17:  # mad
#             median = np.median(arr)
#             absdev = np.abs(arr - median)
#             result[idx] = np.median(absdev)
#         elif stat(stats[idx]) == 18:  # mode
#             uniques = np.unique(arr)
#             counts = np.zeros_like(uniques, dtype=&#34;uint64&#34;)

#             # numba does not support return count of uniques.
#             for idx_values in range(len(arr)):
#                 val = arr[idx_values]
#                 for idx_uniques in range(len(uniques)):
#                     if val == uniques[idx_uniques]:
#                         counts[idx_uniques] = counts[idx_uniques] + 1
#             index = np.argmax(counts)
#             result[idx] = uniques[index]
#         elif stat(stats[idx]) == 19:  # snr
#             std = np.std(arr)
#             if std == 0:
#                 result[idx] = 0.0
#                 continue
#             result[idx] = np.mean(arr) / std
#         elif stat(stats[idx]) == 20:  # eff
#             mean = np.mean(arr)
#             if mean == 0:
#                 result[idx] = 0.0
#                 continue
#             result[idx] = np.var(arr) / np.power(mean, 2)
#         elif stat(stats[idx]) == 21:  # cv
#             mean = np.mean(arr)
#             if mean == 0:
#                 result[idx] = 0.0
#                 continue
#             result[idx] = np.std(arr) / mean

#     return result

# @jit(nopython=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
# def overlap_size_calc(extent, raster_transform):
#     return np.array(
#         [
#             (extent[1] - extent[0]) / raster_transform[1],
#             (extent[3] - extent[2]) / abs(raster_transform[5]),
#         ],
#         dtype=np.int32,
#     )


# @jit(nopython=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
# def align_extent(raster_transform, vector_extent, raster_size):
#     pixel_width = abs(raster_transform[1])
#     pixel_height = abs(raster_transform[5])

#     raster_min_x = raster_transform[0]
#     # raster_max_x = raster_min_x + (raster_size[0] * pixel_width)
#     raster_max_y = raster_transform[3]
#     raster_min_y = raster_max_y + (raster_size[1] * -pixel_width)

#     vector_min_x = vector_extent[0]
#     vector_max_x = vector_extent[1]
#     vector_min_y = vector_extent[2]
#     vector_max_y = vector_extent[3]

#     # Align the two extents
#     vector_min_x = vector_min_x - (vector_min_x - raster_min_x) % pixel_width
#     vector_max_x = vector_max_x + (vector_max_x - raster_min_x) % pixel_width
#     vector_min_y = vector_min_y - (vector_min_y - raster_max_y) % pixel_height
#     vector_max_y = vector_max_y + (vector_max_y - raster_max_y) % pixel_height

#     rasterized_x_size = int((vector_max_x - vector_min_x) / pixel_width)
#     rasterized_y_size = int((vector_max_y - vector_min_y) / pixel_height)

#     rasterized_x_offset = int((vector_min_x - raster_min_x) / pixel_width)
#     rasterized_y_offset = (
#         int(raster_size[1] - int((vector_min_y - raster_min_y) / pixel_height))
#         - rasterized_y_size
#     )

#     if rasterized_x_offset &lt; 0:
#         rasterized_x_offset = 0

#     if rasterized_y_offset &lt; 0:
#         rasterized_y_offset = 0

#     if (rasterized_x_offset + rasterized_x_size) &gt; raster_size[0]:
#         rasterized_x_offset = rasterized_x_offset - (
#             (rasterized_x_offset + rasterized_x_size) - raster_size[0]
#         )

#     if (rasterized_y_offset + rasterized_y_size) &gt; raster_size[1]:
#         rasterized_y_offset = rasterized_y_offset - (
#             (rasterized_y_offset + rasterized_y_size) - raster_size[1]
#         )

#     new_vector_extent = np.array(
#         [vector_min_x, vector_max_x, vector_min_y, vector_max_y], dtype=np.float32
#     )
#     rasterized_size = np.array(
#         [rasterized_x_size, rasterized_y_size, pixel_width, pixel_height],
#         dtype=np.float32,
#     )
#     offset = np.array([rasterized_x_offset, rasterized_y_offset], dtype=np.int32)

#     return new_vector_extent, rasterized_size, offset


# @jit(nopython=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
# def get_intersection(extent1, extent2):
#     one_bottomLeftX = extent1[0]
#     one_topRightX = extent1[1]
#     one_bottomLeftY = extent1[2]
#     one_topRightY = extent1[3]

#     two_bottomLeftX = extent2[0]
#     two_topRightX = extent2[1]
#     two_bottomLeftY = extent2[2]
#     two_topRightY = extent2[3]

#     if two_bottomLeftX &gt; one_topRightX:  # Too far east
#         return np.array([0, 0, 0, 0], dtype=np.float32)
#     elif two_bottomLeftY &gt; one_topRightY:  # Too far north
#         return np.array([0, 0, 0, 0], dtype=np.float32)
#     elif two_topRightX &lt; one_bottomLeftX:  # Too far west
#         return np.array([0, 0, 0, 0], dtype=np.float32)
#     elif two_topRightY &lt; one_bottomLeftY:  # Too far south
#         return np.array([0, 0, 0, 0], dtype=np.float32)
#     else:

#         x_min = (
#             one_bottomLeftX if one_bottomLeftX &gt; two_bottomLeftX else two_bottomLeftX
#         )
#         x_max = one_topRightX if one_topRightX &lt; two_topRightX else two_topRightX
#         y_min = (
#             one_bottomLeftY if one_bottomLeftY &gt; two_bottomLeftY else two_bottomLeftY
#         )
#         y_max = one_topRightY if one_topRightY &lt; two_topRightY else two_topRightY

#         return np.array([x_min, x_max, y_min, y_max], dtype=np.float32)


# @jit(nopython=True, nogil=True, fastmath=True, inline=&#34;always&#34;)
# def get_extent(raster_transform, raster_size):
#     bottomRightX = raster_transform[0] + (raster_size[0] * raster_transform[1])
#     bottomRightY = raster_transform[3] + (raster_size[1] * raster_transform[5])

#     return np.array(
#         [raster_transform[0], bottomRightX, bottomRightY, raster_transform[3]],
#         dtype=np.float32,
#     )


# def zonal_statistics(
#     in_vector,
#     output_vector=None,
#     in_rasters=[],
#     prefixes=[],
#     stats=None,
# ):
#     &#34;&#34;&#34;
#     ZonalStatistics.
#     &#34;&#34;&#34;
#     default_stats = [&#34;mean&#34;, &#34;med&#34;, &#34;std&#34;]

#     if stats is None:
#         stats = default_stats

#     if len(prefixes) != 0:
#         if len(in_rasters) != len(prefixes):
#             raise ValueError(&#34;Unable to parse prefixes.&#34;)

#     if isinstance(in_rasters, list):
#         if len(in_rasters) == 0:
#             raise ValueError(&#34;List of rasters (in_rasters) is empty.&#34;)

#     if len(stats) == 0:
#         raise ValueError(&#34;Unable to parse statistics (stats).&#34;)

#     # Read the raster meta:
#     raster_metadata = raster_to_metadata(in_rasters[0])

#     vector = None
#     if output_vector is None:
#         vector = open_vector(in_vector, writeable=True)
#     else:
#         vector = _vector_to_memory(in_vector)

#     vector_metadata = _vector_to_metadata(vector)
#     vector_layer = vector.GetLayer()

#     # Check that projections match
#     if not vector_metadata[&#34;projection_osr&#34;].IsSame(raster_metadata[&#34;projection_osr&#34;]):
#         if output_vector is None:
#             vector = reproject_vector(in_vector, in_rasters[0])
#         else:
#             vector_path = reproject_vector(
#                 in_vector, in_rasters[0], output_vector
#             )
#             vector = open_vector(vector_path, writeable=True)

#         vector_metadata = _vector_to_metadata(vector)
#         vector_layer = vector.GetLayer()

#     vector_projection = vector_metadata[&#34;projection_osr&#34;]
#     raster_projection = raster_metadata[&#34;projection_osr&#34;]

#     # Read raster data in overlap
#     raster_transform = np.array(raster_metadata[&#34;transform&#34;], dtype=np.float32)
#     raster_size = np.array(raster_metadata[&#34;size&#34;], dtype=np.int32)

#     raster_extent = get_extent(raster_transform, raster_size)

#     vector_extent = np.array(vector_layer.GetExtent(), dtype=np.float32)
#     overlap_extent = get_intersection(raster_extent, vector_extent)

#     if overlap_extent is False:
#         print(&#34;raster_extent: &#34;, raster_extent)
#         print(&#34;vector_extent: &#34;, vector_extent)
#         raise Exception(&#34;Vector and raster do not overlap!&#34;)

#     (
#         overlap_aligned_extent,
#         overlap_aligned_rasterized_size,
#         overlap_aligned_offset,
#     ) = align_extent(raster_transform, overlap_extent, raster_size)
#     overlap_transform = np.array(
#         [
#             overlap_aligned_extent[0],
#             raster_transform[1],
#             0,
#             overlap_aligned_extent[3],
#             0,
#             raster_transform[5],
#         ],
#         dtype=np.float32,
#     )
#     overlap_size = overlap_size_calc(overlap_aligned_extent, raster_transform)

#     # Loop the features
#     vector_driver = ogr.GetDriverByName(&#34;Memory&#34;)
#     vector_feature_count = vector_layer.GetFeatureCount()
#     vector_layer.StartTransaction()

#     # Create fields
#     vector_layer_defn = vector_layer.GetLayerDefn()
#     vector_field_counts = vector_layer_defn.GetFieldCount()
#     vector_current_fields = []

#     # Get current fields
#     for i in range(vector_field_counts):
#         vector_current_fields.append(vector_layer_defn.GetFieldDefn(i).GetName())

#     # Add fields where missing
#     for stat in stats:
#         for i in range(len(in_rasters)):
#             field_name = f&#34;{prefixes[i]}{stat}&#34;
#             if field_name not in vector_current_fields:
#                 field_defn = ogr.FieldDefn(field_name, ogr.OFTReal)
#                 vector_layer.CreateField(field_defn)

#     rasterized_features = []
#     sizes = np.zeros((vector_feature_count, 4), dtype=&#34;float32&#34;)
#     offsets = np.zeros((vector_feature_count, 2), dtype=np.int32)
#     raster_data = None
#     for raster_index, raster_value in enumerate(in_rasters):

#         columns = {}
#         for stat in stats:
#             columns[prefixes[raster_index] + stat] = []

#         fits_in_memory = True
#         try:
#             raster_data = raster_to_array(
#                 raster_value,
#                 pixel_offsets=[
#                     overlap_aligned_offset[0],
#                     overlap_aligned_offset[1],
#                     overlap_aligned_rasterized_size[0],
#                     overlap_aligned_rasterized_size[1],
#                 ],
#             )
#         except:
#             fits_in_memory = False
#             print(&#34;Raster does not fit in memory.. Doing IO for each feature.&#34;)

#         for n in range(vector_feature_count):
#             vector_feature = vector_layer.GetNextFeature()
#             rasterized_vector = None

#             if raster_index == 0:

#                 try:
#                     vector_geom = vector_feature.GetGeometryRef()
#                 except:
#                     vector_geom.Buffer(0)
#                     Warning(&#34;Invalid geometry at : &#34;, n)

#                 if vector_geom is None:
#                     raise Exception(&#34;Invalid geometry. Could not fix.&#34;)

#                 feature_extent = vector_geom.GetEnvelope()

#                 # Create temp layer
#                 temp_vector_datasource = vector_driver.CreateDataSource(f&#34;vector_{n}&#34;)
#                 temp_vector_layer = temp_vector_datasource.CreateLayer(
#                     &#34;temp_polygon&#34;, vector_projection, ogr.wkbPolygon
#                 )
#                 temp_vector_layer.CreateFeature(vector_feature.Clone())

#                 (
#                     feature_aligned_extent,
#                     feature_aligned_rasterized_size,
#                     feature_aligned_offset,
#                 ) = align_extent(overlap_transform, feature_extent, overlap_size)

#                 rasterized_vector = None
#                 # rasterized_vector = rasterize_vector(
#                 #     temp_vector_layer,
#                 #     feature_aligned_extent,
#                 #     feature_aligned_rasterized_size,
#                 #     raster_projection,
#                 # )
#                 rasterized_features.append(rasterized_vector)

#                 offsets[n] = feature_aligned_offset
#                 sizes[n] = feature_aligned_rasterized_size

#             if fits_in_memory is True:
#                 cropped_raster = raster_data[
#                     offsets[n][1] : offsets[n][1] + int(sizes[n][1]),  # X
#                     offsets[n][0] : offsets[n][0] + int(sizes[n][0]),  # Y
#                 ]
#             else:
#                 cropped_raster = raster_to_array(
#                     raster_value,
#                     pixel_offsets=[
#                         overlap_aligned_offset[0] + offsets[n][0],
#                         overlap_aligned_offset[1] + offsets[n][1],
#                         int(sizes[n][0]),
#                         int(sizes[n][1]),
#                     ],
#                 )

#             if rasterized_features[n] is None:
#                 for stat in stats:
#                     field_name = f&#34;{prefixes[raster_index]}{stat}&#34;
#                     vector_feature.SetField(field_name, None)
#             elif cropped_raster is None:
#                 for stat in stats:
#                     field_name = f&#34;{prefixes[raster_index]}{stat}&#34;
#                     vector_feature.SetField(field_name, None)
#             else:
#                 raster_data_masked = np.ma.masked_array(
#                     cropped_raster, mask=rasterized_features[n], dtype=&#34;float32&#34;
#                 ).compressed()
#                 zonal_stats = calculate_array_stats(
#                     raster_data_masked, stats
#                 )

#                 for index, stat in enumerate(stats):
#                     field_name = f&#34;{prefixes[raster_index]}{stat}&#34;
#                     vector_feature.SetField(field_name, float(zonal_stats[index]))

#                 vector_layer.SetFeature(vector_feature)

#             progress(n, vector_feature_count, name=prefixes[raster_index])

#         vector_layer.ResetReading()

#     vector_layer.CommitTransaction()

#     if output_vector is None:
#         return vector

#     return output_vector</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buteo.vector" href="index.html">buteo.vector</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>