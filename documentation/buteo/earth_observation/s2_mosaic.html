<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>buteo.earth_observation.s2_mosaic API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>buteo.earth_observation.s2_mosaic</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys
import os
import zipfile
import datetime
import numpy as np
from glob import glob
from time import time

sys.path.append(&#34;../../&#34;)

from buteo.raster.reproject import reproject_raster
from buteo.raster.resample import internal_resample_raster
from buteo.raster.io import raster_to_array, array_to_raster
from buteo.raster.clip import clip_raster
from buteo.earth_observation.s2_utils import (
    get_tile_files_from_safe,
    get_metadata,
    get_all_tiles_in_folder,
)
from buteo.earth_observation.s2_quality_assessment import (
    assess_quality,
    smooth_mask,
    erode_mask,
    feather,
)
from buteo.gdal_utils import destroy_raster
from buteo.utils import timing
from buteo.orfeo_toolbox import merge_rasters


def resample_array(arr, original_reference, target_reference, resample_alg=&#34;average&#34;):
    return raster_to_array(
        internal_resample_raster(
            array_to_raster(
                arr,
                reference=original_reference,
            ),
            target_size=target_reference,
            resample_alg=resample_alg,
        ),
        filled=True,
        output_2d=True,
    )


def harmonise_band(
    slave_arr,
    metadata,
    size,
    name,
    master_arr,
    master_quality,
    max_harmony=50,
    quality_to_include=75,
    method=&#34;mean_std_match&#34;,
):
    slave_quality = resample_array(
        metadata[&#34;quality&#34;],
        metadata[&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
        metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
    )
    slave_raster = internal_resample_raster(
        metadata[&#34;paths&#34;][size][name], target_size=metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;]
    )
    slave_arr_60 = raster_to_array(slave_raster, output_2d=True, filled=True)
    destroy_raster(slave_raster)

    overlap = np.logical_and(
        master_quality &gt; quality_to_include, slave_quality &gt; quality_to_include
    )

    if overlap.sum() &lt; 100:
        overlap = slave_quality &gt; quality_to_include
    if overlap.sum() &lt; 100:
        overlap = np.ones_like(overlap)

    slave_arr_60 = slave_arr_60[overlap]
    slave_quality_60 = slave_quality[overlap]

    master_arr_60 = master_arr[overlap]
    master_quality_60 = master_quality[overlap]

    if method == &#34;mean_std_match&#34;:
        slave_med = np.ma.average(slave_arr_60, weights=slave_quality_60)
        slave_std = np.ma.sqrt(
            np.ma.average((slave_arr_60 - slave_med) ** 2, weights=slave_quality_60)
        )

        master_med = np.ma.average(master_arr_60, weights=master_quality_60)
        master_std = np.ma.sqrt(
            np.ma.average((master_arr_60 - master_med) ** 2, weights=master_quality_60)
        )
    else:
        slave_med = np.ma.median(slave_arr_60)
        slave_absdev = np.ma.abs(np.ma.subtract(slave_arr_60, slave_med))
        slave_std = np.ma.multiply(np.ma.median(slave_absdev), 1.4826)

        master_med = np.ma.median(master_arr_60)
        master_absdev = np.ma.abs(np.ma.subtract(master_arr_60, master_med))
        master_std = np.ma.multiply(np.ma.median(master_absdev), 1.4826)

    with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
        harmony = master_med + (slave_arr - slave_med) * (master_std / slave_std)

    if max_harmony != 0:
        negative_limit = slave_arr * (1 - (max_harmony / 100))
        positive_limit = slave_arr * (1 + (max_harmony / 100))
    else:
        negative_limit = np.zeros_like(slave_arr)
        positive_limit = np.full_like(slave_arr, 65534.0)

    negative_limit = np.where(negative_limit &lt; 0, 0, negative_limit)
    positive_limit = np.where(positive_limit &gt; 65534.0, 65534.0, positive_limit)

    ret_arr = np.where(
        harmony &lt; negative_limit,
        negative_limit,
        np.where(harmony &gt; positive_limit, positive_limit, harmony),
    )

    return ret_arr


def files_to_tiles(files):
    tiles = []
    for file in files:
        basename = os.path.basename(file)
        name, ext = os.path.splitext(basename)

        try:
            if ext == &#34;.SAFE&#34; or ext == &#34;.zip&#34;:
                tile_name = name.split(&#34;_&#34;)[-2][1:]
                tiles.append(tile_name)
            else:
                raise Exception(&#34;Unknown file type: {}&#34;.format(file))
        except:
            raise Exception(&#34;Error while parsing file: {}&#34;.format(file))

    tile_arr = []
    tiles = set(tiles)
    for tile in tiles:
        tile_arr.append(tile)

    return tile_arr


def files_to_unzipped_paths(files, tmp_folder):
    unzipped_paths = []
    for file in files:
        basename = os.path.basename(file)
        name, ext = os.path.splitext(basename)
        if ext == &#34;.SAFE&#34;:
            unzipped_paths.append(file)
        elif ext == &#34;.zip&#34;:
            with zipfile.ZipFile(file, &#34;r&#34;) as zip_ref:
                zip_ref.extractall(tmp_folder)
            unzipped_paths.append(os.path.join(tmp_folder, name))
        else:
            raise Exception(&#34;Unknown file type: {}&#34;.format(file))

    return unzipped_paths


def get_tile_files_from_paths(paths, tile):
    tile_paths = []

    try:
        for path in paths:
            basename = os.path.basename(path)
            name, ext = os.path.splitext(basename)
            if ext != &#34;.SAFE&#34;:
                raise Exception(&#34;Unknown file type: {}&#34;.format(path))

            tile_name = name.split(&#34;_&#34;)[-2][1:]
            if tile_name == tile:
                tile_paths.append(path)
    except:
        raise Exception(&#34;Error while parsing file: {}&#34;.format(path))

    return tile_paths


def mosaic_tile_s2(
    s2_files,
    out_folder,
    tmp_folder,
    ideal_date=None,
    max_time_delta=60.0,
    max_images=6,
    tile_name=None,
    quality_to_update=5,
    min_improvement=0.5,
    time_penalty=7,
    feather_dist=11,
    use_image=None,
    harmonise=True,
    max_harmony=50,
    quality_threshold=105,
    output_scl=False,
    output_tracking=False,
    output_quality=False,
    process_bands=None,
    clean_tmp_folder=False,
):
    start = time()

    tile_names = files_to_tiles(s2_files)
    unzipped_paths = files_to_unzipped_paths(s2_files, tmp_folder)

    created_images = []
    for tile_name in tile_names:
        tiles = get_tile_files_from_paths(unzipped_paths, tile_name)

        metadatas = []
        best_score = 0
        best_idx = 0
        best_date = None
        best_time = 9999999999.9

        for index, tile in enumerate(tiles):
            print(
                f&#34;Finding best image for tile: {tile_name}. {index + 1}/{len(tiles)} images&#34;
            )
            metadata = get_metadata(tile)
            quality = assess_quality(tile)
            tile_score = np.average(quality)
            metadata[&#34;quality_score&#34;] = tile_score

            if ideal_date is not None or use_image is not None:
                comp_time = None
                if use_image is not None:
                    comp_time = use_image
                else:
                    comp_time = ideal_date

                time_delta = abs(
                    (
                        metadata[&#34;PRODUCT_STOP_TIME&#34;]
                        - datetime.datetime.strptime(comp_time, &#34;%Y%m%d&#34;).replace(
                            tzinfo=datetime.timezone.utc
                        )
                    ).total_seconds()
                    / 86400
                )

            quality_adjustment = 1
            if ideal_date is not None:
                # 1 % reduction in quality for every x days.
                quality_adjustment = (100 - time_delta / time_penalty) / 100

            if use_image:
                if time_delta &lt; best_time:
                    best_score = tile_score
                    best_idx = index
                    best_date = metadata[&#34;PRODUCT_STOP_TIME&#34;]
                    best_time = time_delta
            elif (tile_score * quality_adjustment) &gt; best_score:
                best_score = tile_score
                best_idx = index
                best_date = metadata[&#34;PRODUCT_STOP_TIME&#34;]

            metadata[&#34;quality&#34;] = quality
            metadatas.append(metadata)

        print(
            f&#34;Best image found: {os.path.basename(tiles[best_idx])} @ {round(best_score, 3)}&#34;
        )

        metadatas_thresholded = []
        print(&#34;Adjusting scores by temporal distance.&#34;)
        for index, tile in enumerate(tiles):
            metadata = metadatas[index]
            recording_time = metadata[&#34;PRODUCT_STOP_TIME&#34;]

            time_delta = abs((best_date - recording_time).total_seconds() / 86400)

            # 1 % reduction in quality for every x days.
            quality_adjustment = (100 - time_delta / time_penalty) / 100

            metadatas[index][&#34;quality&#34;] = np.rint(
                (metadatas[index][&#34;quality&#34;].astype(&#34;float32&#34;) * quality_adjustment)
            ).astype(&#34;uint8&#34;)
            metadatas[index][&#34;quality_score&#34;] = np.average(metadatas[index][&#34;quality&#34;])

            if time_delta &lt; max_time_delta:
                metadatas_thresholded.append(metadatas[index])

        # Ordering metadatas by quality
        metadatas = metadatas_thresholded
        metadatas = sorted(metadatas, key=lambda i: i[&#34;quality_score&#34;], reverse=True)

        # if central_images, move it to the front
        if use_image is not None:
            for index, meta in enumerate(metadatas):
                if meta[&#34;PRODUCT_STOP_TIME&#34;] == best_date:
                    metadatas.insert(0, metadatas.pop(index))
                    break

        scl_array = raster_to_array(
            metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;], filled=True, output_2d=True
        )
        tracking_array = np.zeros_like(scl_array, dtype=&#34;uint8&#34;)

        current_valid_mask = erode_mask(scl_array != 0, feather_dist)
        current_quality = metadatas[0][&#34;quality&#34;] * current_valid_mask
        current_quality_score = np.average(current_quality)

        print(&#34;Tracking..&#34;)
        print(f&#34;Current quality: {round(current_quality_score, 4)}&#34;)
        used_images = [0]
        tested_images = 1
        while (
            current_quality_score &lt; quality_threshold
            and len(used_images) &lt; max_images
            and tested_images &lt; len(metadatas)
        ):

            best_idx = None
            best_improvement = None
            best_valid_sum = None
            best_tile_quality = None
            best_tile_scl = None
            best_improvement_mask = None

            first = True
            for index, metadata in enumerate(metadatas):
                if index in used_images:
                    continue

                tile_quality = metadata[&#34;quality&#34;]
                tile_scl = raster_to_array(
                    metadata[&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;], filled=True, output_2d=True
                )

                valid_mask = erode_mask(tile_scl != 0, feather_dist)

                improvement_mask = valid_mask &amp; smooth_mask(
                    tile_quality &gt; (current_quality * (1 + (quality_to_update / 100)))
                )
                improvement_percent = np.average(improvement_mask) * 100

                if first:
                    best_idx = index
                    best_improvement = improvement_percent
                    best_valid_sum = valid_mask.sum()
                    best_tile_quality = tile_quality
                    best_tile_scl = tile_scl
                    best_improvement_mask = improvement_mask
                    first = False
                else:
                    if improvement_percent &gt; best_improvement:
                        best_idx = index
                        best_improvement = improvement_percent
                        best_valid_sum = valid_mask.sum()
                        best_tile_quality = tile_quality
                        best_tile_scl = tile_scl
                        best_improvement_mask = improvement_mask

            tile_quality = np.where(
                best_improvement_mask, best_tile_quality, current_quality
            )
            tile_quality_score = np.average(tile_quality)

            if (tile_quality_score - current_quality_score) &lt; min_improvement and (
                best_valid_sum &lt;= current_valid_mask.sum()
            ):
                break

            # Update tracking arrays
            tracking_array = np.where(best_improvement_mask, best_idx, tracking_array)
            scl_array = np.where(best_improvement_mask, best_tile_scl, scl_array)
            current_quality = tile_quality
            current_quality_score = tile_quality_score
            used_images.append(best_idx)
            tested_images += 1

            print(f&#34;Current quality: {round(current_quality_score, 4)}&#34;)

        bands_to_process = (
            [
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B02&#34;},
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B03&#34;},
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B04&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B05&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B06&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B07&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B8A&#34;},
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B08&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B11&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B12&#34;},
            ]
            if process_bands is None
            else process_bands
        )

        if len(used_images) &gt; 1:
            print(&#34;Pre-calculating feathers&#34;)
            tracking_20m = feather(
                tracking_array, np.array(used_images, dtype=&#34;uint8&#34;), feather_dist
            )

            tracking_10m = raster_to_array(
                internal_resample_raster(
                    array_to_raster(
                        tracking_20m, reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;]
                    ),
                    target_size=metadatas[0][&#34;paths&#34;][&#34;10m&#34;][&#34;B04&#34;],
                    resample_alg=&#34;average&#34;,
                ),
                filled=True,
            )

            tracking_60m = raster_to_array(
                internal_resample_raster(
                    array_to_raster(
                        tracking_20m, reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;]
                    ),
                    target_size=metadatas[0][&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
                    resample_alg=&#34;average&#34;,
                ),
                filled=True,
            )

        print(&#34;Harmonising and merging tiles&#34;)
        for pi, process_band in enumerate(bands_to_process):
            size = process_band[&#34;size&#34;]
            name = process_band[&#34;band&#34;]
            tile_outname = out_folder + f&#34;{tile_name}_{name}_{size}.tif&#34;

            print(f&#34;Now processing {pi + 1}/{len(bands_to_process)}: {name} @ {size}&#34;)

            out_arr = None

            master_arr = None
            master_quality = None
            for index, image in enumerate(used_images):
                metadata = metadatas[image]

                band_arr = raster_to_array(
                    metadata[&#34;paths&#34;][size][name], filled=True, output_2d=True
                )

                if len(used_images) == 1:
                    out_arr = band_arr
                    continue

                if harmonise and index == 0:
                    master_arr = resample_array(
                        band_arr,
                        metadata[&#34;paths&#34;][size][&#34;B04&#34;],
                        metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
                    )
                    master_quality = resample_array(
                        metadata[&#34;quality&#34;],
                        metadata[&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                        metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
                    )

                if harmonise and index != 0:

                    band_arr = harmonise_band(
                        band_arr,
                        metadata,
                        size,
                        name,
                        master_arr,
                        master_quality,
                        max_harmony=max_harmony,
                    )

                feather_scale = None
                if size == &#34;10m&#34;:
                    feather_scale = tracking_10m[:, :, index]
                elif size == &#34;20m&#34;:
                    feather_scale = tracking_20m[:, :, index]
                elif size == &#34;60m&#34;:
                    feather_scale = tracking_60m[:, :, index]
                else:
                    raise Exception(&#34;Unknown band size.&#34;)

                if index == 0:
                    out_arr = feather_scale * band_arr
                else:
                    out_arr += feather_scale * band_arr

            ref = None
            if size == &#34;10m&#34;:
                ref = metadatas[0][&#34;paths&#34;][&#34;10m&#34;][&#34;B04&#34;]
            elif size == &#34;20m&#34;:
                ref = metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;B04&#34;]
            elif size == &#34;60m&#34;:
                ref = metadatas[0][&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;]

            created_images.append(tile_outname)

            array_to_raster(
                np.rint(out_arr).astype(&#34;uint16&#34;),
                reference=ref,
                out_path=tile_outname,
            )

        if output_tracking:
            tracking_outname = out_folder + f&#34;{tile_name}_tracking_20m.tif&#34;
            created_images.append(tracking_outname)
            array_to_raster(
                tracking_array,
                reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                out_path=tracking_outname,
            )

        if output_scl:
            scl_outname = out_folder + f&#34;{tile_name}_SCL_20m.tif&#34;
            created_images.append(scl_outname)
            array_to_raster(
                scl_array,
                reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                out_path=scl_outname,
            )

        if output_quality:
            quality_outname = out_folder + f&#34;{tile_name}_quality_20m.tif&#34;
            created_images.append(quality_outname)
            array_to_raster(
                current_quality,
                reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                out_path=quality_outname,
            )

        timing(start)

    if clean_tmp_folder:
        tmp_files = glob(tmp_folder + &#34;*.tif&#34;)
        for f in tmp_files:
            try:
                os.remove(f)
            except:
                pass

    return created_images


def join_s2_tiles(
    mosaic_tile_folder,
    out_folder,
    tmp_dir,
    prefix=&#34;&#34;,
    clip_geom=None,
    harmonisation=False,
    nodata_value=0.0,
    pixel_width=None,
    pixel_height=None,
    bands_to_process=None,
    projection_to_match=25832,
    clean=False,
):
    bands = (
        [
            &#34;B02_10m&#34;,
            &#34;B03_10m&#34;,
            &#34;B04_10m&#34;,
            &#34;B08_10m&#34;,
            &#34;B05_20m&#34;,
            &#34;B06_20m&#34;,
            &#34;B07_20m&#34;,
            &#34;B8A_20m&#34;,
            &#34;B11_20m&#34;,
            &#34;B12_20m&#34;,
        ]
        if bands_to_process is None
        else bands_to_process
    )

    created = []
    for band in bands:
        images = glob(mosaic_tile_folder + f&#34;*_{band}.tif&#34;)

        reprojected = reproject_raster(
            images,
            projection_to_match,
            tmp_dir,
            copy_if_already_correct=False,
            dst_nodata=nodata_value,
        )

        if clip_geom is not None:
            reprojected = clip_raster(
                reprojected, clip_geom, out_path=tmp_dir, crop_to_geom=False
            )

        output = merge_rasters(
            reprojected,
            out_folder + prefix + band + &#34;.tif&#34;,
            tmp=tmp_dir,
            harmonisation=harmonisation,
            nodata_value=nodata_value,
            pixel_width=pixel_width,
            pixel_height=pixel_height,
        )

        created.append(output)

    if clean:
        tmp_files = glob(tmp_dir + &#34;*.tif&#34;)
        for f in tmp_files:
            try:
                os.remove(f)
            except:
                pass

    return created</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="buteo.earth_observation.s2_mosaic.files_to_tiles"><code class="name flex">
<span>def <span class="ident">files_to_tiles</span></span>(<span>files)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_to_tiles(files):
    tiles = []
    for file in files:
        basename = os.path.basename(file)
        name, ext = os.path.splitext(basename)

        try:
            if ext == &#34;.SAFE&#34; or ext == &#34;.zip&#34;:
                tile_name = name.split(&#34;_&#34;)[-2][1:]
                tiles.append(tile_name)
            else:
                raise Exception(&#34;Unknown file type: {}&#34;.format(file))
        except:
            raise Exception(&#34;Error while parsing file: {}&#34;.format(file))

    tile_arr = []
    tiles = set(tiles)
    for tile in tiles:
        tile_arr.append(tile)

    return tile_arr</code></pre>
</details>
</dd>
<dt id="buteo.earth_observation.s2_mosaic.files_to_unzipped_paths"><code class="name flex">
<span>def <span class="ident">files_to_unzipped_paths</span></span>(<span>files, tmp_folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def files_to_unzipped_paths(files, tmp_folder):
    unzipped_paths = []
    for file in files:
        basename = os.path.basename(file)
        name, ext = os.path.splitext(basename)
        if ext == &#34;.SAFE&#34;:
            unzipped_paths.append(file)
        elif ext == &#34;.zip&#34;:
            with zipfile.ZipFile(file, &#34;r&#34;) as zip_ref:
                zip_ref.extractall(tmp_folder)
            unzipped_paths.append(os.path.join(tmp_folder, name))
        else:
            raise Exception(&#34;Unknown file type: {}&#34;.format(file))

    return unzipped_paths</code></pre>
</details>
</dd>
<dt id="buteo.earth_observation.s2_mosaic.get_tile_files_from_paths"><code class="name flex">
<span>def <span class="ident">get_tile_files_from_paths</span></span>(<span>paths, tile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tile_files_from_paths(paths, tile):
    tile_paths = []

    try:
        for path in paths:
            basename = os.path.basename(path)
            name, ext = os.path.splitext(basename)
            if ext != &#34;.SAFE&#34;:
                raise Exception(&#34;Unknown file type: {}&#34;.format(path))

            tile_name = name.split(&#34;_&#34;)[-2][1:]
            if tile_name == tile:
                tile_paths.append(path)
    except:
        raise Exception(&#34;Error while parsing file: {}&#34;.format(path))

    return tile_paths</code></pre>
</details>
</dd>
<dt id="buteo.earth_observation.s2_mosaic.harmonise_band"><code class="name flex">
<span>def <span class="ident">harmonise_band</span></span>(<span>slave_arr, metadata, size, name, master_arr, master_quality, max_harmony=50, quality_to_include=75, method='mean_std_match')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def harmonise_band(
    slave_arr,
    metadata,
    size,
    name,
    master_arr,
    master_quality,
    max_harmony=50,
    quality_to_include=75,
    method=&#34;mean_std_match&#34;,
):
    slave_quality = resample_array(
        metadata[&#34;quality&#34;],
        metadata[&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
        metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
    )
    slave_raster = internal_resample_raster(
        metadata[&#34;paths&#34;][size][name], target_size=metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;]
    )
    slave_arr_60 = raster_to_array(slave_raster, output_2d=True, filled=True)
    destroy_raster(slave_raster)

    overlap = np.logical_and(
        master_quality &gt; quality_to_include, slave_quality &gt; quality_to_include
    )

    if overlap.sum() &lt; 100:
        overlap = slave_quality &gt; quality_to_include
    if overlap.sum() &lt; 100:
        overlap = np.ones_like(overlap)

    slave_arr_60 = slave_arr_60[overlap]
    slave_quality_60 = slave_quality[overlap]

    master_arr_60 = master_arr[overlap]
    master_quality_60 = master_quality[overlap]

    if method == &#34;mean_std_match&#34;:
        slave_med = np.ma.average(slave_arr_60, weights=slave_quality_60)
        slave_std = np.ma.sqrt(
            np.ma.average((slave_arr_60 - slave_med) ** 2, weights=slave_quality_60)
        )

        master_med = np.ma.average(master_arr_60, weights=master_quality_60)
        master_std = np.ma.sqrt(
            np.ma.average((master_arr_60 - master_med) ** 2, weights=master_quality_60)
        )
    else:
        slave_med = np.ma.median(slave_arr_60)
        slave_absdev = np.ma.abs(np.ma.subtract(slave_arr_60, slave_med))
        slave_std = np.ma.multiply(np.ma.median(slave_absdev), 1.4826)

        master_med = np.ma.median(master_arr_60)
        master_absdev = np.ma.abs(np.ma.subtract(master_arr_60, master_med))
        master_std = np.ma.multiply(np.ma.median(master_absdev), 1.4826)

    with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
        harmony = master_med + (slave_arr - slave_med) * (master_std / slave_std)

    if max_harmony != 0:
        negative_limit = slave_arr * (1 - (max_harmony / 100))
        positive_limit = slave_arr * (1 + (max_harmony / 100))
    else:
        negative_limit = np.zeros_like(slave_arr)
        positive_limit = np.full_like(slave_arr, 65534.0)

    negative_limit = np.where(negative_limit &lt; 0, 0, negative_limit)
    positive_limit = np.where(positive_limit &gt; 65534.0, 65534.0, positive_limit)

    ret_arr = np.where(
        harmony &lt; negative_limit,
        negative_limit,
        np.where(harmony &gt; positive_limit, positive_limit, harmony),
    )

    return ret_arr</code></pre>
</details>
</dd>
<dt id="buteo.earth_observation.s2_mosaic.join_s2_tiles"><code class="name flex">
<span>def <span class="ident">join_s2_tiles</span></span>(<span>mosaic_tile_folder, out_folder, tmp_dir, prefix='', clip_geom=None, harmonisation=False, nodata_value=0.0, pixel_width=None, pixel_height=None, bands_to_process=None, projection_to_match=25832, clean=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join_s2_tiles(
    mosaic_tile_folder,
    out_folder,
    tmp_dir,
    prefix=&#34;&#34;,
    clip_geom=None,
    harmonisation=False,
    nodata_value=0.0,
    pixel_width=None,
    pixel_height=None,
    bands_to_process=None,
    projection_to_match=25832,
    clean=False,
):
    bands = (
        [
            &#34;B02_10m&#34;,
            &#34;B03_10m&#34;,
            &#34;B04_10m&#34;,
            &#34;B08_10m&#34;,
            &#34;B05_20m&#34;,
            &#34;B06_20m&#34;,
            &#34;B07_20m&#34;,
            &#34;B8A_20m&#34;,
            &#34;B11_20m&#34;,
            &#34;B12_20m&#34;,
        ]
        if bands_to_process is None
        else bands_to_process
    )

    created = []
    for band in bands:
        images = glob(mosaic_tile_folder + f&#34;*_{band}.tif&#34;)

        reprojected = reproject_raster(
            images,
            projection_to_match,
            tmp_dir,
            copy_if_already_correct=False,
            dst_nodata=nodata_value,
        )

        if clip_geom is not None:
            reprojected = clip_raster(
                reprojected, clip_geom, out_path=tmp_dir, crop_to_geom=False
            )

        output = merge_rasters(
            reprojected,
            out_folder + prefix + band + &#34;.tif&#34;,
            tmp=tmp_dir,
            harmonisation=harmonisation,
            nodata_value=nodata_value,
            pixel_width=pixel_width,
            pixel_height=pixel_height,
        )

        created.append(output)

    if clean:
        tmp_files = glob(tmp_dir + &#34;*.tif&#34;)
        for f in tmp_files:
            try:
                os.remove(f)
            except:
                pass

    return created</code></pre>
</details>
</dd>
<dt id="buteo.earth_observation.s2_mosaic.mosaic_tile_s2"><code class="name flex">
<span>def <span class="ident">mosaic_tile_s2</span></span>(<span>s2_files, out_folder, tmp_folder, ideal_date=None, max_time_delta=60.0, max_images=6, tile_name=None, quality_to_update=5, min_improvement=0.5, time_penalty=7, feather_dist=11, use_image=None, harmonise=True, max_harmony=50, quality_threshold=105, output_scl=False, output_tracking=False, output_quality=False, process_bands=None, clean_tmp_folder=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mosaic_tile_s2(
    s2_files,
    out_folder,
    tmp_folder,
    ideal_date=None,
    max_time_delta=60.0,
    max_images=6,
    tile_name=None,
    quality_to_update=5,
    min_improvement=0.5,
    time_penalty=7,
    feather_dist=11,
    use_image=None,
    harmonise=True,
    max_harmony=50,
    quality_threshold=105,
    output_scl=False,
    output_tracking=False,
    output_quality=False,
    process_bands=None,
    clean_tmp_folder=False,
):
    start = time()

    tile_names = files_to_tiles(s2_files)
    unzipped_paths = files_to_unzipped_paths(s2_files, tmp_folder)

    created_images = []
    for tile_name in tile_names:
        tiles = get_tile_files_from_paths(unzipped_paths, tile_name)

        metadatas = []
        best_score = 0
        best_idx = 0
        best_date = None
        best_time = 9999999999.9

        for index, tile in enumerate(tiles):
            print(
                f&#34;Finding best image for tile: {tile_name}. {index + 1}/{len(tiles)} images&#34;
            )
            metadata = get_metadata(tile)
            quality = assess_quality(tile)
            tile_score = np.average(quality)
            metadata[&#34;quality_score&#34;] = tile_score

            if ideal_date is not None or use_image is not None:
                comp_time = None
                if use_image is not None:
                    comp_time = use_image
                else:
                    comp_time = ideal_date

                time_delta = abs(
                    (
                        metadata[&#34;PRODUCT_STOP_TIME&#34;]
                        - datetime.datetime.strptime(comp_time, &#34;%Y%m%d&#34;).replace(
                            tzinfo=datetime.timezone.utc
                        )
                    ).total_seconds()
                    / 86400
                )

            quality_adjustment = 1
            if ideal_date is not None:
                # 1 % reduction in quality for every x days.
                quality_adjustment = (100 - time_delta / time_penalty) / 100

            if use_image:
                if time_delta &lt; best_time:
                    best_score = tile_score
                    best_idx = index
                    best_date = metadata[&#34;PRODUCT_STOP_TIME&#34;]
                    best_time = time_delta
            elif (tile_score * quality_adjustment) &gt; best_score:
                best_score = tile_score
                best_idx = index
                best_date = metadata[&#34;PRODUCT_STOP_TIME&#34;]

            metadata[&#34;quality&#34;] = quality
            metadatas.append(metadata)

        print(
            f&#34;Best image found: {os.path.basename(tiles[best_idx])} @ {round(best_score, 3)}&#34;
        )

        metadatas_thresholded = []
        print(&#34;Adjusting scores by temporal distance.&#34;)
        for index, tile in enumerate(tiles):
            metadata = metadatas[index]
            recording_time = metadata[&#34;PRODUCT_STOP_TIME&#34;]

            time_delta = abs((best_date - recording_time).total_seconds() / 86400)

            # 1 % reduction in quality for every x days.
            quality_adjustment = (100 - time_delta / time_penalty) / 100

            metadatas[index][&#34;quality&#34;] = np.rint(
                (metadatas[index][&#34;quality&#34;].astype(&#34;float32&#34;) * quality_adjustment)
            ).astype(&#34;uint8&#34;)
            metadatas[index][&#34;quality_score&#34;] = np.average(metadatas[index][&#34;quality&#34;])

            if time_delta &lt; max_time_delta:
                metadatas_thresholded.append(metadatas[index])

        # Ordering metadatas by quality
        metadatas = metadatas_thresholded
        metadatas = sorted(metadatas, key=lambda i: i[&#34;quality_score&#34;], reverse=True)

        # if central_images, move it to the front
        if use_image is not None:
            for index, meta in enumerate(metadatas):
                if meta[&#34;PRODUCT_STOP_TIME&#34;] == best_date:
                    metadatas.insert(0, metadatas.pop(index))
                    break

        scl_array = raster_to_array(
            metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;], filled=True, output_2d=True
        )
        tracking_array = np.zeros_like(scl_array, dtype=&#34;uint8&#34;)

        current_valid_mask = erode_mask(scl_array != 0, feather_dist)
        current_quality = metadatas[0][&#34;quality&#34;] * current_valid_mask
        current_quality_score = np.average(current_quality)

        print(&#34;Tracking..&#34;)
        print(f&#34;Current quality: {round(current_quality_score, 4)}&#34;)
        used_images = [0]
        tested_images = 1
        while (
            current_quality_score &lt; quality_threshold
            and len(used_images) &lt; max_images
            and tested_images &lt; len(metadatas)
        ):

            best_idx = None
            best_improvement = None
            best_valid_sum = None
            best_tile_quality = None
            best_tile_scl = None
            best_improvement_mask = None

            first = True
            for index, metadata in enumerate(metadatas):
                if index in used_images:
                    continue

                tile_quality = metadata[&#34;quality&#34;]
                tile_scl = raster_to_array(
                    metadata[&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;], filled=True, output_2d=True
                )

                valid_mask = erode_mask(tile_scl != 0, feather_dist)

                improvement_mask = valid_mask &amp; smooth_mask(
                    tile_quality &gt; (current_quality * (1 + (quality_to_update / 100)))
                )
                improvement_percent = np.average(improvement_mask) * 100

                if first:
                    best_idx = index
                    best_improvement = improvement_percent
                    best_valid_sum = valid_mask.sum()
                    best_tile_quality = tile_quality
                    best_tile_scl = tile_scl
                    best_improvement_mask = improvement_mask
                    first = False
                else:
                    if improvement_percent &gt; best_improvement:
                        best_idx = index
                        best_improvement = improvement_percent
                        best_valid_sum = valid_mask.sum()
                        best_tile_quality = tile_quality
                        best_tile_scl = tile_scl
                        best_improvement_mask = improvement_mask

            tile_quality = np.where(
                best_improvement_mask, best_tile_quality, current_quality
            )
            tile_quality_score = np.average(tile_quality)

            if (tile_quality_score - current_quality_score) &lt; min_improvement and (
                best_valid_sum &lt;= current_valid_mask.sum()
            ):
                break

            # Update tracking arrays
            tracking_array = np.where(best_improvement_mask, best_idx, tracking_array)
            scl_array = np.where(best_improvement_mask, best_tile_scl, scl_array)
            current_quality = tile_quality
            current_quality_score = tile_quality_score
            used_images.append(best_idx)
            tested_images += 1

            print(f&#34;Current quality: {round(current_quality_score, 4)}&#34;)

        bands_to_process = (
            [
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B02&#34;},
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B03&#34;},
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B04&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B05&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B06&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B07&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B8A&#34;},
                {&#34;size&#34;: &#34;10m&#34;, &#34;band&#34;: &#34;B08&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B11&#34;},
                {&#34;size&#34;: &#34;20m&#34;, &#34;band&#34;: &#34;B12&#34;},
            ]
            if process_bands is None
            else process_bands
        )

        if len(used_images) &gt; 1:
            print(&#34;Pre-calculating feathers&#34;)
            tracking_20m = feather(
                tracking_array, np.array(used_images, dtype=&#34;uint8&#34;), feather_dist
            )

            tracking_10m = raster_to_array(
                internal_resample_raster(
                    array_to_raster(
                        tracking_20m, reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;]
                    ),
                    target_size=metadatas[0][&#34;paths&#34;][&#34;10m&#34;][&#34;B04&#34;],
                    resample_alg=&#34;average&#34;,
                ),
                filled=True,
            )

            tracking_60m = raster_to_array(
                internal_resample_raster(
                    array_to_raster(
                        tracking_20m, reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;]
                    ),
                    target_size=metadatas[0][&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
                    resample_alg=&#34;average&#34;,
                ),
                filled=True,
            )

        print(&#34;Harmonising and merging tiles&#34;)
        for pi, process_band in enumerate(bands_to_process):
            size = process_band[&#34;size&#34;]
            name = process_band[&#34;band&#34;]
            tile_outname = out_folder + f&#34;{tile_name}_{name}_{size}.tif&#34;

            print(f&#34;Now processing {pi + 1}/{len(bands_to_process)}: {name} @ {size}&#34;)

            out_arr = None

            master_arr = None
            master_quality = None
            for index, image in enumerate(used_images):
                metadata = metadatas[image]

                band_arr = raster_to_array(
                    metadata[&#34;paths&#34;][size][name], filled=True, output_2d=True
                )

                if len(used_images) == 1:
                    out_arr = band_arr
                    continue

                if harmonise and index == 0:
                    master_arr = resample_array(
                        band_arr,
                        metadata[&#34;paths&#34;][size][&#34;B04&#34;],
                        metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
                    )
                    master_quality = resample_array(
                        metadata[&#34;quality&#34;],
                        metadata[&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                        metadata[&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;],
                    )

                if harmonise and index != 0:

                    band_arr = harmonise_band(
                        band_arr,
                        metadata,
                        size,
                        name,
                        master_arr,
                        master_quality,
                        max_harmony=max_harmony,
                    )

                feather_scale = None
                if size == &#34;10m&#34;:
                    feather_scale = tracking_10m[:, :, index]
                elif size == &#34;20m&#34;:
                    feather_scale = tracking_20m[:, :, index]
                elif size == &#34;60m&#34;:
                    feather_scale = tracking_60m[:, :, index]
                else:
                    raise Exception(&#34;Unknown band size.&#34;)

                if index == 0:
                    out_arr = feather_scale * band_arr
                else:
                    out_arr += feather_scale * band_arr

            ref = None
            if size == &#34;10m&#34;:
                ref = metadatas[0][&#34;paths&#34;][&#34;10m&#34;][&#34;B04&#34;]
            elif size == &#34;20m&#34;:
                ref = metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;B04&#34;]
            elif size == &#34;60m&#34;:
                ref = metadatas[0][&#34;paths&#34;][&#34;60m&#34;][&#34;B04&#34;]

            created_images.append(tile_outname)

            array_to_raster(
                np.rint(out_arr).astype(&#34;uint16&#34;),
                reference=ref,
                out_path=tile_outname,
            )

        if output_tracking:
            tracking_outname = out_folder + f&#34;{tile_name}_tracking_20m.tif&#34;
            created_images.append(tracking_outname)
            array_to_raster(
                tracking_array,
                reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                out_path=tracking_outname,
            )

        if output_scl:
            scl_outname = out_folder + f&#34;{tile_name}_SCL_20m.tif&#34;
            created_images.append(scl_outname)
            array_to_raster(
                scl_array,
                reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                out_path=scl_outname,
            )

        if output_quality:
            quality_outname = out_folder + f&#34;{tile_name}_quality_20m.tif&#34;
            created_images.append(quality_outname)
            array_to_raster(
                current_quality,
                reference=metadatas[0][&#34;paths&#34;][&#34;20m&#34;][&#34;SCL&#34;],
                out_path=quality_outname,
            )

        timing(start)

    if clean_tmp_folder:
        tmp_files = glob(tmp_folder + &#34;*.tif&#34;)
        for f in tmp_files:
            try:
                os.remove(f)
            except:
                pass

    return created_images</code></pre>
</details>
</dd>
<dt id="buteo.earth_observation.s2_mosaic.resample_array"><code class="name flex">
<span>def <span class="ident">resample_array</span></span>(<span>arr, original_reference, target_reference, resample_alg='average')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resample_array(arr, original_reference, target_reference, resample_alg=&#34;average&#34;):
    return raster_to_array(
        internal_resample_raster(
            array_to_raster(
                arr,
                reference=original_reference,
            ),
            target_size=target_reference,
            resample_alg=resample_alg,
        ),
        filled=True,
        output_2d=True,
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="buteo.earth_observation" href="index.html">buteo.earth_observation</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="buteo.earth_observation.s2_mosaic.files_to_tiles" href="#buteo.earth_observation.s2_mosaic.files_to_tiles">files_to_tiles</a></code></li>
<li><code><a title="buteo.earth_observation.s2_mosaic.files_to_unzipped_paths" href="#buteo.earth_observation.s2_mosaic.files_to_unzipped_paths">files_to_unzipped_paths</a></code></li>
<li><code><a title="buteo.earth_observation.s2_mosaic.get_tile_files_from_paths" href="#buteo.earth_observation.s2_mosaic.get_tile_files_from_paths">get_tile_files_from_paths</a></code></li>
<li><code><a title="buteo.earth_observation.s2_mosaic.harmonise_band" href="#buteo.earth_observation.s2_mosaic.harmonise_band">harmonise_band</a></code></li>
<li><code><a title="buteo.earth_observation.s2_mosaic.join_s2_tiles" href="#buteo.earth_observation.s2_mosaic.join_s2_tiles">join_s2_tiles</a></code></li>
<li><code><a title="buteo.earth_observation.s2_mosaic.mosaic_tile_s2" href="#buteo.earth_observation.s2_mosaic.mosaic_tile_s2">mosaic_tile_s2</a></code></li>
<li><code><a title="buteo.earth_observation.s2_mosaic.resample_array" href="#buteo.earth_observation.s2_mosaic.resample_array">resample_array</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>